[{"categories":["Project"],"content":"Unity Project","date":"2021-01-28","objectID":"/unity_room/","tags":["Unity","app"],"title":"[Project] 유니티를 이용한 가구배치 앱","uri":"/unity_room/"},{"categories":["Project"],"content":"유니티를 이용한 가구배치 앱 ","date":"2021-01-28","objectID":"/unity_room/:0:0","tags":["Unity","app"],"title":"[Project] 유니티를 이용한 가구배치 앱","uri":"/unity_room/"},{"categories":["Project"],"content":"● 제작 인원 - 1명 ","date":"2021-01-28","objectID":"/unity_room/:0:1","tags":["Unity","app"],"title":"[Project] 유니티를 이용한 가구배치 앱","uri":"/unity_room/"},{"categories":["Project"],"content":"● 제작 기간 - 1 개월 ","date":"2021-01-28","objectID":"/unity_room/:0:2","tags":["Unity","app"],"title":"[Project] 유니티를 이용한 가구배치 앱","uri":"/unity_room/"},{"categories":["Project"],"content":"● 용도 - 가구 배치 ","date":"2021-01-28","objectID":"/unity_room/:0:3","tags":["Unity","app"],"title":"[Project] 유니티를 이용한 가구배치 앱","uri":"/unity_room/"},{"categories":["Project"],"content":"● 기능 가구 이동(그리드 방식, room 밖으로 가구가 나갈 수 없음) 가구가 놓을 수 없는 상황일 때에는 놓을 수 없음.(빨간색 외곽선이 생김) place, undo, rotate 버튼을 통해 가구 조작 가능 캐릭터 이동 가능(가구를 통과할 수 없음) 벽면에 가구를 놓을 수 있음(왼쪽 벽에서 오른쪽 벽으로 이동하는 등 벽 사이에 이동 시 자동으로 회전됨.) ","date":"2021-01-28","objectID":"/unity_room/:0:4","tags":["Unity","app"],"title":"[Project] 유니티를 이용한 가구배치 앱","uri":"/unity_room/"},{"categories":["Project"],"content":"● unity 사용 ","date":"2021-01-28","objectID":"/unity_room/:0:5","tags":["Unity","app"],"title":"[Project] 유니티를 이용한 가구배치 앱","uri":"/unity_room/"},{"categories":["Project"],"content":"● apk 파일 malive.apk ","date":"2021-01-28","objectID":"/unity_room/:0:6","tags":["Unity","app"],"title":"[Project] 유니티를 이용한 가구배치 앱","uri":"/unity_room/"},{"categories":["Flutter"],"content":"Flutter Practice","date":"2021-01-25","objectID":"/flutter_sample_note_1/","tags":["Flutter","note","app"],"title":"Flutter_sample_note_1","uri":"/flutter_sample_note_1/"},{"categories":["Flutter"],"content":"Flutter Practice ","date":"2021-01-25","objectID":"/flutter_sample_note_1/:0:0","tags":["Flutter","note","app"],"title":"Flutter_sample_note_1","uri":"/flutter_sample_note_1/"},{"categories":["Flutter"],"content":"1. Flutter_sample_note_1 ","date":"2021-01-25","objectID":"/flutter_sample_note_1/:1:0","tags":["Flutter","note","app"],"title":"Flutter_sample_note_1","uri":"/flutter_sample_note_1/"},{"categories":["Flutter"],"content":"● 노트 ","date":"2021-01-25","objectID":"/flutter_sample_note_1/:1:1","tags":["Flutter","note","app"],"title":"Flutter_sample_note_1","uri":"/flutter_sample_note_1/"},{"categories":["Flutter"],"content":"● Flutter 사용 ","date":"2021-01-25","objectID":"/flutter_sample_note_1/:1:2","tags":["Flutter","note","app"],"title":"Flutter_sample_note_1","uri":"/flutter_sample_note_1/"},{"categories":["Flutter"],"content":"● Git 위치 Flutter_sample_note_1 ","date":"2021-01-25","objectID":"/flutter_sample_note_1/:1:3","tags":["Flutter","note","app"],"title":"Flutter_sample_note_1","uri":"/flutter_sample_note_1/"},{"categories":["Flutter"],"content":"Flutter Practice","date":"2021-01-27","objectID":"/flutter_sample_bookstore/","tags":["Flutter","bookstore","app"],"title":"Flutter_sample_bookstore","uri":"/flutter_sample_bookstore/"},{"categories":["Flutter"],"content":"Flutter Practice ","date":"2021-01-27","objectID":"/flutter_sample_bookstore/:0:0","tags":["Flutter","bookstore","app"],"title":"Flutter_sample_bookstore","uri":"/flutter_sample_bookstore/"},{"categories":["Flutter"],"content":"2. flutter_sample_bookstore ","date":"2021-01-27","objectID":"/flutter_sample_bookstore/:1:0","tags":["Flutter","bookstore","app"],"title":"Flutter_sample_bookstore","uri":"/flutter_sample_bookstore/"},{"categories":["Flutter"],"content":"● 용도 - Book Store ","date":"2021-01-27","objectID":"/flutter_sample_bookstore/:1:1","tags":["Flutter","bookstore","app"],"title":"Flutter_sample_bookstore","uri":"/flutter_sample_bookstore/"},{"categories":["Flutter"],"content":"● Flutter 사용 ","date":"2021-01-27","objectID":"/flutter_sample_bookstore/:1:2","tags":["Flutter","bookstore","app"],"title":"Flutter_sample_bookstore","uri":"/flutter_sample_bookstore/"},{"categories":["Flutter"],"content":"● Git 위치 Flutter_sample_bookstore ","date":"2021-01-27","objectID":"/flutter_sample_bookstore/:1:3","tags":["Flutter","bookstore","app"],"title":"Flutter_sample_bookstore","uri":"/flutter_sample_bookstore/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/12787 풀이: IPv8 주소가 주어진다면, 정수로 정수가 주어진다면, IPv8 주소로 변환하여 출력한다. 정수의 범위가 64비트이므로 unsigned long long 형을 사용하도록 하자!! 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cstring.h\u003e#define ul unsigned long long using namespace std; ul c; int main() { int i, t, y, n, m, d; cin \u003e\u003e n; while (n--) { string s; cin \u003e\u003e m; if (m == 1) { char *r = new char[40], *e; cin \u003e\u003e r; i = 8, c = 0; e = strtok(r, \".\"); do { i--, y = atoi(e); for (t = 7; t \u003e= 0; t--) if (y \u0026 (1 \u003c\u003c t)) c |= (ul)1 \u003c\u003c ((i * 8) + t); } while (e = strtok(NULL, \".\")); cout \u003c\u003c c \u003c\u003c endl; } else { cin \u003e\u003e c; for (i = 7; i \u003e= 0; i--, s += to_string(d) + '.') for (d = 0, t = 7; t \u003e= 0; t--) if (c \u0026 (ul)1 \u003c\u003c ((i * 8) + t)) d |= 1 \u003c\u003c t; s.erase(s.end()-1); cout \u003c\u003c s \u003c\u003c endl; } } } ","date":"2021-01-04","objectID":"/2021-01-04-12787/:0:0","tags":["algorithm","C++"],"title":"[백준]12787 지금 밥이 문제냐","uri":"/2021-01-04-12787/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17273 풀이: 카드 1장을 공장장의 말에 따라 뒤집는다. 마지막 명령이 끝났을 때, 카드의 윗면에 그려진 숫자를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int n, m, a, b, d; cin \u003e\u003e n \u003e\u003e m \u003e\u003e a \u003e\u003e b; for (n = a; m--;) { cin \u003e\u003e d; if (n \u003c= d) n = n == a ? b : a; } cout \u003c\u003c n \u003c\u003c endl; } ","date":"2021-01-03","objectID":"/2021-01-03-17273/:0:0","tags":["algorithm","C++"],"title":"[백준]17273 카드 공장 (Small)","uri":"/2021-01-03-17273/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17271 풀이: [백준]2624 동전 바꿔주기 참고 코드: 사용언어 : c++ #include\u003ciostream\u003eusing namespace std; long long d[10005] = { 1,1 }, n, m, i; int main() { cin \u003e\u003e n \u003e\u003e m; for (i = 2; i \u003c= n; i++) d[i] = (d[i - 1] + (i - m \u003e= 0 ? d[i - m] : 0)) % 1000000007; cout \u003c\u003c d[n] \u003c\u003c endl; } ","date":"2021-01-02","objectID":"/2021-01-02-17271/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]17271 리그 오브 레전설 (Small)","uri":"/2021-01-02-17271/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17269 풀이: 이름 두개를 받은 후 글자의 획수를 더하여 한개씩 진행한다. 최종 더한 두 숫자를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int main() { int n, m, i, t, q[26] = {3,2,1,2,4,3,1,3,1,1,3,1,3,2,1,2,2,2,1,2,1,1,1,2,2,1}; string a, b; cin \u003e\u003e n \u003e\u003e m \u003e\u003e a \u003e\u003e b; vector\u003cvector\u003cint\u003e\u003e v(1); for (i = 0, t = 0;; i++, t++) { if (i \u003e= n \u0026\u0026 t \u003e= m)break; if (i \u003c n) v[0].push_back(q[a[i] - 'A']); if (t \u003c m) v[0].push_back(q[b[t] - 'A']); } while (1) { vector\u003cint\u003e w; for (i = 0; i \u003c v.back().size() - 1; i++) { w.push_back((v.back()[i] + v.back()[i + 1]) % 10); } v.push_back(w); if (w.size() == 2) break; } cout \u003c\u003c v.back()[0] * 10 + v.back()[1] \u003c\u003c \"%\" \u003c\u003c endl; } ","date":"2021-01-01","objectID":"/2021-01-01-17269/:0:0","tags":["algorithm","C++"],"title":"[백준]17269 이름궁합 테스트","uri":"/2021-01-01-17269/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17268 풀이: n = 2 …. 1 n = 4 …. 2 n = 6 …. 5 n = 8 …. 14 . . . 1, 2, 5, 14 … 로 진행되는 수열인 카탈란 수 이다. 카탈란 수는 $$ C_i = {2i \\choose i} - {2i \\choose i + 1} $$ 이다. 이를 점화식으로 표현하면 $$ C_n = \\sum_{i=0}^{n-1}C_iC_{n-1-i} $$ 이 된다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; long long dp[5005] = { 1 }, n, i, t; int main() { cin \u003e\u003e n; for (i = 1; i \u003c= n / 2; i++) { for (t = 0; t \u003c i; t++) { dp[i] = (dp[i] + dp[t] * dp[i - 1 - t]) % 987654321; } } cout \u003c\u003c dp[n / 2] \u003c\u003c endl; } ","date":"2020-12-31","objectID":"/2020-12-31-17268/:0:0","tags":["algorithm","C++","DP","조합"],"title":"[백준]17268 미팅의 저주","uri":"/2020-12-31-17268/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17267 풀이: 스타트 지점부터 움직일 수 있는 지점으로 움직인다. 움직일 때, 왼쪽으로 움직였다면 left 값을 -1 해주고, 오른쪽으로 움직였다면 right값을 -1해주면서 움직이자. 주의사항 : 위아래를 한칸씩 움직일 경우 안되는 case가 존재. 움직일 수 있는 한도 내에서 다 움직이자!!. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003e#include \u003cstring.h\u003eusing namespace std; int w[1005][1005]; int main() { int i, t, n, m, l, r, c = 0; cin \u003e\u003e n \u003e\u003e m \u003e\u003e l \u003e\u003e r; queue\u003cvector\u003cint\u003e\u003e q; memset(w, 0, sizeof(w)); for (i = 0; i \u003c n; i++) { for (t = 0; t \u003c m; t++) { scanf(\"%1d\", \u0026w[i][t]); if (w[i][t] == 2) q.push({ i,t,l,r }); } } while (!q.empty()) { c++, i = q.front()[0], t = q.front()[1], l = q.front()[2], r = q.front()[3]; while (++i \u003c n \u0026\u0026 !w[i][t]) w[i][t] = 1, q.push({ i,t,l,r }); i = q.front()[0]; while (--i \u003e= 0 \u0026\u0026 !w[i][t]) w[i][t] = 1, q.push({ i,t,l,r }); i = q.front()[0]; if (t \u003c m - 1 \u0026\u0026 !w[i][t + 1] \u0026\u0026 r \u003e 0) w[i][t + 1] = 1, q.push({ i,t + 1,l,r - 1 }); if (t \u003e 0 \u0026\u0026 !w[i][t - 1] \u0026\u0026 l \u003e 0) w[i][t - 1] = 1, q.push({ i,t - 1,l - 1,r }); q.pop(); } cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-12-30","objectID":"/2020-12-30-17267/:0:0","tags":["algorithm","C++","BFS"],"title":"[백준]17267 상남자","uri":"/2020-12-30-17267/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17266 풀이: 가로등들의 사이 길이 / 2 가 가장 긴 것을 찾는다. 단, 첫 가로등과 마지막 가로등은 왼쪽 끝과 오른쪽 끝에 가로등이 없기 때문에 /2를 하지않는다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int n, m, i, x, v[100001], c = 0, d = 0, s, f = 1; cin \u003e\u003e n \u003e\u003e m; fill(v, v + n + 1, 0); for (i = 0; i \u003c m; i++) { cin \u003e\u003e x; v[x] = 1; } for (i = 0; i \u003c= n; i++) { if (v[i]) { if (f) s = i, f = 0; else s = s \u003e (i - d + 1) / 2 ? s : (i - d + 1) / 2; d = i; } if (i == n) s = s \u003e i - d ? s : i - d; } cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-12-29","objectID":"/2020-12-29-17266/:0:0","tags":["algorithm","C++"],"title":"[백준]17266 어두운 굴다리","uri":"/2020-12-29-17266/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17264 풀이: 이길 수 있는 사람을 set에 모아놓는다. 만약 만난 사람이 set에 존재한다면, score에 획득 점수를 더해준다. 만약 만난 사람이 set에 존재하지 않는다면, score에 떨어지는 점수를 빼준다. 만약 score가 IRON 티어에서 벗어나기 위한 점수보다 높아진다면, “I AM NOT IRONMAN!!” 을 출력한다. 모든 플레이어를 만났음에도 IRON 티어에서 벗어나기 위한 점수보다 낮다면, “I AM IRONMAN!!“을 출력한다. score값은 음수가 될 수 없으므로 주의하자!!! 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cset\u003eusing namespace std; int main() { int n, p, w, l, g, c = 0; set\u003cstring\u003e s; string t, h; for (cin \u003e\u003e n \u003e\u003e p \u003e\u003e w \u003e\u003e l \u003e\u003e g; p--;s.insert(h==\"W\"?t:\"\")) cin \u003e\u003e t \u003e\u003e h; for (; n--; c = c \u003c 0 ? 0 : c) { cin \u003e\u003e t; c += s.find(t) != s.end() ? w : -l; if (c \u003e= g) cout \u003c\u003c \"I AM NOT IRONMAN!!\" \u003c\u003c endl, exit(0); } cout \u003c\u003c \"I AM IRONMAN!!\" \u003c\u003c endl; } ","date":"2020-12-28","objectID":"/2020-12-28-17264/:0:0","tags":["algorithm","C++","해시"],"title":"[백준]17264 I AM IRONMAN","uri":"/2020-12-28-17264/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17263 풀이: 받아온 수 중 가장 큰 수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int n, a, c = 0; cin \u003e\u003e n; while (n--) { cin \u003e\u003e a; if (c \u003c a) c = a; } cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-12-27","objectID":"/2020-12-27-17263/:0:0","tags":["algorithm","C++"],"title":"[백준]17263 Sort 마스터 배지훈","uri":"/2020-12-27-17263/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/14614 풀이: C가 짝수라면 A를 C가 홀수라면 A 와 B를 XOR한 값을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int a, b; string c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; if ((int)(c[c.size() - 1] - '0') % 2) a ^= b; cout \u003c\u003c a \u003c\u003c endl; } ","date":"2020-12-26","objectID":"/2020-12-26-14614/:0:0","tags":["algorithm","C++","수학"],"title":"[백준]14614 Calculate!","uri":"/2020-12-26-14614/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/14612 풀이: order를 \u003c주문시간, 테이블번호\u003e 를 변수로 하는 vector에 차곡차곡 쌓는다. 각 주문이 끝난 후 vector의 들어있는 테이블 번호를 순서대로 출력한다. 만약 sort가 들어왔다면, 주문시간을 기준으로 vector를 정렬한다 만약 complete가 들어왔다면, 완성된 테이블 번호를 vector에서 제거한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int main() { int n, m, a, b, i; vector\u003cpair\u003cint, int\u003e\u003e v; cin \u003e\u003e n \u003e\u003e m; while (n--) { string s; cin \u003e\u003e s; if (s == \"order\") { cin \u003e\u003e a \u003e\u003e b; v.push_back({ b,a }); } else if (s == \"sort\") { sort(v.begin(), v.end()); } else { cin \u003e\u003e a; for (i = 0; i \u003c v.size(); i++) { if (v[i].second == a) { v.erase(v.begin() + i); break; } } } if (v.empty()) { cout \u003c\u003c \"sleep\" \u003c\u003c endl; } else { for (i = 0; i \u003c v.size(); i++) { cout \u003c\u003c v[i].second \u003c\u003c \" \"; } cout \u003c\u003c endl; } } } ","date":"2020-12-25","objectID":"/2020-12-25-14612/:0:0","tags":["algorithm","C++"],"title":"[백준]14612 김식당","uri":"/2020-12-25-14612/"},{"categories":["백준"],"content":"algorithm","date":"2020-12-24","objectID":"/2020-12-24-12778/","tags":["algorithm","C++","구현"],"title":"[백준]12778 CTP공국으로 이민 가자","uri":"/2020-12-24-12778/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/12778 풀이: 만약 C라면, 문자열을 숫자로 출력한다. 만약 N이라면, 숫자를 문자열로 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int a, i, n; char b; cin \u003e\u003e n; while (n--) { cin \u003e\u003e a \u003e\u003e b; if (b == 'C') { for (i = 0; i \u003c a; i++) { char c; cin \u003e\u003e c; cout \u003c\u003c (int)(c - 'A' + 1) \u003c\u003c \" \"; } } else { for (i = 0; i \u003c a; i++) { int c; cin \u003e\u003e c; cout \u003c\u003c (char)('A' + c - 1) \u003c\u003c \" \"; } } cout \u003c\u003c endl; } } ","date":"2020-12-24","objectID":"/2020-12-24-12778/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]12778 CTP공국으로 이민 가자","uri":"/2020-12-24-12778/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/12779 풀이: 약수의 갯수가 홀수라는 것은 “제곱수” 라는 것을 의미한다. 그러므로 제곱수의 갯수 / 전체 갯수를 한다면 답을 구할 수 있다. 주의 확률이 0일 경우 0을 출력해야한다. 2^60 까지의 숫자이므로 int형에 들어갈 수 없다. 기약분수로 출력해야하므로 최대 공약수로 나누어주는 작업을 해주자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cmath.h\u003eusing namespace std; long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; } int main() { long long a, b, i, g, c = 0; cin \u003e\u003e a \u003e\u003e b; for (i = sqrt(a); i * i \u003c= b; i++) { c += i * i \u003e a ? 1 : 0; } if (c == 0) { cout \u003c\u003c 0 \u003c\u003c endl; } else { g = gcd(b - a, c); cout \u003c\u003c c / g \u003c\u003c \"/\" \u003c\u003c (b - a) / g \u003c\u003c endl; } } ","date":"2020-12-24","objectID":"/2020-12-24-12779/:0:0","tags":["algorithm","C++"],"title":"[백준]12779 상품 is 뭔들","uri":"/2020-12-24-12779/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/12780 풀이: H의 1번 문자열부터 끝까지 검사하며 N이 몇 번 등장하는지 확인한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main() { string s, a; int c = 0; cin \u003e\u003e s \u003e\u003e a; for (int i = 0; i \u003c= s.length() - a.length(); i++) { if (s.substr(i, a.length()) == a) c++; } cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-12-24","objectID":"/2020-12-24-12780/:0:0","tags":["algorithm","C++"],"title":"[백준]12780 원피스","uri":"/2020-12-24-12780/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-27","objectID":"/2020-04-27-1388/","tags":["algorithm","C++","파싱"],"title":"[백준]1388 바닥 장식","uri":"/2020-04-27-1388/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1388 풀이: 같은 행에 연속된 ‘-’ 이 몇 쌍이 있는지 센다. 같은 방식으로 같은 열에 연속된 ‘|’ 이 몇 쌍이 있는지 센다. 두 수를 더하여 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, t, c; string s[105]; int main() { cin \u003e\u003e n \u003e\u003e m; for (; i \u003c n; i++) cin \u003e\u003e s[i]; for (i = 0; i \u003c n; i++) for (t = 0; t \u003c m; t++) { if (s[i][t] == '-')if (t == m - 1 || s[i][t + 1] == '|')c++; if (s[i][t] == '|')if (i == n - 1 || s[i + 1][t] == '-')c++; } cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-04-27","objectID":"/2020-04-27-1388/:0:0","tags":["algorithm","C++","파싱"],"title":"[백준]1388 바닥 장식","uri":"/2020-04-27-1388/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-26","objectID":"/2020-04-26-1356/","tags":["algorithm","C++","수학"],"title":"[백준]1356 유진수","uri":"/2020-04-26-1356/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1356 풀이: 1의 자릿수 == 10의 자릿수*…*n자릿수 1의 자릿수 * 10의 자릿수 == 100의 자릿수 *…*n자릿수 . . . 1의 자릿수*…*n-1자릿수 == n 자릿수 중 앞의 값과 뒤의 값이 같은 것이 하나라도 있다면, YES를 하나도 없다면 NO를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n = 1, m = 1, i, t, f; string s; int main() { cin \u003e\u003e s; for (i = 1; i \u003c s.size(); f += n == m, n = 1, m = 1, i++) { for (t = 0; t \u003c i; t++) n *= (s[t] - 48); for (t = i; t \u003c s.size(); t++) m *= (s[t] - 48); } printf(\"%s\", f ? \"YES\" : \"NO\"); } ","date":"2020-04-26","objectID":"/2020-04-26-1356/:0:0","tags":["algorithm","C++","수학"],"title":"[백준]1356 유진수","uri":"/2020-04-26-1356/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-25","objectID":"/2020-04-25-1268/","tags":["algorithm","C++"],"title":"[백준]1268 임시 반장 정하기","uri":"/2020-04-25-1268/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1268 풀이: 현재 상태에서 제일 많은 학생수를 S, 그 학생수를 가진 학생을 C라고 하자. 1번 학생이 몇 명의 학생과 같은 반을 했었는지를 저장하고, 그 값이 S보다 많다면 S를 교체하고 C에 1을 저장한다. . . . n번 학생이 몇 명의 학생과 같은 반을 했었는지를 저장하고, 그 값이 S보다 많다면 S를 교체하고 C에 n을 저장한다. 전체를 다 탐색 한 후 C를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i, t, y, d, s, c, a[1005][5], b[1005][1005]; int main() { cin \u003e\u003e n; for (; i \u003c n; i++) for (t = 0; t \u003c 5; t++) cin \u003e\u003e a[i][t]; for (i = 0; i \u003c n; i++, d = 0) { for (t = 0; t \u003c 5; t++) for (y = 0; y \u003c n; y++) if (a[i][t] == a[y][t])d += !b[i][y], b[i][y] = 1; if (s \u003c d) s = d, c = i; } cout \u003c\u003c c + 1 \u003c\u003c endl; } ","date":"2020-04-25","objectID":"/2020-04-25-1268/:0:0","tags":["algorithm","C++"],"title":"[백준]1268 임시 반장 정하기","uri":"/2020-04-25-1268/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-24","objectID":"/2020-04-24-1236/","tags":["algorithm","C++","탐색"],"title":"[백준]1236 성 지키기","uri":"/2020-04-24-1236/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1236 풀이: 각 행에 경비병이 있는지 없는지 탐색한다. 경비병이 없는 행의 갯수를 Sn이라고 하자. 각 열에 경비병이 있는지 없는지 탐색한다. 경비병이 없는 열의 갯수를 Sm이라고 하자. 각 행과 열에는 경비병이 1명씩은 있어야 하므로 Sn과 Sm 중 최댓값을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, t, a[55], b[55], q, w; char c; int main() { cin \u003e\u003e n \u003e\u003e m; for (; i \u003c n; i++) for (t = 0; t \u003c m; t++) { cin \u003e\u003e c; if (c == 'X') q+=!a[i],a[i]=1,w+=!b[t],b[t]=1; } n -= q, m -= w; printf(\"%d\", n \u003c m ? m : n); } ","date":"2020-04-24","objectID":"/2020-04-24-1236/:0:0","tags":["algorithm","C++","탐색"],"title":"[백준]1236 성 지키기","uri":"/2020-04-24-1236/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-23","objectID":"/2020-04-23-17265/","tags":["algorithm","C++","백트래킹"],"title":"[백준]17265 나의 인생에는 수학과 함께","uri":"/2020-04-23-17265/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17265 풀이: 최단 거리이므로 오른쪽과 아래쪽으로만 이동한다. 현재 위치가 연산자라면, 이전까지 연산해왔던 값을 x라고 하자 연잔자를 ㅁ 라고 하고, 다음 이동할 곳의 숫자를 y라고 하자. 현재 위치의 연산자를 이용하여 x ㅁ y 를 연산한 후 다음 숫자로 이동한다. 현재 위치가 숫자라면, 현재 위치가 학교인지 판단 후 학교가 아니라면 오른쪽 또는 아래로 이동한다. 학교라면 현재까지 연산해왔던 값이 지금 저장해 놓은 최댓값보다 크다면 교체한다. 또한 현재까지 연산해왔던 값이 지금 저장해 놓은 최솟값보다 작다면 교체한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i, t, s = -4000, f = 4000, b[8][8]; char c[8][8]; void P(int x, int y, int z) { if (x == n - 1 \u0026\u0026 y == n - 1) { s = s \u003c z ? z : s; f = f \u003e z ? z : f; return; } for (int u = 0; u \u003c 2; u++) { int q = x + u, w = y - u + 1; if (q \u003e= n || w \u003e= n) continue; if (!b[q][w]) { b[q][w] = 1; if (c[x][y] == '+') P(q, w, z + c[q][w] - '0'); else if (c[x][y] == '-') P(q, w, z - c[q][w] + '0'); else if (c[x][y] == '*') P(q, w, z * (c[q][w] - '0')); else P(q, w, z); b[q][w] = 0; } } } int main() { cin \u003e\u003e n; for (; i \u003c n; i++) for (t = 0; t \u003c n; t++) cin \u003e\u003e c[i][t]; P(0, 0, c[0][0] - '0'); cout \u003c\u003c s \u003c\u003c \" \" \u003c\u003c f \u003c\u003c endl; } ","date":"2020-04-23","objectID":"/2020-04-23-17265/:0:0","tags":["algorithm","C++","백트래킹"],"title":"[백준]17265 나의 인생에는 수학과 함께","uri":"/2020-04-23-17265/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-22","objectID":"/2020-04-22-1759/","tags":["algorithm","C++","백트래킹"],"title":"[백준]1759 암호 만들기","uri":"/2020-04-22-1759/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1759 풀이: C개의 문자들을 사전순으로 정렬한다. 정렬된 문자열을 L개만큼 출력한다. 단, 최소 한 개의 모음과 두개의 자음이 있어야한다. 증가하는 순서로 있어야한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m, i, b[20]; char c[20], d[20]; void P(int x, int z) { if (x == n) { int y = 0, t = 0, r = 0; for (; y \u003c x; y++) if (d[y] == 'a' || d[y] == 'e' || d[y] == 'i' || d[y] == 'o' || d[y] == 'u') t++; else r++; if(t \u0026\u0026 r\u003e1) cout \u003c\u003c d \u003c\u003c endl; return; } for (int y = z; y \u003c m; y++) if (!b[y]) b[y] = 1, d[x] = c[y], P(x + 1, y + 1), b[y] = 0; } int main() { cin \u003e\u003e n \u003e\u003e m; for (; i \u003c m; i++) cin \u003e\u003e c[i]; sort(c, c + m); P(0, 0); } ","date":"2020-04-22","objectID":"/2020-04-22-1759/:0:0","tags":["algorithm","C++","백트래킹"],"title":"[백준]1759 암호 만들기","uri":"/2020-04-22-1759/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-21","objectID":"/2020-04-21-2089/","tags":["algorithm","C++"],"title":"[백준]2089 -2진수","uri":"/2020-04-21-2089/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2089 풀이: 2진수를 구하듯이 구한다. -2 13 ​ -6 … 1 ​ 3 … 0 ​ -1 … 1 ​ 1 … 1 13 = 11101(-2) 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n; void G(int x) { if (!x) return; G(x % -2 \u003c 0 ? (x / -2) + 1 : x / -2); if (x % -2 \u003c 0) cout \u003c\u003c -1 * (x % -2); else cout \u003c\u003c x % -2; } int main() { cin \u003e\u003e n; G(n); if (!n) cout \u003c\u003c 0; cout \u003c\u003c endl; } ","date":"2020-04-21","objectID":"/2020-04-21-2089/:0:0","tags":["algorithm","C++"],"title":"[백준]2089 -2진수","uri":"/2020-04-21-2089/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-20","objectID":"/2020-04-20-16637/","tags":["algorithm","C++"],"title":"[백준]16637 괄호 추가하기","uri":"/2020-04-20-16637/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/16637 풀이: 순서대로 사칙연산을 진행한다. 이 때, 현재 숫자만 계산하는 것, 현재 숫자 (연산자) 다음 숫자 를 계산하는 것 두 가지로 나누어 생각한다. 현재 숫자만 계산하는 것은, 이전에 계산했던 숫자 (연산자) 현재 숫자 두번째 경우는, 이전에 계산했던 숫자 (연산자) ( 현재 숫자 (연산자) 다음 숫자 ) 이렇게 두 가지 경우로 모든 구간을 연산하여 완전탐색을 돌린다. 정답의 범위가 -2^31 ~ 2^31 이므로 최댓값의 초기값을 0으로 하지않도록 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; long long n, m = -2e31; string s; void O(int x, int y, long long z) { long long q; if (x + y \u003e= n) return; if (y) { if (s[x + 1] == '+') q = s[x] + s[x + 2] - 96; if (s[x + 1] == '-') q = s[x] - s[x + 2]; if (s[x + 1] == '*') q = (s[x] - '0') * (s[x + 2] - '0'); } else q = s[x] - '0'; if (!x || s[x - 1] == '+') z += q; else if (s[x - 1] == '-') z -= q; else if (s[x - 1] == '*') z *= q; if (x + 2 * y \u003e n - 2) { m = m \u003c z ? z : m; return; } O(x + 2 * (y + 1), 0, z); O(x + 2 * (y + 1), 1, z); } int main() { cin \u003e\u003e n \u003e\u003e s; O(0, 0, 0); O(0, 1, 0); cout \u003c\u003c m \u003c\u003c endl; } ","date":"2020-04-20","objectID":"/2020-04-20-16637/:0:0","tags":["algorithm","C++"],"title":"[백준]16637 괄호 추가하기","uri":"/2020-04-20-16637/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-19","objectID":"/2020-04-19-11382/","tags":["algorithm","C++"],"title":"[백준]11382 꼬마 정민","uri":"/2020-04-19-11382/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11382 풀이: A, B, C 를 각각 문자열로 변환한다. 변환된 문자열을 한자리씩 더한다. 만약 각 자릿수의 숫자가 10이 넘어간다면 다음 자릿수에 올림을 해준다. 더해진 문자열을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main() { string a, b, c, d; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; int m = max(a.size(), max(b.size(), c.size())), s = 0; for (int i = 1; i \u003c= m; i++) { if (a.size() \u003e= i) s += a[a.size() - i] - '0'; if (b.size() \u003e= i) s += b[b.size() - i] - '0'; if (c.size() \u003e= i) s += c[c.size() - i] - '0'; d += (s % 10) + '0'; s /= 10; if (i == m \u0026\u0026 s) d += s + '0'; } reverse(d.begin(), d.end()); cout \u003c\u003c d \u003c\u003c endl; } ","date":"2020-04-19","objectID":"/2020-04-19-11382/:0:0","tags":["algorithm","C++"],"title":"[백준]11382 꼬마 정민","uri":"/2020-04-19-11382/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-18","objectID":"/2020-04-18-3056/","tags":["algorithm","C++","DP","비트마스크","MCMF"],"title":"[백준]3056 007","uri":"/2020-04-18-3056/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/3056 풀이: d[x] : 비트마스크가 x인 미션을 완료 할 확률 비트마스크 x : 나누어 준 미션은 1, 아직 나누어 주지 않은 미션은 0 비트마스크가 1, 10, 100, 1000 ….. 등 1의 갯수가 1개인 것은 첫 번째 지미 본드가 수행한다고 한다. 비트마스크가 11, 110, 1100, 11000 ….. 등 1의 갯수가 2개인 것은 두 번째 지미 본드가 수행한다고 한다. …. 비트마스크를 0 ~ (1 « n) 까지 순회한다. 현재의 비트마스크를 i 라고 하자, 그 비트의 중간에 0이 들어있다면, 그 위치에 1을 넣는다. 즉, d(i | (1 « t)(t번째 위치에 0값을 1로 바꿈)) = max(d[i | (1 « t), ​ d[i] * a[(비트마스크의 1의 갯수)(1의 갯수가 지미 본드의 번호)][t(몇 번째 미션을 수행하는지)] / 100) 로 구할 수 있다. 출력할 때 %.6f 로 출력하는 것 잊지말자!!!!!!!!!!!!!!!! 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, i, t, a[23][23]; double d[(1 \u003c\u003c 22)] = { 1 }; int main() { cin \u003e\u003e n; for (; i \u003c n; i++)for (t = 0; t \u003c n; t++)cin \u003e\u003e a[i][t]; for (i = 0; i \u003c (1 \u003c\u003c n);i++) for (t = 0; t \u003c n; t++) if (!(i \u0026 (1 \u003c\u003c t))) d[i | (1 \u003c\u003c t)] = max(d[i | (1 \u003c\u003c t)], d[i] * a[__builtin_popcount(i)][t] / 100); printf(\"%.6f\", 100 * d[(1 \u003c\u003c n) - 1]); } ","date":"2020-04-18","objectID":"/2020-04-18-3056/:0:0","tags":["algorithm","C++","DP","비트마스크","MCMF"],"title":"[백준]3056 007","uri":"/2020-04-18-3056/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-17","objectID":"/2020-04-17-1102/","tags":["algorithm","C++","DP","비트마스크"],"title":"[백준]1102 발전소","uri":"/2020-04-17-1102/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1102 풀이: 발전소의 현재 상태를 2진수로 표현한다. ex) YNN -\u003e 100 l : 발전소의 현재 상태를 2진수로 표현한 값 z : 발전소가 현재 켜져있는 갯수 z가 p보다 크거나 같아진다면 반복을 종료한다. d[x] : x상태인 발전소를 만드는데 필요한 비용 d[x] = min(d[x], B(x | (1«y), z + 1) + a[u][y]) 현재 발전소의 상태에서 안켜진 부분을 키되, 가장 적은 비용으로 킨 후 z를 + 1 한다. p값이 0이라면 발전소를 킬 필요가 없으므로 0을 출력 p값보다 시작 발전소의 켜져있는 갯수가 더 크다면, 0을 출력 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m, l, i, t, s, a[20][20], d[(1 \u003c\u003c 17)]; char c[20]; int B(int x, int z) { if (z \u003e= m || !m || m \u003c= s) return 0; if (d[x] != 987654321) return d[x]; for (int y = 0; y \u003c n; y++) if (!(x \u0026 (1 \u003c\u003c y))) for (int u = 0; u \u003c n; u++) if (x \u0026 (1 \u003c\u003c u))d[x] = min(d[x], B(x|(1 \u003c\u003c y), z + 1) + a[u][y]); return d[x]; } int main() { cin \u003e\u003e n; fill(d, d + (1 \u003c\u003c n), 987654321); for (; i \u003c n; i++)for (t = 0; t \u003c n; t++)cin \u003e\u003e a[i][t]; for (i = 0; i \u003c n; l |= c[i] == 'Y' ? 1 \u003c\u003c i : 0, s += c[i++] == 'Y' ? 1 : 0) cin \u003e\u003e c[i]; cin \u003e\u003e m; i = B(l, s); printf(\"%d\", i == 987654321 ? -1 : i); } ","date":"2020-04-17","objectID":"/2020-04-17-1102/:0:0","tags":["algorithm","C++","DP","비트마스크"],"title":"[백준]1102 발전소","uri":"/2020-04-17-1102/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-16","objectID":"/2020-04-16-1194/","tags":["algorithm","C++","BFS"],"title":"[백준]1194 달이 차오른다, 가자","uri":"/2020-04-16-1194/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1194 풀이: b[x][y][key] : key를 들고, (x, y) 방문했다면, 1, 방문하지 않았다면 0 0부터 BFS를 시작한다. 오른쪽, 왼쪽, 위, 아래를 갈 수 있는데, 만약 갈 수 있는곳이 빈 곳(' . ‘) 이고, 방문하지 않았다면, 방문하고, 방문표시를 한다. 만약 갈 수 있는 곳이 문(대문자) 이고, 방문하지 않았다면, 현재 key가 있는지 확인하고, key가 있다면 방문하고, 방문표시를 한다. 만약 갈 수 있는 곳이 열쇠(소문자) 라면, 얻은 열쇠를 key값에 적용시켜준다. 출구(‘1’) 를 만난다면 반복을 중단한다. 미로를 탈출했다면, 이동 횟수의 최솟값을, 탈출하지 못했다면 -1을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int n, m, i, t, w, e, r, f, b[55][55][35], x[4] = { 1,0,0,-1 }, y[4] = { 0,1,-1,0 }; char c[55][55]; int main() { cin \u003e\u003e n \u003e\u003e m; queue\u003cpair\u003cpair\u003cint, int\u003e, int\u003e\u003e q; for (; i \u003c n; i++) for (t = 0; t \u003c m; t++) { cin \u003e\u003e c[i][t]; if (c[i][t] == '0') q.push({ { i,t },0 }), b[i][t][0] = 1; } for (i = 0; !f \u0026\u0026 !q.empty(); i++) { queue\u003cpair\u003cpair\u003cint, int\u003e,int\u003e\u003e p; while (!q.empty()) { w = q.front().first.first, e = q.front().first.second, r = q.front().second, q.pop(); if (c[w][e] == '1') { f = 1; break; } for (t = 0; t \u003c 4; w -= x[t], e -= y[t], t++) { w += x[t], e += y[t]; if (w \u003c 0 || w \u003e= n || e \u003c 0 || e \u003e= m) continue; if ((!isalpha(c[w][e]) \u0026\u0026 c[w][e] != '#' \u0026\u0026 !b[w][e][r]) || (isupper(c[w][e]) \u0026\u0026 !b[w][e][r] \u0026\u0026 (r \u0026 (1 \u003c\u003c (c[w][e] - 65))))) b[w][e][r] = 1, p.push({ {w,e},r }); if (islower(c[w][e]) \u0026\u0026 !b[w][e][r | (1 \u003c\u003c (c[w][e] - 97))]) b[w][e][r | (1 \u003c\u003c (c[w][e] - 97))] = 1, p.push({ {w,e}, r | (1 \u003c\u003c (c[w][e] - 97)) }); } } q = p; } printf(\"%d\", f ? i - 1 : -1); } ","date":"2020-04-16","objectID":"/2020-04-16-1194/:0:0","tags":["algorithm","C++","BFS"],"title":"[백준]1194 달이 차오른다, 가자","uri":"/2020-04-16-1194/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-15","objectID":"/2020-04-15-1525/","tags":["algorithm","C++","BFS"],"title":"[백준]1525 퍼즐","uri":"/2020-04-15-1525/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1525 풀이: 0 1 2 3 4 5 6 7 8 이렇게 퍼즐이 배열되어 있다고 가정하자. 우리는 이것을 012345678 -\u003e int형으로 바꿔 생각하도록 하자. 이 때, 0이 맨 앞에 나올 경우 무시되므로 0 -\u003e 9 로 바꿔서 912345678 로 나타내도록 하자. 우리가 찾아야 하는 퍼즐의 상태는 123456789 이다. 주어진 퍼즐에서 9를 오른쪽, 왼쪽, 위, 아래 로 옮기면서, 123456789가 되는 지점 까지 BFS를 돌린다. 만약 모든 종류의 퍼즐을 돌았음에도 123456789를 못찾았다면, -1을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003cmap\u003eusing namespace std; int i, t, a, w, f; int main() { map\u003cint, int\u003e m; for (; i \u003c 9; w = w ? w : 9, a = a * 10 + w, i++) cin \u003e\u003e w; queue\u003cint\u003e q; q.push(a), m[a] = 1; for (i = 0;!q.empty(); i++) { queue\u003cint\u003e p; while (!q.empty()) { string s = to_string(q.front()); if (q.front() == 123456789) { f = 1; break; } w = s.find('9'); if (w \u003c 6) { swap(s[w], s[w + 3]); if (!m.count(stoi(s))) p.push(stoi(s)), m[stoi(s)] = 1; swap(s[w], s[w + 3]); } if (w \u003e 2) { swap(s[w], s[w - 3]); if (!m.count(stoi(s))) p.push(stoi(s)), m[stoi(s)] = 1; swap(s[w], s[w - 3]); } if (w % 3 \u003c 2) { swap(s[w], s[w + 1]); if (!m.count(stoi(s))) p.push(stoi(s)), m[stoi(s)] = 1; swap(s[w], s[w + 1]); } if (w % 3 \u003e 0) { swap(s[w], s[w - 1]); if (!m.count(stoi(s))) p.push(stoi(s)), m[stoi(s)] = 1; swap(s[w], s[w - 1]); } q.pop(); } q = p; if (f) break; } printf(\"%d\", f ? i : -1); } ","date":"2020-04-15","objectID":"/2020-04-15-1525/:0:0","tags":["algorithm","C++","BFS"],"title":"[백준]1525 퍼즐","uri":"/2020-04-15-1525/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-14","objectID":"/2020-04-14-1254/","tags":["algorithm","C++","DP"],"title":"[백준]1254 팰린드롬 만들기","uri":"/2020-04-14-1254/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1254 풀이: 기준점 i를 잡는다. (초기 i값은 문자열 S의 중간 지점) 기준점 i와 i - 1을 기준으로 짝수 팰린드롬을 만들 수 있는지 확인한다. 만들 수 없다면, 기준점 i를 기준으로 홀수 팰린드롬을 만들 수 있는지 확인한다. 만들 수 없다면, 기준점 i를 +1 해준다. 짝수 팰린드롬을 만들 수 있다면, 2 * ( i - 1 ) 을 출력한다. 홀수 팰린드롬을 만들 수 있다면, 2 * i - 1 을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int i, c, f, k, t; string s; int main() { cin \u003e\u003e s; c = s.size(); for (i = c / 2; !f \u0026\u0026 i \u003c c; i++) { for (t = 1; t + i - 1 \u003c c \u0026\u0026 i \u003e (c - 1) / 2; t++) { f = 1, k = 1; if (s[i + t - 1] != s[i - t]) { f = 0, k = 0; break; } } for (t = 1; !k \u0026\u0026 t + i \u003c c; t++) { f = 1; if (s[i + t] != s[i - t]) { f = 0; break; } } } printf(\"%d\", k ? 2 * (i - 1) : 2 * i - 1); } ","date":"2020-04-14","objectID":"/2020-04-14-1254/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1254 팰린드롬 만들기","uri":"/2020-04-14-1254/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-13","objectID":"/2020-04-13-1213/","tags":["algorithm","C++","브루트 포스","정렬"],"title":"[백준]1213 팰린드롬 만들기","uri":"/2020-04-13-1213/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1213 풀이: 주어진 문자열에서 알파벳이 각각 몇개 들어있는지 저장한다. A~Z 까지 갯수를 확인한 후 앞뒤로 하나씩 넣는다. 홀수개인 알파벳이 2개 이상 이라면, 문자열을 만들 수 없으므로 “I’m Sorry Hansoo\"를 출력한다. 문자열의 길이가 홀수라면, 가운데에 1개남은 글자를 넣어준다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int i, c = -1, f, t, b[26]; string s; int main() { cin \u003e\u003e s; for (; i \u003c s.size(); i++) b[s[i] - 65]++; for (i = 0; !f \u0026\u0026 i \u003c 26; i++) if (b[i]) { while (b[i] \u003e 1) s[t] = i + 65, s[s.size() - t - 1] = i + 65, t++, b[i] -= 2; if (b[i] % 2) f = c != -1, c = i; } if (s.size() % 2) s[s.size() / 2] = c + 65; if (f) cout \u003c\u003c \"I'm Sorry Hansoo\" \u003c\u003c endl; else cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-04-13","objectID":"/2020-04-13-1213/:0:0","tags":["algorithm","C++","브루트 포스","정렬"],"title":"[백준]1213 팰린드롬 만들기","uri":"/2020-04-13-1213/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-12","objectID":"/2020-04-12-1334/","tags":["algorithm","C++","수학","문자열"],"title":"[백준]1334 다음 팰린드롬 수","uri":"/2020-04-12-1334/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1334 풀이: 문자열 S를 받아온다. S의 길이를 N이라고 하자. S의 오른쪽 절반의 값을 왼쪽 절반의 값으로 덮어쓰자. 그렇게 만들어진 문자열을 A라고 하자. A는 이미 펠린드롬 수 인데, 이 수가 S보다 크다면 A를 그대로 출력한다. 만약 S보다 작다면, 가운데 수를 1씩 증가시킨다. 가운데 수가 9가 됐다면, 0으로 바꾸고 오른쪽, 왼쪽 수를 1씩 증가시킨다. 더 커질 때까지 반복한 후 A를 출력한다. 만약 S가 9로만 이루어진 수라면, 맨 앞수를 1로 바꾸고 그 것을 제외한 모든수를 0으로 바꾼 후 1을 추가한 후 출력한다. EX) 999 -\u003e 1001 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i, f; string s, a; int main() { cin \u003e\u003e s; a = s; n = a.size(); string p(n, '9'); if (a == p) { for (i = 0; i \u003c n; i++) a[i] = '0'; a[0] = '1', a += '0', n++; s.insert(s.begin(), '0'); } for (i = n - 1; i \u003e= n / 2; i--) a[i] = a[n - i - 1]; for (i = 0; i \u003c n; i++) if (a[i]!=s[i]) { f = a[i] \u003e s[i]; break; } for (i = n / 2; !f \u0026\u0026 i \u003c n; i++) { if (a[i] \u003e s[i] || a[n - i - 1] \u003e s[n - i - 1]) break; if (a[i] == '9') { if (!(n % 2) || i != n / 2) a[n - i - 1] = '0'; a[i] = '0'; continue; } if (a[i] \u003c= s[i]) { if (i != n - i - 1) a[n - i - 1]++; a[i]++, i--; } } cout \u003c\u003c a \u003c\u003c endl; } ","date":"2020-04-12","objectID":"/2020-04-12-1334/:0:0","tags":["algorithm","C++","수학","문자열"],"title":"[백준]1334 다음 팰린드롬 수","uri":"/2020-04-12-1334/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-11","objectID":"/2020-04-11-5214/","tags":["algorithm","C++","BFS","그래프"],"title":"[백준]5214 환승","uri":"/2020-04-11-5214/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5214 풀이: s[i] : i 번째 하이퍼 튜브에 연결 되어 있는 모든 역 v[i] : i 번 역이 들어있는 하이퍼 튜브 1부터 bfs를 돌아 N번째 역에 도착할 때 지나온 역의 갯수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int n, m, k, i, t, w, d, c[1005], b[100005] = { 1,1 }; int main() { cin \u003e\u003e n \u003e\u003e k \u003e\u003e m; vector\u003cvector\u003cint\u003e\u003e s(m + 1), v(n + 1); queue\u003cint\u003e q; for (q.push(1); i \u003c m; i++) for (t = 0; t \u003c k; t++) { cin \u003e\u003e w; s[i].push_back(w); v[w].push_back(i); } for (i = 0;!q.empty() \u0026\u0026 !d; i++) { queue\u003cint\u003e p; while (!q.empty()) { w = q.front(), q.pop(), d += w == n; for (int a : v[w]) if (!c[a]) { c[a]++; for (int e : s[a]) if (!b[e]) b[e]++, p.push(e); } } q = p; } printf(\"%d\", d ? i : -1); } ","date":"2020-04-11","objectID":"/2020-04-11-5214/:0:0","tags":["algorithm","C++","BFS","그래프"],"title":"[백준]5214 환승","uri":"/2020-04-11-5214/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-10","objectID":"/2020-04-10-2589/","tags":["algorithm","C++","BFS"],"title":"[백준]2589 보물섬","uri":"/2020-04-10-2589/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2589 풀이: 모든 L을 전부 찾는다. 현재 L에서 최단 거리로 가장 먼 거리가 현재 저장된 거리보다 크다면 현재 저장된 거리를 바꾼다. 최대 거리를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int n, m, i, t, s, y; string c[55]; int main() { cin \u003e\u003e n \u003e\u003e m; for (; i \u003c n; i++) cin \u003e\u003e c[i]; for (i = 0; i \u003c n; i++) for (t = 0; t \u003c m; t++, s = y - 1 \u003e s ? y - 1: s) if (c[i][t] == 'L') { int w, e, b[55][55] = { 0 }; queue\u003cpair\u003cint, int\u003e\u003e q; q.push({ i,t }), b[i][t]++; for (y = 0;!q.empty(); y++) { queue\u003cpair\u003cint, int\u003e\u003e p; while (!q.empty()) { w = q.front().first, e = q.front().second, q.pop(); if (w \u003e 0 \u0026\u0026 !b[w - 1][e] \u0026\u0026 c[w - 1][e] == 'L') b[w - 1][e]++, p.push({ w - 1,e }); if (e \u003e 0 \u0026\u0026 !b[w][e - 1] \u0026\u0026 c[w][e - 1] == 'L') b[w][e - 1]++, p.push({ w,e - 1 }); if (w + 1 \u003c n \u0026\u0026 !b[w + 1][e] \u0026\u0026 c[w + 1][e] == 'L') b[w + 1][e]++, p.push({ w + 1,e }); if (e + 1 \u003c m \u0026\u0026 !b[w][e + 1] \u0026\u0026 c[w][e + 1] == 'L') b[w][e + 1]++, p.push({ w,e + 1 }); } q = p; } } cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-04-10","objectID":"/2020-04-10-2589/:0:0","tags":["algorithm","C++","BFS"],"title":"[백준]2589 보물섬","uri":"/2020-04-10-2589/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-09","objectID":"/2020-04-09-5014/","tags":["algorithm","C++","BFS"],"title":"[백준]5014 스타트링크","uri":"/2020-04-09-5014/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5014 풀이: 현재 층 S부터 +U, -D 를 하며 모든 층을 찾아간다. 만약 찾는 층에 도달했다면 버튼을 몇 번 눌렀는지 출력한다. 만약 1 ~ F 층까지 갈 수 있는 모든 층을 가봤지만 G층에 도달 할 수 없다면, “use the stairs\"를 출력한다. S가 G와 같다면 0을 출력한다. 1층 부터 시작이므로 주의하자. (0층은 없다.) 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int F, S, G, U, D, i, s, a, b[1000005]; int main() { cin \u003e\u003e F \u003e\u003e S \u003e\u003e G \u003e\u003e U \u003e\u003e D; queue\u003cint\u003e q; q.push(S), b[S]++; if (S == G) printf(\"0\"); else { for (i = 1; !q.empty(); i++) { queue\u003cint\u003e p; while (!q.empty()) { a = q.front(), q.pop(); if (a \u003e D \u0026\u0026 !b[a - D]) b[a - D]++, p.push(a - D), s += a - D == G; if (a + U \u003c= F \u0026\u0026 !b[a + U]) b[a + U]++, p.push(a + U), s += a + U == G; } if (s) break; q = p; } if (s) printf(\"%d\", i); else printf(\"use the stairs\"); } } ","date":"2020-04-09","objectID":"/2020-04-09-5014/:0:0","tags":["algorithm","C++","BFS"],"title":"[백준]5014 스타트링크","uri":"/2020-04-09-5014/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-08","objectID":"/2020-04-08-2954/","tags":["algorithm","C++"],"title":"[백준]2954 창영이의 일기장","uri":"/2020-04-08-2954/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2954 풀이: 문자열을 하나씩 읽는 중 모음이 나온다면, 그 다음글자와 다다음 글자를 삭제한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int i, c; string s; int main() { getline(cin, s); for (i = 0; i \u003c s.size(); i++) if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') s.erase(i + 1, 2); cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-04-08","objectID":"/2020-04-08-2954/:0:0","tags":["algorithm","C++"],"title":"[백준]2954 창영이의 일기장","uri":"/2020-04-08-2954/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-07","objectID":"/2020-04-07-2929/","tags":["algorithm","C++"],"title":"[백준]2929 머신 코드","uri":"/2020-04-07-2929/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2929 풀이: 만약 머신 코드의 명령(대문자) 이 들어왔는데, 그 위치가 4의 배수가 아니라면, 4의 배수가 될 때까지 NOP의 갯수를 증가시킨다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int i, c; string s; int main() { cin \u003e\u003e s; for (i = 0; i \u003c s.size(); i++) while (isupper(s[i]) \u0026\u0026 (i + c) % 4 != 0) c++; cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-04-07","objectID":"/2020-04-07-2929/:0:0","tags":["algorithm","C++"],"title":"[백준]2929 머신 코드","uri":"/2020-04-07-2929/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-06","objectID":"/2020-04-06-2083/","tags":["algorithm","C++"],"title":"[백준]2083 럭비 클럽","uri":"/2020-04-06-2083/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2083 풀이: 나이가 17세보다 많거나, 몸무게가 80kg 이상이면, ‘Senior’ 아니라면 ‘Junior’를 출력한다. 코드: 사용언어 : c char c[11]; main(a,b){ for(;scanf(\"%s%d%d\",c,\u0026a,\u0026b)*a;) printf(\"%s %s\\n\",c,a\u003e17||b\u003e=80?\"Senior\":\"Junior\"); } ","date":"2020-04-06","objectID":"/2020-04-06-2083/:0:0","tags":["algorithm","C++"],"title":"[백준]2083 럭비 클럽","uri":"/2020-04-06-2083/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-05","objectID":"/2020-04-05-13909/","tags":["algorithm","C++"],"title":"[백준]13909 창문 닫기","uri":"/2020-04-05-13909/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/13909 풀이: n 까지의 창문들 중 열려있는 창문들은 제곱수 이다. 즉 n까지의 창문들 중 제곱수의 갯수를 찾아 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i; int main() { cin \u003e\u003e n; while (i * i \u003c= n) i++; cout \u003c\u003c i - 1 \u003c\u003c endl; } ","date":"2020-04-05","objectID":"/2020-04-05-13909/:0:0","tags":["algorithm","C++"],"title":"[백준]13909 창문 닫기","uri":"/2020-04-05-13909/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-04","objectID":"/2020-04-04-11586/","tags":["algorithm","C++","문자열"],"title":"[백준]11586 지영 공주님의 마법 거울","uri":"/2020-04-04-11586/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11586 풀이: 문자열을 k가 1일 경우 그대로 k가 2일 경우 좌우 반전 k가 3일 경우 상하 반전 으로 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i, t, k; string s[101]; int main() { cin \u003e\u003e n; for (; i \u003c n; i++) cin \u003e\u003e s[i]; cin \u003e\u003e k; if (k == 1) for (i = 0; i \u003c n; i++) cout \u003c\u003c s[i] \u003c\u003c endl; else if (k == 2) for (i = 0; i \u003c n; i++,printf(\"\\n\")) for (t = n - 1; t \u003e= 0; t--) cout \u003c\u003c s[i][t]; else for (i = n - 1; i \u003e= 0; i--) cout \u003c\u003c s[i] \u003c\u003c endl; } ","date":"2020-04-04","objectID":"/2020-04-04-11586/:0:0","tags":["algorithm","C++","문자열"],"title":"[백준]11586 지영 공주님의 마법 거울","uri":"/2020-04-04-11586/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-03","objectID":"/2020-04-03-11509/","tags":["algorithm","C++"],"title":"[백준]11509 풍선 맞추기","uri":"/2020-04-03-11509/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11509 풀이: 풍선의 높이를 확인한다. 현재 풍선의 높이가 H(i) 라고 하자. H(i) + 1 인 풍선이 현재 풍선 앞에 나타난적이 있다면, H(i) + 1 높이의 풍선을 -1 해준다. 나타난적이 없다면, 화살을 새로 써야 하므로 화살의 갯수를 +1 해준다. 화살의 갯수를 출력한다. 코드: 사용언어 : c #include \u003ciostream\u003eusing namespace std; int n, i, a, b[1000005], c; int main() { cin \u003e\u003e n; for (i = 0; i \u003c n; i++, b[a]++, b[a + 1] ? b[a + 1]-- : c++) cin \u003e\u003e a; cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-04-03","objectID":"/2020-04-03-11509/:0:0","tags":["algorithm","C++"],"title":"[백준]11509 풍선 맞추기","uri":"/2020-04-03-11509/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-02","objectID":"/2020-04-02-10474/","tags":["algorithm","C++"],"title":"[백준]10474 분수좋아해?","uri":"/2020-04-02-10474/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10474 풀이: (a / b) (a %b) / (b) 를 순서대로 출력해준다. 코드: 사용언어 : c main(a,b){ for(;scanf(\"%d%d\",\u0026a,\u0026b)*a*b;) printf(\"%d %d / %d\\n\",a/b,a%b,b); } ","date":"2020-04-02","objectID":"/2020-04-02-10474/:0:0","tags":["algorithm","C++"],"title":"[백준]10474 분수좋아해?","uri":"/2020-04-02-10474/"},{"categories":["백준"],"content":"algorithm","date":"2020-04-01","objectID":"/2020-04-01-14656/","tags":["algorithm","C++"],"title":"[백준]14656 조교는 새디스트야!!","uri":"/2020-04-01-14656/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/14656 풀이: 현재의 줄번호와 학생의 번호가 다르다면 +1 해준다. 코드: 사용언어 : c i,c; main(a){ for(gets(\u0026a);~scanf(\"%d\",\u0026a);) c+=a!=++i; printf(\"%d\",c); } ","date":"2020-04-01","objectID":"/2020-04-01-14656/:0:0","tags":["algorithm","C++"],"title":"[백준]14656 조교는 새디스트야!!","uri":"/2020-04-01-14656/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-31","objectID":"/2020-03-31-13304/","tags":["algorithm","C++"],"title":"[백준]13304 방 배정","uri":"/2020-03-31-13304/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/13304 풀이: 1, 2학년인 학생들 3,4 학년이면서 남학생 3,4 학년이면서 여학생 5,6 학년이면서 남학생 5,6 학년이면서 여학생 으로 나누어 방을 배정한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, k, q, w, a[5]; int main() { cin \u003e\u003e n \u003e\u003e k; while (n--) { cin \u003e\u003e q \u003e\u003e w; if (w \u003c 3) a[0]++; else if (w \u003c 5) if (q) a[1]++; else a[2]++; else if (q) a[3]++; else a[4]++; } for (q = 0, w = 0; q \u003c 5; q++) w += a[q] / k + (a[q] % k ? 1 : 0); cout \u003c\u003c w \u003c\u003c endl; } ","date":"2020-03-31","objectID":"/2020-03-31-13304/:0:0","tags":["algorithm","C++"],"title":"[백준]13304 방 배정","uri":"/2020-03-31-13304/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-31","objectID":"/2020-03-31-2548/","tags":["algorithm","C++"],"title":"[백준]2548 대표 자연수","uri":"/2020-03-31-2548/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2548 풀이: 정렬한 뒤 가운데에 있는 값을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, i, a[20005]; int main() { cin \u003e\u003e n; for (i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; sort(a, a + n); cout \u003c\u003c a[(n - 1) / 2] \u003c\u003c endl; } ","date":"2020-03-31","objectID":"/2020-03-31-2548/:0:0","tags":["algorithm","C++"],"title":"[백준]2548 대표 자연수","uri":"/2020-03-31-2548/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-31","objectID":"/2020-03-31-2684/","tags":["algorithm","C++"],"title":"[백준]2684 동전 게임","uri":"/2020-03-31-2684/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2684 풀이: 뒤뒤뒤, 뒤뒤앞, 뒤앞뒤, 뒤앞앞, 앞뒤뒤, 앞뒤앞, 앞앞뒤, 앞앞앞 순서대로 공백으로 구분해서 출력한다 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int T, i, a[8]; char c[41]; int main() { cin \u003e\u003e T; while (T--) { fill(a, a + 8, 0); for (i = 0; i \u003c 40 ; i++) { cin \u003e\u003e c[i]; if (i \u003e 1) { if (c[i - 2] == 84) if (c[i - 1] == 84) if (c[i] == 84) a[0]++; else a[1]++; else if (c[i] == 84) a[2]++; else a[3]++; else if (c[i - 1] == 84) if (c[i] == 84) a[4]++; else a[5]++; else if (c[i] == 84) a[6]++; else a[7]++; } } for (i = 0; i \u003c 8; i++) printf(\"%d \", a[i]); printf(\"\\n\"); } } ","date":"2020-03-31","objectID":"/2020-03-31-2684/:0:0","tags":["algorithm","C++"],"title":"[백준]2684 동전 게임","uri":"/2020-03-31-2684/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-30","objectID":"/2020-03-30-1484/","tags":["algorithm","C++"],"title":"[백준]1484 다이어트","uri":"/2020-03-30-1484/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1484 풀이: a를 1로 b를 ( n + 1)^1/2 로 초기화 시킨다. b^2 - a^2 이 n 과 같다면, b 를 출력한다. b^2 - a^2 이 n 보다 작다면 b 를 +1 해준다. b^2 - a^2 이 n 이상이라면, a 를 +1 해준다. b와 a가 같아질떄까지 반복한다. 만약 출력을 한번도 안했다면 “-1\"을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cmath.h\u003eusing namespace std; int n,a=1,b,c; int main(){ cin\u003e\u003en; for(b=sqrt(n+a);a!=b;){ if(b*b-a*a==n)c=1,printf(\"%d\\n\",b); if(b*b-a*a\u003cn)b++; else a++; } if(!c)puts(\"-1\"); } ","date":"2020-03-30","objectID":"/2020-03-30-1484/:0:0","tags":["algorithm","C++"],"title":"[백준]1484 다이어트","uri":"/2020-03-30-1484/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-30","objectID":"/2020-03-30-1806/","tags":["algorithm","C++","투 포인터"],"title":"[백준]1806 부분합","uri":"/2020-03-30-1806/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1806 풀이: a[i] : 0 ~ i 번째 수 까지의 합 a[i] 와 a[t] 로 시작한다. a[t] - a[i] 가 S 보다 크거나 같다면, t - i 길이의 부분합이 S 이상이 됨을 알 수 있다. t를 1 줄이고 한번 더 반복한다. 만약, a[t] - a[i] 가 S 보다 작다면, i++, t++ 해준다. t값이 N보다 커질때까지 반복한다. 구한 길이를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int N, S, i, t, s = 0, a[100005]; int main() { cin \u003e\u003e N \u003e\u003e S; for (i = 1; i \u003c= N; i++) { cin \u003e\u003e t; a[i] = a[i - 1] + t; } for (i = 0, t = N; t \u003c= N;) if (a[t] - a[i] \u003e= S) s = t - i, t--; else i++,t++; cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-03-30","objectID":"/2020-03-30-1806/:0:0","tags":["algorithm","C++","투 포인터"],"title":"[백준]1806 부분합","uri":"/2020-03-30-1806/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-30","objectID":"/2020-03-30-9576/","tags":["algorithm","C++","greedy"],"title":"[백준]9576 책 나눠주기","uri":"/2020-03-30-9576/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9576 풀이: 학생들을 b 를 기준으로 정렬한다. a[i] ~ b[i] 까지의 책들 중 현재 도서관에 있는 책이라면 빌려주고, 빌려준 학생수를 +1 해준다. 빌려준 학생수를 출력한다. 코드: 사용언어 : c++ #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003calgorithm\u003eusing namespace std; int T,N,M,q,w,s,a[1005]; int main() { cin\u003e\u003eT; while (T--){ cin\u003e\u003eN\u003e\u003eM; fill(a,a+1001,0); vector\u003cpair\u003cint, int\u003e\u003ev; for(s=0;M--;v.push_back({w,q})) cin\u003e\u003eq\u003e\u003ew; sort(v.begin(),v.end()); for (auto i:v) for (q=i.second;q\u003c=i.first;q++) if(!a[q]){ a[q]=1,s++; break; } cout\u003c\u003cs\u003c\u003cendl; } } ","date":"2020-03-30","objectID":"/2020-03-30-9576/:0:0","tags":["algorithm","C++","greedy"],"title":"[백준]9576 책 나눠주기","uri":"/2020-03-30-9576/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-29","objectID":"/2020-03-29-10708/","tags":["algorithm","C++","구현"],"title":"[백준]10708 크리스마스 파티","uri":"/2020-03-29-10708/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10708 풀이: 게임을 진행한다. 적은 대상이 타겟이라면 적은 사람을 +1 타겟이 아니라면 타겟인 사람을 +1 해준다. 게임 이 끝난 후 각각의 친구들이 얻은 합계 점수를 각각 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, t, c, a[102], b[102]; int main() { cin \u003e\u003e n \u003e\u003e m; for (; i \u003c m; i++) cin \u003e\u003e a[i]; for (i = 0; i \u003c m; i++) for (t = 0; t \u003c n; b[c==a[i]?t:a[i]-1]++,t++) cin \u003e\u003e c; for (i = 0; i \u003c n; i++) cout \u003c\u003c b[i] \u003c\u003c endl; } ","date":"2020-03-29","objectID":"/2020-03-29-10708/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]10708 크리스마스 파티","uri":"/2020-03-29-10708/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-28","objectID":"/2020-03-28-16483/","tags":["algorithm","C++"],"title":"[백준]16483 접시 안의 원","uri":"/2020-03-28-16483/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/16483 풀이: a^2 = (T/2)^2 + b^2 a^2 - b^2 = (T/2)^2 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int T; int main() { cin \u003e\u003e T; printf(\"%d\", T*T/4); } ","date":"2020-03-28","objectID":"/2020-03-28-16483/:0:0","tags":["algorithm","C++"],"title":"[백준]16483 접시 안의 원","uri":"/2020-03-28-16483/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-28","objectID":"/2020-03-28-17945/","tags":["algorithm","C++"],"title":"[백준]17945 통학의 신","uri":"/2020-03-28-17945/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17945 풀이: x2 + 2Ax + B = 0 의 두 계수 A, B가 주어진다 두 근을 구해 출력하는 문제. 근의 공식을 이용하자! 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cmath.h\u003eusing namespace std; int a, b, c, d;; int main() { cin \u003e\u003e a \u003e\u003e b; c = -a - sqrt(a * a - b); d = -a + sqrt(a * a - b); printf(c == d ? \"%d\" : \"%d %d\",c, d); } ","date":"2020-03-28","objectID":"/2020-03-28-17945/:0:0","tags":["algorithm","C++"],"title":"[백준]17945 통학의 신","uri":"/2020-03-28-17945/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-28","objectID":"/2020-03-28-2503/","tags":["algorithm","C++","브루트 포스"],"title":"[백준]2503 숫자 야구","uri":"/2020-03-28-2503/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2503 풀이: 123 ~ 987 까지의 중복이 없는 숫자를 모두 탐색한다. 각 숫자를 n개의 질문과 대조하여 틀린점이 없다면 답을 +1 해준다. 모든 숫자를 탐색했다면 답을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i, a, s[100], b[100]; string c[100], m; void B(int x) { if (x == 3) { int r = 1; for (int t = 0; t \u003c n; t++) { int q = 0, w = 0; for (int y = 0; y \u003c 3; y++) for (int u = 0; u \u003c 3; u++) if (c[t][y] == m[u]) if (y == u) q++; else w++; if (s[t] != q || b[t] != w) r = 0; } if (r) a++; } for (int t = 1; t \u003c 10; t++) { if (!x || (x == 1 \u0026\u0026 m[0] - '0' != t) || (x == 2 \u0026\u0026 m[0] - '0' != t \u0026\u0026 m[1] - '0' != t)) m[x] = '0' + t, B(x + 1); } } int main() { cin \u003e\u003e n; for (i = 0; i \u003c n; i++) cin \u003e\u003e c[i] \u003e\u003e s[i] \u003e\u003e b[i]; m.resize(4); B(0); cout \u003c\u003c a \u003c\u003c endl; } ","date":"2020-03-28","objectID":"/2020-03-28-2503/:0:0","tags":["algorithm","C++","브루트 포스"],"title":"[백준]2503 숫자 야구","uri":"/2020-03-28-2503/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-28","objectID":"/2020-03-28-3449/","tags":["algorithm","C++"],"title":"[백준]3449 해밍 거리","uri":"/2020-03-28-3449/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/3449 풀이: 각 테스트 케이스에 대해서, 해밍 거리를 계산한 뒤, “Hamming distance is X.“라고 출력한다. 해밍 거리란? 각 문자열의 문자들 중 서로 다른 문자열의 갯수! 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int T, i, s; string a, b; int main() { cin \u003e\u003e T; while (T--) { cin \u003e\u003e a \u003e\u003e b; for (s = 0,i = 0; i \u003c a.size(); i++) s += a[i] != b[i] ? 1 : 0; printf(\"Hamming distance is %d.\\n\", s); } } ","date":"2020-03-28","objectID":"/2020-03-28-3449/:0:0","tags":["algorithm","C++"],"title":"[백준]3449 해밍 거리","uri":"/2020-03-28-3449/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-27","objectID":"/2020-03-27-11109/","tags":["algorithm","C++"],"title":"[백준]11109 괴짜 교수","uri":"/2020-03-27-11109/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11109 풀이: 병렬화를 하는게 좋으면 “parallelize” 를 출력하고, 병렬화를 하는게 좋지 않으면 “do not parallelize” 를 출력한다. 만약 직렬화와 병렬화를 통한 시간이 같으면 “does not matter” 를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int T, d, n, s, p; int main() { cin \u003e\u003e T; while (T--) { cin \u003e\u003e d \u003e\u003e n \u003e\u003e s \u003e\u003e p; printf(\"%s\\n\",d + n * p \u003e n* s ? \"do not parallelize\" : d + n * p \u003c n * s ? \"parallelize\" : \"does not matter\"); } } ","date":"2020-03-27","objectID":"/2020-03-27-11109/:0:0","tags":["algorithm","C++"],"title":"[백준]11109 괴짜 교수","uri":"/2020-03-27-11109/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-27","objectID":"/2020-03-27-2738/","tags":["algorithm","C++"],"title":"[백준]2738 행렬 덧셈","uri":"/2020-03-27-2738/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2738 풀이: 행렬 A와 행렬 B를 더한 행렬을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, b, a[10005]; int main() { for (cin \u003e\u003e n \u003e\u003e m; i \u003c n * m; i++) cin \u003e\u003e a[i]; for (i = 0; i \u003c n * m; printf(\"%d%s\", a[i++] + b, i % m ? \" \" : \"\\n\")) cin \u003e\u003e b; } ","date":"2020-03-27","objectID":"/2020-03-27-2738/:0:0","tags":["algorithm","C++"],"title":"[백준]2738 행렬 덧셈","uri":"/2020-03-27-2738/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-26","objectID":"/2020-03-26-1748/","tags":["algorithm","C++"],"title":"[백준]1748 수 이어 쓰기 1","uri":"/2020-03-26-1748/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1748 풀이: 1 ~ N 까지의 1의 자릿수의 갯수 + 1 ~ N 까지의 10의 자릿수의 갯수 . . . + 1 ~ N 까지의 N의 최대 자릿수의 갯수 = 1 ~ N 까지의 수를 이어서 썻을 때의 자릿수 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, a, b = 1; int main() { for (cin \u003e\u003e n; n \u003e b; b *= 10) a += n - b + 1; cout \u003c\u003c a \u003c\u003c endl; } ","date":"2020-03-26","objectID":"/2020-03-26-1748/:0:0","tags":["algorithm","C++"],"title":"[백준]1748 수 이어 쓰기 1","uri":"/2020-03-26-1748/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-26","objectID":"/2020-03-26-5533/","tags":["algorithm","C++","구현"],"title":"[백준]5533 유니크","uri":"/2020-03-26-5533/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5533 풀이: 각 플레이어가 3번의 게임에서 얻은 총 점수를 입력으로 주어진 순서대로 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, a[201][3], i, t, b[3][101], s; int main() { cin \u003e\u003e n; for (i = 0; i \u003c n; i++) for (t = 0; t \u003c 3; b[t][a[i][t++]]++) cin \u003e\u003e a[i][t]; for (i = 0; i \u003c n; i++, s = 0) { for (t = 0; t \u003c 3; t++) s += b[t][a[i][t]] \u003e 1 ? 0 : a[i][t]; cout \u003c\u003c s \u003c\u003c endl; } } ","date":"2020-03-26","objectID":"/2020-03-26-5533/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]5533 유니크","uri":"/2020-03-26-5533/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-26","objectID":"/2020-03-26-5586/","tags":["algorithm","C++"],"title":"[백준]5586 JOI와 IOI","uri":"/2020-03-26-5586/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5586 풀이: 문자열에 포함되어 있는 JOI의 개수, 둘째 줄에 IOI의 개수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int a, b, i; string s; int main() { cin \u003e\u003e s; for (i = 0; i \u003c s.size() - 2; i++) if (s.substr(i, 3) == \"JOI\") a++; else if (s.substr(i, 3) == \"IOI\") b++; printf(\"%d\\n%d\", a, b); } ","date":"2020-03-26","objectID":"/2020-03-26-5586/:0:0","tags":["algorithm","C++"],"title":"[백준]5586 JOI와 IOI","uri":"/2020-03-26-5586/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-25","objectID":"/2020-03-25-10995/","tags":["algorithm","C++"],"title":"[백준]10995 별 찍기 - 20","uri":"/2020-03-25-10995/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10995 풀이: 주어진 규칙대로 별을 찍는다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i, t; int main() { cin \u003e\u003e n; for (i = 0; i \u003c n; i++) { for (t = 0; t \u003c n; t++) printf(\"%s\", i % 2 ? \" *\" : \"* \"); printf(\"\\n\"); } } ","date":"2020-03-25","objectID":"/2020-03-25-10995/:0:0","tags":["algorithm","C++"],"title":"[백준]10995 별 찍기 - 20","uri":"/2020-03-25-10995/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-25","objectID":"/2020-03-25-1259/","tags":["algorithm","C++"],"title":"[백준]1259 팰린드롬수","uri":"/2020-03-25-1259/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1259 풀이: 팰린드롬 이라면 yes 를 아니라면 no를 출력한다. 맨 첫 글자와 맨 마지막글자 가 같은지 i번째 글자와 size() - i - 1 번째 글자가 같은지 를 판단하여, 만약 하나라도 다르다면 no를 전부 같다면 yes를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { while (1) { string s; int i, t = 0; cin \u003e\u003e s; if (s == \"0\") break; for (i = 0; i \u003c s.size() / 2; i++) if (s[i] != s[s.size() - i - 1]) t = 1; printf(\"%s\\n\", t ? \"no\" : \"yes\"); } } ","date":"2020-03-25","objectID":"/2020-03-25-1259/:0:0","tags":["algorithm","C++"],"title":"[백준]1259 팰린드롬수","uri":"/2020-03-25-1259/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-25","objectID":"/2020-03-25-14920/","tags":["algorithm","C++"],"title":"[백준]14920 3n+1 수열","uri":"/2020-03-25-14920/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/14920 풀이: C(n+1) = C(n)/2 (C(n)이 짝수일 때) = 3*C(n)+1 (C(n)이 홀수일 때) 주어진 점화식대로 진행하다가 C(n)이 1이되었을 때, n을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int a, i = 1; int main() { for (cin \u003e\u003e a;a!=1; i++) a = a % 2 ? 3 * a + 1 : a / 2; cout \u003c\u003c i \u003c\u003c endl; } ","date":"2020-03-25","objectID":"/2020-03-25-14920/:0:0","tags":["algorithm","C++"],"title":"[백준]14920 3n+1 수열","uri":"/2020-03-25-14920/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-25","objectID":"/2020-03-25-17173/","tags":["algorithm","C++"],"title":"[백준]17173 배수들의 합","uri":"/2020-03-25-17173/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17173 풀이: 2 ~ n 까지 수들 중 ki 중 하나의 배수인 수를 모두 찾아 더한 후 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, t, s = 0, a[1001]; int main() { cin \u003e\u003e n \u003e\u003e m; for (i = 0; i \u003c m; i++) cin \u003e\u003e a[i]; for (i = 2; i \u003c= n; i++) for (t = 0; t \u003c m; t++) if (!(i % a[t])) { s += i; break; } cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-03-25","objectID":"/2020-03-25-17173/:0:0","tags":["algorithm","C++"],"title":"[백준]17173 배수들의 합","uri":"/2020-03-25-17173/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-25","objectID":"/2020-03-25-2460/","tags":["algorithm","C++"],"title":"[백준]2460 지능형 기차 2","uri":"/2020-03-25-2460/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2460 풀이: 기차에 사람이 가장 많을 때의 사람 수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int a, b, i, s = 0, t = 0; int main() { for (i = 0; i \u003c 10; i++) { cin \u003e\u003e a \u003e\u003e b; s += b - a, t = t \u003c s ? s : t; } cout \u003c\u003c t \u003c\u003c endl; } ","date":"2020-03-25","objectID":"/2020-03-25-2460/:0:0","tags":["algorithm","C++"],"title":"[백준]2460 지능형 기차 2","uri":"/2020-03-25-2460/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-25","objectID":"/2020-03-25-5532/","tags":["algorithm","C++"],"title":"[백준]5532 방학 숙제","uri":"/2020-03-25-5532/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5532 풀이: 국어를 풀어야 하는 날짜와 수학을 풀어야 하는 날짜를 각각 a, b라고 했을 때, a, b 중 더 높은 값을 방학일에서 뺀다면, 놀 수 있는 날의 최댓값이 된다. 코드: 사용언어 : c main(n,a,b,c,d){ scanf(\"%d%d%d%d%d\",\u0026n,\u0026a,\u0026b,\u0026c,\u0026d); a=a/c+(a%c?1:0),b=b/d+(b%d?1:0); printf(\"%d\",n-(a\u003cb?b:a)); } ","date":"2020-03-25","objectID":"/2020-03-25-5532/:0:0","tags":["algorithm","C++"],"title":"[백준]5532 방학 숙제","uri":"/2020-03-25-5532/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-24","objectID":"/2020-03-24-13699/","tags":["algorithm","C++"],"title":"[백준]13699 점화식","uri":"/2020-03-24-13699/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/13699 풀이: t(0) = 1 t(1) = t(0)*t(0) = 1 t(2) = t(0)*t(1)+t(1)*t(0) = 2 t(3) = t(0)*t(2)+t(1)*t(1)+t(2)*t(0) = 5 주어진 점화식 그대로 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; long long n, t, i = 1, a[36] = { 1 }; int main() { cin \u003e\u003e n; for (; i \u003c= n; i++) for (t = 0; t \u003c i; t++) a[i] += a[i - t - 1] * a[t]; cout \u003c\u003c a[n] \u003c\u003c endl; } ","date":"2020-03-24","objectID":"/2020-03-24-13699/:0:0","tags":["algorithm","C++"],"title":"[백준]13699 점화식","uri":"/2020-03-24-13699/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-24","objectID":"/2020-03-24-15657/","tags":["algorithm","C++"],"title":"[백준]15657 N과 M (8)","uri":"/2020-03-24-15657/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/15657 풀이: 수열을 배열에 저장한다. 비내림차순으로 출력해야 하므로 배열을 정렬한다. 현재 배열에 있는 수를 새로운 배열에 옮겨 담는다. 옮긴 수가 M개가 된다면 출력하고, 다른 수를 담는다. 모든 수를 사전 순으로 출력했다면 종료한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m, a[8], b[8]; void N(int x, int y) { if (!y) { for (int i = 0; i \u003c m; i++) printf(\"%d \", b[i]); printf(\"\\n\"); return; } for (int i = x; i \u003c n; i++) b[m - y] = a[i], N(i, y - 1); } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; sort(a, a + n); N(0, m); } ","date":"2020-03-24","objectID":"/2020-03-24-15657/:0:0","tags":["algorithm","C++"],"title":"[백준]15657 N과 M (8)","uri":"/2020-03-24-15657/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-24","objectID":"/2020-03-24-15989/","tags":["algorithm","C++"],"title":"[백준]15989 1, 2, 3 더하기 4","uri":"/2020-03-24-15989/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/15989 풀이: a[n][0] : 3을 포함하지 않고, 2를 1개 이상 포함한 n 을 만드는 경우의 수 a[n][1] : 3을 1개 이상 포함한 n을 만드는 경우의 수 a[n][0] = a[n - 2][0] + 1 -\u003e 2를 1개 이상 포함하여 n - 2 를 만드는 경우의 수에 2를 하나씩 더 붙힌 것 + 1로만 이루어진 수에 2를 하나 붙힌 것) a[n][1] = a[n - 3][1] + a[n - 3][0] + 1 -\u003e 3을 3개 이상 포함하여 n - 3 을 만드는 경우의 수에 3을 하나씩 붙힌 것 + 2를 1개 이상 포함하여 n - 3 을 만드는 경우의 수에 3를 하나씩 더 붙힌 것 + 1로만 이루어진 수에 2를 하나 붙힌 것) a[n][0] + a[n][1] + 1 (1로만 이루어진 경우의 수를 위해 1을 더해준다.) 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int T, n, i = 3, a[10001][2]; int main() { cin \u003e\u003e T; a[2][0] = 1; while (T--) { cin \u003e\u003e n; for (; i \u003c= n; i++) a[i][0] = a[i - 2][0] + 1, a[i][1] = a[i - 3][1] + a[i - 3][0] + 1; cout \u003c\u003c a[n][0] + a[n][1] + 1 \u003c\u003c endl; } } ","date":"2020-03-24","objectID":"/2020-03-24-15989/:0:0","tags":["algorithm","C++"],"title":"[백준]15989 1, 2, 3 더하기 4","uri":"/2020-03-24-15989/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-24","objectID":"/2020-03-24-16673/","tags":["algorithm","C++"],"title":"[백준]16673 고려대학교에는 공식 와인이 있다","uri":"/2020-03-24-16673/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/16673 풀이: ΣKn + ΣPn^2 (1 ~ C) Kn(n+1)/2 + Pn(n+1)(2n+1)/6 n(n+1)(3K+P(2n+1))/6 코드: 사용언어 : c main(c,k,p){ scanf(\"%d%d%d\",\u0026c,\u0026k,\u0026p); printf(\"%d\",((c*c+c)*(3*k+p*2*c+p))/6); } ","date":"2020-03-24","objectID":"/2020-03-24-16673/:0:0","tags":["algorithm","C++"],"title":"[백준]16673 고려대학교에는 공식 와인이 있다","uri":"/2020-03-24-16673/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-23","objectID":"/2020-03-23-10996/","tags":["algorithm","C++","별 찍기"],"title":"[백준]10996 별 찍기 - 21","uri":"/2020-03-23-10996/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10996 풀이: 지그제그로 n번 별을 찍는다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i, t; int main() { cin \u003e\u003e n; for (i = 0; i \u003c n * 2; i++) { for (t = 0; t \u003c n / 2 + (i % 2 ? 0 : n % 2); t++) printf(\"%s\", i % 2 ? \" *\" : \"* \"); cout \u003c\u003c endl; } } ","date":"2020-03-23","objectID":"/2020-03-23-10996/:0:0","tags":["algorithm","C++","별 찍기"],"title":"[백준]10996 별 찍기 - 21","uri":"/2020-03-23-10996/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-23","objectID":"/2020-03-23-1453/","tags":["algorithm","C++"],"title":"[백준]1453 피시방 알바","uri":"/2020-03-23-1453/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1453 풀이: 거절당하는 사람의 수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, s = 0, a[101]; int main() { cin \u003e\u003e n; while (n--) { cin \u003e\u003e m; a[m]?s++:a[m]++; } cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-03-23","objectID":"/2020-03-23-1453/:0:0","tags":["algorithm","C++"],"title":"[백준]1453 피시방 알바","uri":"/2020-03-23-1453/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-23","objectID":"/2020-03-23-14681/","tags":["algorithm","C++"],"title":"[백준]14681 사분면 고르기","uri":"/2020-03-23-14681/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/14681 풀이: 점 (x, y)의 사분면 번호를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int x, y; int main() { cin \u003e\u003e x \u003e\u003e y; if (x \u003e 0 \u0026\u0026 y \u003e 0) cout \u003c\u003c \"1\" \u003c\u003c endl; if (x \u003c 0 \u0026\u0026 y \u003e 0) cout \u003c\u003c \"2\" \u003c\u003c endl; if (x \u003c 0 \u0026\u0026 y \u003c 0) cout \u003c\u003c \"3\" \u003c\u003c endl; if (x \u003e 0 \u0026\u0026 y \u003c 0) cout \u003c\u003c \"4\" \u003c\u003c endl; } ","date":"2020-03-23","objectID":"/2020-03-23-14681/:0:0","tags":["algorithm","C++"],"title":"[백준]14681 사분면 고르기","uri":"/2020-03-23-14681/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-23","objectID":"/2020-03-23-16486/","tags":["algorithm","C++"],"title":"[백준]16486 운동장 한 바퀴","uri":"/2020-03-23-16486/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/16486 풀이: 원 둘레 + 직사각형 가로길이 * 2 코드: 사용언어 : c main(n,m){ scanf(\"%d%d\",\u0026n,\u0026m); printf(\"%f\",2*(n+m*3.141592)); } ","date":"2020-03-23","objectID":"/2020-03-23-16486/:0:0","tags":["algorithm","C++"],"title":"[백준]16486 운동장 한 바퀴","uri":"/2020-03-23-16486/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-23","objectID":"/2020-03-23-17176/","tags":["algorithm","C++"],"title":"[백준]17176 암호해독기","uri":"/2020-03-23-17176/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/17176 풀이: 암호의 쓰인 알파벳들을 저장한다. 평문을 살펴보며 암호에 쓰였는지 확인한다. 암호의 없는 알파벳이 나온다면, n을 아니라면 y를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, b, i, s, a[53]; int main() { cin \u003e\u003e n; for (i = 0; i \u003c= n; i++) { cin \u003e\u003e m; a[m]++; } for (i = 0; i \u003c n; i++) { s = getchar(); s -= s \u003e 96 ? 70 : s \u003e 64 ? 64 : 32; if (a[s]) a[s]--; else b = 1; } printf(\"%s\", b ? \"n\" : \"y\"); } ","date":"2020-03-23","objectID":"/2020-03-23-17176/:0:0","tags":["algorithm","C++"],"title":"[백준]17176 암호해독기","uri":"/2020-03-23-17176/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-23","objectID":"/2020-03-23-2475/","tags":["algorithm","C++"],"title":"[백준]2475 검증수","uri":"/2020-03-23-2475/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2475 풀이: 고유번호의 각 자릿수를 제곱한 값을 더한 후 10으로 나눈 나머지를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int x, i, s = 0; int main() { for (i = 0; i \u003c 5; i++) { cin \u003e\u003e x; s += x * x; } cout \u003c\u003c s % 10 \u003c\u003c endl; } ","date":"2020-03-23","objectID":"/2020-03-23-2475/:0:0","tags":["algorithm","C++"],"title":"[백준]2475 검증수","uri":"/2020-03-23-2475/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-23","objectID":"/2020-03-23-2523/","tags":["algorithm","C++","별 찍기"],"title":"[백준]2523 별 찍기 - 13","uri":"/2020-03-23-2523/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2523 풀이: 증가하는 순서로 별을찍다가 n+1 번쨰 줄부터 감소하는 순서로 별을 찍는다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i, t; int main() { cin \u003e\u003e n; for (i = 0; i \u003c n; i++) { for (t = 0; t \u003c= i; t++) cout \u003c\u003c \"*\"; cout \u003c\u003c endl; } while (n--) { for (t = 0; t \u003c n; t++) cout \u003c\u003c \"*\"; cout \u003c\u003c endl; } } ","date":"2020-03-23","objectID":"/2020-03-23-2523/:0:0","tags":["algorithm","C++","별 찍기"],"title":"[백준]2523 별 찍기 - 13","uri":"/2020-03-23-2523/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-23","objectID":"/2020-03-23-2959/","tags":["algorithm","C++"],"title":"[백준]2959 거북이","uri":"/2020-03-23-2959/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2959 풀이: 거북이가 만들 수 있는 가장 큰 직사각형의 면적을 출력한다 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[4], i = 4; int main() { while (i--) cin \u003e\u003e a[i]; sort(a, a + 4); cout \u003c\u003c a[0] * a[2] \u003c\u003c endl; } ","date":"2020-03-23","objectID":"/2020-03-23-2959/:0:0","tags":["algorithm","C++"],"title":"[백준]2959 거북이","uri":"/2020-03-23-2959/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-23","objectID":"/2020-03-23-5523/","tags":["algorithm","C++"],"title":"[백준]5523 경기 결과","uri":"/2020-03-23-5523/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5523 풀이: 각 경기마다 a가 이겼다면 a++ 를 b가 이겼다면 b++를 해준다. 모든 경기가 끝난 후 a와 b값을 출력해준다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, a = 0, b = 0, x, y; int main() { cin \u003e\u003e n; while (n--) { cin \u003e\u003e x \u003e\u003e y; if (x \u003e y) a++; if (x \u003c y) b++; } cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c endl; } ","date":"2020-03-23","objectID":"/2020-03-23-5523/:0:0","tags":["algorithm","C++"],"title":"[백준]5523 경기 결과","uri":"/2020-03-23-5523/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-22","objectID":"/2020-03-22-10422/","tags":["algorithm","C++"],"title":"[백준]10422 괄호","uri":"/2020-03-22-10422/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10422 풀이: C1=C0C0 C2=C0C1+C1C0 C3=C0C2+C1C1+C2C0 C4=C0C3+C1C2+C2C1+C3C0 . . . Cn = ΣCiC(n - i - 1) 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; long long T, n, t, i = 2, a[3000] = { 1,1 }; int main() { cin \u003e\u003e T; while (T--) { cin \u003e\u003e n; if (n % 2) cout \u003c\u003c \"0\" \u003c\u003c endl; else { for (; i \u003c= n / 2; i++) for (t = 0; t \u003c i; t++) a[i] = (a[i] + a[i - t - 1] * a[t]) % 1000000007; cout \u003c\u003c a[n / 2] \u003c\u003c endl; } } } ","date":"2020-03-22","objectID":"/2020-03-22-10422/:0:0","tags":["algorithm","C++"],"title":"[백준]10422 괄호","uri":"/2020-03-22-10422/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-22","objectID":"/2020-03-22-11505/","tags":["algorithm","C++","세그먼트 트리"],"title":"[백준]11505 구간 곱 구하기","uri":"/2020-03-22-11505/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11505 풀이: [백준]2042 구간 합 구하기 참고 cin, cout 은 시간초과가 나므로 주의 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; #define ll long long ll n, m, k, a, b, c; vector\u003cll\u003e T; ll update(int node, int idx, ll val, int x, int y) { if (idx \u003c x || idx \u003e y) return T[node]; if (x == y) return T[node] = val; return T[node] = (update(node * 2, idx, val, x, (x + y) / 2) * update(node * 2 + 1, idx, val, (x + y) / 2 + 1, y)) % 1000000007; } ll mul(int node, int x, int y, int s, int e) { if (e \u003c x || s \u003e y) return 1; if (s \u003c= x \u0026\u0026 e \u003e= y) return T[node]; return (mul(node * 2, x, (x + y) / 2, s, e) * mul(node * 2 + 1, (x + y) / 2 + 1, y, s, e)) % 1000000007; } int main() { scanf(\"%d%d%d\",\u0026n,\u0026m,\u0026k); T.resize(1 \u003c\u003c (int)(ceil(log2(n)) + 1)); for (int i = 0; i \u003c n; i++) { scanf(\"%d\",\u0026c); update(1, i, c, 0, n - 1); } for (int i = 0; i \u003c m + k; i++) { scanf(\"%d%d%d\",\u0026a,\u0026b,\u0026c); if (a == 1) update(1, b - 1, c, 0, n - 1); else printf(\"%lld\\n\",mul(1, 0, n - 1, b - 1, c - 1)); } } ","date":"2020-03-22","objectID":"/2020-03-22-11505/:0:0","tags":["algorithm","C++","세그먼트 트리"],"title":"[백준]11505 구간 곱 구하기","uri":"/2020-03-22-11505/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-22","objectID":"/2020-03-22-2042/","tags":["algorithm","C++","세그먼트 트리"],"title":"[백준]2042 구간 합 구하기","uri":"/2020-03-22-2042/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2042 풀이: https://www.acmicpc.net/blog/view/9 참고 크기가 2 ^ (log2(n) + 1) 인 트리를 하나 만든다. N개의 값을 트리에 모두 저장한다. a 가 1 이라면, b번째 값을 c로 수정한다. a 가 2 라면, 2 ~ 5 까지의 모든 수의 합을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; #define ll long long ll n, m, k, a, b, c; vector\u003cll\u003e T; ll update(int node, int idx, ll val, int x, int y) { if (idx \u003c x || idx \u003e y) return T[node]; if (x == y) return T[node] = val; return T[node] = update(node * 2, idx, val, x, (x + y) / 2) + update(node * 2 + 1, idx, val, (x + y) / 2 + 1, y); } ll sum(int node, int x, int y, int s, int e) { if (e \u003c x || s \u003e y) return 0; if (s \u003c= x \u0026\u0026 e \u003e= y) return T[node]; return sum(node * 2, x, (x + y) / 2, s, e) + sum(node * 2 + 1, (x + y) / 2 + 1, y, s, e); } int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; T.resize(1 \u003c\u003c (int)(ceil(log2(n)) + 1)); for (int i = 0; i \u003c n; i++) { cin \u003e\u003e c; update(1, i, c, 0, n - 1); } for (int i = 0; i \u003c m + k; i++) { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; if (a == 1) update(1, b - 1, c, 0, n - 1); else cout \u003c\u003c sum(1, 0, n - 1, b - 1, c - 1) \u003c\u003c endl; } } ","date":"2020-03-22","objectID":"/2020-03-22-2042/:0:0","tags":["algorithm","C++","세그먼트 트리"],"title":"[백준]2042 구간 합 구하기","uri":"/2020-03-22-2042/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-22","objectID":"/2020-03-22-2217/","tags":["algorithm","C++","greedy"],"title":"[백준]2217 로프","uri":"/2020-03-22-2217/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2217 풀이: a[i] : i 무게를 들 수 있는 로프의 갯수 로프의 중량보다 가벼운 물체는 들 수 있으므로 중량보다 낮은 값은 전부 +1 씩 해준다. a[i] * i 의 값이 가장 높은 값을 출력한다. i 무게를 들 수 있는 로프의 갯수가 a[i] 개 일 때, a[i] 개의 로프를 이용하여 중량이 a[i] * i 인 물체를 들 수 있기 때문에) 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, s = 0, a[10002]; int main() { cin \u003e\u003e n; while (n--) { cin \u003e\u003e m; while (m) a[m--]++; } for (i = 1; i \u003c 10001; i++) s = s \u003c i * a[i] ? i * a[i] : s; cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-03-22","objectID":"/2020-03-22-2217/:0:0","tags":["algorithm","C++","greedy"],"title":"[백준]2217 로프","uri":"/2020-03-22-2217/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-22","objectID":"/2020-03-22-2357/","tags":["algorithm","C++","세그먼트 트리"],"title":"[백준]2357 최솟값과 최댓값","uri":"/2020-03-22-2357/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2357 풀이: [백준]2042 구간 합 구하기 참고 cin, cout 은 시간초과가 나므로 주의 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; #define ll long long ll n, m, a, b; vector\u003cll\u003e T, Y; void update(int node, int idx, ll val, int x, int y) { if (idx \u003c x || idx \u003e y) return; T[node] = T[node] \u003e val ? T[node] : val; Y[node] = Y[node] \u003e val ? val : Y[node]; if (x != y) update(node * 2, idx, val, x, (x + y) / 2), update(node * 2 + 1, idx, val, (x + y) / 2 + 1, y); } ll min(int node, int x, int y, int s, int e) { if (e \u003c x || s \u003e y) return 1000000001; if (s \u003c= x \u0026\u0026 e \u003e= y) return Y[node]; int i = min(node * 2, x, (x + y) / 2, s, e), t = min(node * 2 + 1, (x + y) / 2 + 1, y, s, e); return i \u003e t ? t : i; } ll max(int node, int x, int y, int s, int e) { if (e \u003c x || s \u003e y) return 0; if (s \u003c= x \u0026\u0026 e \u003e= y) return T[node]; int i = max(node * 2, x, (x + y) / 2, s, e), t = max(node * 2 + 1, (x + y) / 2 + 1, y, s, e); return i \u003e t ? i : t; } int main() { scanf(\"%d%d\",\u0026n,\u0026m); a = 1 \u003c\u003c (int)(ceil(log2(n)) + 1), T.resize(a), Y.resize(a, 1000000001); for (int i = 0; i \u003c n; i++) { scanf(\"%d\",\u0026a); update(1, i, a, 0, n - 1); } for (int i = 0; i \u003c m; i++) { scanf(\"%d%d\",\u0026a,\u0026b); printf(\"%lld %lld\\n\",min(1, 0, n - 1, a - 1, b - 1), max(1, 0, n - 1, a - 1, b - 1)); } } ","date":"2020-03-22","objectID":"/2020-03-22-2357/:0:0","tags":["algorithm","C++","세그먼트 트리"],"title":"[백준]2357 최솟값과 최댓값","uri":"/2020-03-22-2357/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-21","objectID":"/2020-03-21-10807/","tags":["algorithm","C++"],"title":"[백준]10807 개수 세기","uri":"/2020-03-21-10807/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10807 풀이: 입력으로 주어진 N개의 정수 중에 v가 몇 개인지 출력한다. 코드: 사용언어 : c n,m,a[202]; main(){ scanf(\"%d\",\u0026n); while(n--){ scanf(\"%d\",\u0026m); a[m+100]++; } scanf(\"%d\",\u0026n); printf(\"%d\\n\",a[n+100]); } ","date":"2020-03-21","objectID":"/2020-03-21-10807/:0:0","tags":["algorithm","C++"],"title":"[백준]10807 개수 세기","uri":"/2020-03-21-10807/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-21","objectID":"/2020-03-21-11576/","tags":["algorithm","C++"],"title":"[백준]11576 Base Conversion","uri":"/2020-03-21-11576/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11576 풀이: A진법으로 나타낸 수를 10진법으로 바꾼 후 바꾼 10진법 수를 다시 B진법으로 바꿔 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int a, b, m, n, s; vector\u003cint\u003e v; int main() { cin \u003e\u003e a \u003e\u003e b \u003e\u003e m; while (m--) { cin \u003e\u003e n; s = s * a + n; } while (s) v.push_back(s % b), s /= b; for (m = v.size() - 1; m \u003e= 0; m--) cout \u003c\u003c v[m] \u003c\u003c \" \"; cout \u003c\u003c endl; } ","date":"2020-03-21","objectID":"/2020-03-21-11576/:0:0","tags":["algorithm","C++"],"title":"[백준]11576 Base Conversion","uri":"/2020-03-21-11576/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-21","objectID":"/2020-03-21-2506/","tags":["algorithm","C++"],"title":"[백준]2506 점수 계산","uri":"/2020-03-21-2506/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2506 풀이: 연속으로 맞춘다면 추가 점수가 있게 하여 총점을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, s, c = 0, a; int main() { cin \u003e\u003e n; while (n--) { cin \u003e\u003e a; if (a) s += a + c, c++; else c = 0; } cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-03-21","objectID":"/2020-03-21-2506/:0:0","tags":["algorithm","C++"],"title":"[백준]2506 점수 계산","uri":"/2020-03-21-2506/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-21","objectID":"/2020-03-21-2822/","tags":["algorithm","C++","구현"],"title":"[백준]2822 점수 계산","uri":"/2020-03-21-2822/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2822 풀이: 첫째 줄에 참가자의 총점을 출력한다. 둘째 줄에는 어떤 문제가 최종 점수에 포함되는지를 공백으로 구분하여 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int n, m, k, s = 0; int main() { vector\u003cpair\u003cint, int\u003e\u003ea; for (int i = 1; i \u003c 9; i++) { cin \u003e\u003e n; if (i \u003e= 6) { m = 151; for (int t = 0; t \u003c 5; t++) if (a[t].first \u003c m) m = a[t].first, k = t; if (a[k].first \u003c n) a.erase(a.begin() + k), a.push_back({ n,i }); } else a.push_back({ n, i }); } for (auto i : a) s += i.first; cout \u003c\u003c s \u003c\u003c endl; for (auto i : a) cout \u003c\u003c i.second \u003c\u003c \" \"; cout \u003c\u003c endl; } ","date":"2020-03-21","objectID":"/2020-03-21-2822/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]2822 점수 계산","uri":"/2020-03-21-2822/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-20","objectID":"/2020-03-20-1547/","tags":["algorithm","C++"],"title":"[백준]1547 공","uri":"/2020-03-20-1547/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1547 풀이: 주어진 입력에 따라 컵의 위치를 바꾼다. 입력이 끝난 후 공이 들어있는 컵의 번호를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, x, y, a[4] = { 0,1 }; int main() { cin \u003e\u003e n; while (n--) { cin \u003e\u003e x \u003e\u003e y; swap(a[x], a[y]); } for (int i = 1; i \u003c 4; i++) if (a[i]) cout \u003c\u003c i \u003c\u003c endl; } ","date":"2020-03-20","objectID":"/2020-03-20-1547/:0:0","tags":["algorithm","C++"],"title":"[백준]1547 공","uri":"/2020-03-20-1547/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-20","objectID":"/2020-03-20-2501/","tags":["algorithm","C++"],"title":"[백준]2501 약수 구하기","uri":"/2020-03-20-2501/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2501 풀이: n의 약수들 중 k번째로 작은 수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, k, i, c = 0; int main() { cin \u003e\u003e n \u003e\u003e k; for (i = 1; i \u003c= n; i++) if (!(n % i)) { k--; if (!k) { c = i; break; } } cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-03-20","objectID":"/2020-03-20-2501/:0:0","tags":["algorithm","C++"],"title":"[백준]2501 약수 구하기","uri":"/2020-03-20-2501/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-19","objectID":"/2020-03-19-10867/","tags":["algorithm","C++"],"title":"[백준]10867 중복 빼고 정렬하기","uri":"/2020-03-19-10867/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10867 풀이: N개의 정수를 중복을 제외하고 오름차순으로 정렬하여 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cset\u003eusing namespace std; int main() { int n, a; set\u003cint\u003e s; cin \u003e\u003e n; while (n--) {cin \u003e\u003e a; s.insert(a);} for (auto i : s) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; } ","date":"2020-03-19","objectID":"/2020-03-19-10867/:0:0","tags":["algorithm","C++"],"title":"[백준]10867 중복 빼고 정렬하기","uri":"/2020-03-19-10867/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-19","objectID":"/2020-03-19-1516/","tags":["algorithm","C++","위상 정렬"],"title":"[백준]1516 게임 개발","uri":"/2020-03-19-1516/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1516 풀이: [백준]1005 ACM Craft 참고 코드: 사용언어 : c++ #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003calgorithm\u003eusing namespace std; int N, i, q, a[502], b[502]; vector\u003cvector\u003cint\u003e\u003ev; int A(int x) { if (b[x]) return b[x]; for (int t : v[x]) b[x] = max(b[x], A(t)); b[x] += a[x]; return b[x]; } int main() { cin \u003e\u003e N; v.resize(N + 1); for (i = 1; i \u003c= N; i++) { cin \u003e\u003e a[i] \u003e\u003e q; while (q != -1) v[i].push_back(q), cin \u003e\u003e q; } for (i = 1; i \u003c= N; i++) cout \u003c\u003c A(i) \u003c\u003c endl; } ","date":"2020-03-19","objectID":"/2020-03-19-1516/:0:0","tags":["algorithm","C++","위상 정렬"],"title":"[백준]1516 게임 개발","uri":"/2020-03-19-1516/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-19","objectID":"/2020-03-19-4101/","tags":["algorithm","C++"],"title":"[백준]4101 크냐?","uri":"/2020-03-19-4101/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/4101 풀이: 첫 번째 수가 두 번째 수보다 크면 Yes를, 아니면 No를 한 줄에 하나씩 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int a, b; int main() { while (1) { cin \u003e\u003e a \u003e\u003e b; if (!a \u0026\u0026 !b)break; printf(\"%s\\n\", a \u003e b ? \"Yes\" : \"No\"); } } ","date":"2020-03-19","objectID":"/2020-03-19-4101/:0:0","tags":["algorithm","C++"],"title":"[백준]4101 크냐?","uri":"/2020-03-19-4101/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-19","objectID":"/2020-03-19-4999/","tags":["algorithm","C++"],"title":"[백준]4999 아!","uri":"/2020-03-19-4999/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/4999 풀이: 의사가 듣기 원하는 소리의 길이가 재환이가 가장 길게 낼 수 있는 소리보다 크다면, “no\"를 아니라면 “go” 를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { string a, b; cin \u003e\u003e a \u003e\u003e b; printf(\"%s\\n\", a.size() \u003c b.size() ? \"no\" : \"go\"); } ","date":"2020-03-19","objectID":"/2020-03-19-4999/:0:0","tags":["algorithm","C++"],"title":"[백준]4999 아!","uri":"/2020-03-19-4999/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-19","objectID":"/2020-03-19-5598/","tags":["algorithm","C++","문자열"],"title":"[백준]5598 카이사르 암호","uri":"/2020-03-19-5598/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5598 풀이: 입력받은 카이사르 단어를 원래 단어로 고친 걸 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { string s; cin \u003e\u003e s; for (char c : s) printf(\"%c\", c \u003c 68 ? c + 23 : c - 3); cout \u003c\u003c endl; } ","date":"2020-03-19","objectID":"/2020-03-19-5598/:0:0","tags":["algorithm","C++","문자열"],"title":"[백준]5598 카이사르 암호","uri":"/2020-03-19-5598/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-19","objectID":"/2020-03-19-9316/","tags":["algorithm","C++"],"title":"[백준]9316 Hello Judge","uri":"/2020-03-19-9316/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9316 풀이: 한 줄에 하나의 Hello World, Judge i! 를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int a; cin \u003e\u003e a; for (int i = 1; i \u003c= a; i++)printf(\"Hello World, Judge %d!\\n\", i); } ","date":"2020-03-19","objectID":"/2020-03-19-9316/:0:0","tags":["algorithm","C++"],"title":"[백준]9316 Hello Judge","uri":"/2020-03-19-9316/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-19","objectID":"/2020-03-19-9325/","tags":["algorithm","C++"],"title":"[백준]9325 얼마?","uri":"/2020-03-19-9325/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9325 풀이: 각 케이스 마다 자동차의 가격에 옵션의 가격을 더하여 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int T, n, a, b, c; cin \u003e\u003e T; while (T--) { cin \u003e\u003e a \u003e\u003e n; while (n--) { cin \u003e\u003e b \u003e\u003e c; a += b * c; } cout \u003c\u003c a \u003c\u003c endl; } } ","date":"2020-03-19","objectID":"/2020-03-19-9325/:0:0","tags":["algorithm","C++"],"title":"[백준]9325 얼마?","uri":"/2020-03-19-9325/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-18","objectID":"/2020-03-18-2864/","tags":["algorithm","C++","문자열","수학"],"title":"[백준]2864 5와 6의 차이","uri":"/2020-03-18-2864/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2864 풀이: 두 정수 A 와 B 의 숫자 중 5 와 6 을 전부 5 로 바꾼 값들을 더한 값이 최솟값, 6 으로 바꾼 값들을 더한 값이 최댓값이 된다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main() { string a, b, c, d, e, f; cin \u003e\u003e a \u003e\u003e b; for (char i : a) if (i == 54 || i == 53) c += '6', d += '5'; else c += i, d += i; for (char i : b) if (i == 54 || i == 53) e += '6', f += '5'; else e += i, f += i; printf(\"%d %d\\n\", stoi(d) + stoi(f), stoi(c) + stoi(e)); } ","date":"2020-03-18","objectID":"/2020-03-18-2864/:0:0","tags":["algorithm","C++","문자열","수학"],"title":"[백준]2864 5와 6의 차이","uri":"/2020-03-18-2864/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-17","objectID":"/2020-03-17-10156/","tags":["algorithm","C++"],"title":"[백준]10156 과자","uri":"/2020-03-17-10156/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10156 풀이: 과자 한개의 가격 * 과자의 개수 - 현재 가진 돈 을 출력한다. 만약 출력값이 음수라면 0을 출력한다. (필요한 돈보다 가진돈이 많은 것이므로 부모님께 받을 필요없음.) 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int k, n, m; int main() { cin \u003e\u003e k \u003e\u003e n \u003e\u003e m; k = k * n - m; if (k \u003c 0) k = 0; cout \u003c\u003c k \u003c\u003c endl; } ","date":"2020-03-17","objectID":"/2020-03-17-10156/:0:0","tags":["algorithm","C++"],"title":"[백준]10156 과자","uri":"/2020-03-17-10156/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-17","objectID":"/2020-03-17-10707/","tags":["algorithm","C++","구현"],"title":"[백준]10707 수도요금","uri":"/2020-03-17-10707/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10707 풀이: X사의 1리터당 요금 * 한 달간의 수도의 양 Y사의 기본요금 + (Y사의 1리터당 추가요금 * (한 달간의 수도의 양 - 기본요금이 되는 사용량의 상한)) 둘 중 더 싼 금액을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int a, b, c, d ,p; int main() { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d \u003e\u003e p; a *= p, b += p \u003c c ? 0 : (p - c) * d; printf(\"%d\\n\", a \u003c b ? a : b); } ","date":"2020-03-17","objectID":"/2020-03-17-10707/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]10707 수도요금","uri":"/2020-03-17-10707/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-17","objectID":"/2020-03-17-10833/","tags":["algorithm","C++"],"title":"[백준]10833 사과","uri":"/2020-03-17-10833/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10833 풀이: 배정된 사과 수를 학생수로 나눈 나머지를 모두 더해 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int N, a, b, c = 0; int main() { cin \u003e\u003e N; while (N--) { cin \u003e\u003e a \u003e\u003e b; c += b % a; } cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-03-17","objectID":"/2020-03-17-10833/:0:0","tags":["algorithm","C++"],"title":"[백준]10833 사과","uri":"/2020-03-17-10833/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-17","objectID":"/2020-03-17-11655/","tags":["algorithm","C++"],"title":"[백준]11655 ROT13","uri":"/2020-03-17-11655/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11655 풀이: ROT13으로 암호화한 내용을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main() { string s; getline(cin, s); for (char c : s) printf(\"%c\", c \u003c 65 ? c : (c \u003c 97 \u0026\u0026 c \u003e 77) || c \u003e 109 ? c - 13 : c + 13); cout \u003c\u003c endl; } ","date":"2020-03-17","objectID":"/2020-03-17-11655/:0:0","tags":["algorithm","C++"],"title":"[백준]11655 ROT13","uri":"/2020-03-17-11655/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-17","objectID":"/2020-03-17-2566/","tags":["algorithm","C++"],"title":"[백준]2566 최댓값","uri":"/2020-03-17-2566/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2566 풀이: 9 * 9 칸에 있는 숫자들 중 최댓값과 그 위치를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int i, a, x, c = 0; int main() { for (i = 0; i \u003c 81; i++){ cin \u003e\u003e a; if (a \u003e c) c = a, x = i; } printf(\"%d %d %d\", c, x / 9 + 1, x % 9 + 1); } ","date":"2020-03-17","objectID":"/2020-03-17-2566/:0:0","tags":["algorithm","C++"],"title":"[백준]2566 최댓값","uri":"/2020-03-17-2566/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-17","objectID":"/2020-03-17-2953/","tags":["algorithm","C++","배열"],"title":"[백준]2953 나는 요리사다","uri":"/2020-03-17-2953/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2953 풀이: 첫째 줄부터 다섯번쨰 줄까지의 사람 중 점수의 합이 가장 높은 사람과 그 점수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int i, a, b, c, d, s, t = 0; int main() { for (i = 1; i \u003c 6; i++) { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d; a += b + c + d; if (a \u003e t) t = a, s = i; } printf(\"%d %d\", s, t); } ","date":"2020-03-17","objectID":"/2020-03-17-2953/:0:0","tags":["algorithm","C++","배열"],"title":"[백준]2953 나는 요리사다","uri":"/2020-03-17-2953/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-17","objectID":"/2020-03-17-5063/","tags":["algorithm","C++","구현"],"title":"[백준]5063 TGN","uri":"/2020-03-17-5063/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5063 풀이: 광고를 했을 때의 수익 - 광고 비용 이 광고를 했을 떄 얻을 수 있는 순이익이다. 즉, 광고를 하지않았을 때의 수익과 광고를 했을 때 얻을 수 있는 순 이익을 비교하여, 해야 하면 “advertise”, 하지 않아야 하면 “do not advertise”, 광고를 해도 수익이 차이가 없다면 “does not matter\"를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int T, k, n, m; int main() { cin \u003e\u003e T; while (T--) { cin \u003e\u003e k \u003e\u003e n \u003e\u003e m; n -= m; if (k == n) cout \u003c\u003c \"does not matter\" \u003c\u003c endl; else if (k \u003c n) cout \u003c\u003c \"advertise\" \u003c\u003c endl; else cout \u003c\u003c \"do not advertise\" \u003c\u003c endl; } } ","date":"2020-03-17","objectID":"/2020-03-17-5063/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]5063 TGN","uri":"/2020-03-17-5063/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-10820/","tags":["algorithm","C++"],"title":"[백준]10820 문자열 분석","uri":"/2020-03-16-10820/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10820 풀이: [C++]대소문자, 숫자 구분함수 참고 따로 종료 조건이 없으므로 EOF 처리를 해주자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main() { string s; while (getline(cin, s)) { int a = 0, b = 0, c = 0, d = 0; for (char i : s) if (islower(i)) a++; else if (isupper(i)) b++; else if (isdigit(i)) c++; else d++; printf(\"%d %d %d %d\\n\", a, b, c, d); } } ","date":"2020-03-16","objectID":"/2020-03-16-10820/:0:0","tags":["algorithm","C++"],"title":"[백준]10820 문자열 분석","uri":"/2020-03-16-10820/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-10988/","tags":["algorithm","C++","문자열"],"title":"[백준]10988 팰린드롬인지 확인하기","uri":"/2020-03-16-10988/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10988 풀이: 팰린드롬 : 기러기, 토마토 등 뒤집어도 같은단어 주어진 단어가 팰린드롬이라면 1, 아니라면 0을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { string a; bool b = true; cin \u003e\u003e a; for (int i = 0; i \u003c a.size() / 2; i++) if (a[i] != a[a.size() - i - 1]) b = false; if (b) cout \u003c\u003c \"1\" \u003c\u003c endl; else cout \u003c\u003c \"0\" \u003c\u003c endl; } ","date":"2020-03-16","objectID":"/2020-03-16-10988/:0:0","tags":["algorithm","C++","문자열"],"title":"[백준]10988 팰린드롬인지 확인하기","uri":"/2020-03-16-10988/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-10991/","tags":["algorithm","C++","별 찍기"],"title":"[백준]10991 별 찍기 - 16","uri":"/2020-03-16-10991/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10991 풀이: N개의 줄에 N개의 글자를 출력한다. 첫 줄에는 N-1개의 \" “와 1개의 “* “을 두 번째 줄에는 N-2개의 \" “와 2개의 “* “을 . . . i번째 줄에는 N-i개의 \" “와 i개의 “* “을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int N, i, t; int main() { cin \u003e\u003e N; for (i = 0; i \u003c N; i++) { for (t = 1; t \u003c N - i; t++) cout \u003c\u003c \" \"; for (; t \u003c= N; t++) cout \u003c\u003c \"* \"; cout \u003c\u003c endl; } } ","date":"2020-03-16","objectID":"/2020-03-16-10991/:0:0","tags":["algorithm","C++","별 찍기"],"title":"[백준]10991 별 찍기 - 16","uri":"/2020-03-16-10991/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-10992/","tags":["algorithm","C++","별 찍기"],"title":"[백준]10992 별 찍기 - 17","uri":"/2020-03-16-10992/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10992 풀이: 첫줄에 1개, 마지막줄에 2 * N - 1개 i번째 줄에는 N - i 칸 띄고, “” 한개, 2 * i - 1 칸 띄고, “” 한개 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int N, i, t; int main() { cin \u003e\u003e N; for (i = 0; i \u003c N; i++) { for (t = 1; t \u003c N - i; t++) cout \u003c\u003c \" \"; cout \u003c\u003c \"*\"; for (t = 0; t \u003c 2 * i - 1; t++) printf(\"%s\", i == N - 1 ? \"*\" : \" \"); printf(\"%s\\n\",!i?\"\":\"*\"); } cout \u003c\u003c endl; } ","date":"2020-03-16","objectID":"/2020-03-16-10992/:0:0","tags":["algorithm","C++","별 찍기"],"title":"[백준]10992 별 찍기 - 17","uri":"/2020-03-16-10992/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-11659/","tags":["algorithm","C++"],"title":"[백준]11659 구간 합 구하기","uri":"/2020-03-16-11659/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11659 풀이: a[i] : 1 ~ i 까지의 구간 합 i ~ j 까지의 구간 합 = 1 ~ j 까지의 구간 합 - 1 ~ i - 1 까지의 구간 합 cin, cout 은 시간초과가 나므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int N, M, q, w, i, a[100002]; int main() { scanf(\"%d%d\",\u0026N,\u0026M); for (i = 1; i \u003c= N; i++){ scanf(\"%d\",\u0026q); a[i] = a[i - 1] + q; } while (M--) { scanf(\"%d%d\",\u0026q,\u0026w); printf(\"%d\\n\", a[w] - a[q - 1]); } } ","date":"2020-03-16","objectID":"/2020-03-16-11659/:0:0","tags":["algorithm","C++"],"title":"[백준]11659 구간 합 구하기","uri":"/2020-03-16-11659/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-11728/","tags":["algorithm","C++"],"title":"[백준]11728 배열 합치기","uri":"/2020-03-16-11728/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11728 풀이: n + m 만큼의 숫자를 받아온다. 받아온 숫자를 정렬하여 출력한다. cin, cout 은 시간초과가 나므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int n, m; int main() { scanf(\"%d%d\",\u0026n,\u0026m); n += m; priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e a; while (n--) { scanf(\"%d\",\u0026m); a.push(m); } while (!a.empty()) printf(\"%d \",a.top()), a.pop(); printf(\"\\n\"); } ","date":"2020-03-16","objectID":"/2020-03-16-11728/:0:0","tags":["algorithm","C++"],"title":"[백준]11728 배열 합치기","uri":"/2020-03-16-11728/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-1915/","tags":["algorithm","C++","DP"],"title":"[백준]1915 가장 큰 정사각형","uri":"/2020-03-16-1915/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1915 풀이: b[i][t] : i , t 가 오른쪽 아래 꼭짓점인 정사각형의 한 변의 길이 i, t가 0이라면, 정사각형을 만들 수 없으므로 0 i, t 의 수가 1이라면, b[i][t] = (b[i - 1][t], b[i][t - 1], b[i - 1][t - 1] 의 최솟값) + 1 넓이 이므로 b[i][t] 중 가장 큰 값을 제곱하여 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, t, a, b[1002][1002], s = 0; int main() { cin \u003e\u003e n \u003e\u003e m; for (i = 0; i \u003c n; i++) for (t = 0; t \u003c m; t++) { scanf_s(\"%1d\",\u0026a); if (a) { if (i \u0026\u0026 t) { b[i][t] = b[i - 1][t] \u003e b[i][t - 1] ? b[i][t - 1] : b[i - 1][t]; b[i][t] = b[i][t] \u003e b[i - 1][t - 1] ? b[i - 1][t - 1] : b[i][t]; } b[i][t]++; s = s \u003e b[i][t] ? s : b[i][t]; } } cout \u003c\u003c s * s \u003c\u003c endl; } ","date":"2020-03-16","objectID":"/2020-03-16-1915/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1915 가장 큰 정사각형","uri":"/2020-03-16-1915/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-1922/","tags":["algorithm","C++","최소 스패닝 트리"],"title":"[백준]1922 네트워크 연결","uri":"/2020-03-16-1922/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1922 풀이: [백준]1197 최소 스패닝 트리 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003eusing namespace std; typedef pair\u003cint, int\u003e P; int N, E, q, w, e, b[1002] = { 1,1 }; int main() { cin \u003e\u003e N \u003e\u003e E; vector\u003cpriority_queue\u003cP, vector\u003cP\u003e, greater\u003cP\u003e\u003e\u003e a(N + 1); vector\u003cint\u003e v = { 1 }; for (int i = 0; i \u003c E; i++) { cin \u003e\u003e q \u003e\u003e w \u003e\u003e e; a[q].push({ e,w }); a[w].push({ e,q }); } P p; q = 0; while (1) { p = { 10002, 0 }; for (int i : v) while (!a[i].empty()) if (b[a[i].top().second]) a[i].pop(); else if (p.first \u003e a[i].top().first) p = a[i].top(); else break; if (p.first \u003c 10002) { b[p.second]++; v.push_back(p.second); q += p.first; } else break; } cout \u003c\u003c q \u003c\u003c endl; } ","date":"2020-03-16","objectID":"/2020-03-16-1922/:0:0","tags":["algorithm","C++","최소 스패닝 트리"],"title":"[백준]1922 네트워크 연결","uri":"/2020-03-16-1922/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-2252/","tags":["algorithm","C++","위상 정렬"],"title":"[백준]2252 줄 세우기","uri":"/2020-03-16-2252/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2252 풀이: b[i] : i 보다 작은 사람들의 수 b[i] 가 0인 i를 맨 앞에 세운다. i보다 큰 학생들을 t라고 할 때, b[t] 값을 각각 -1 해준다. 모든 학생들을 세울때까지 반복한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int n, m, i, q, w, b[32002], c[32002]; int main() { cin \u003e\u003e n \u003e\u003e m; vector\u003cvector\u003cint\u003e\u003e a(n + 1); vector\u003cint\u003e v; for (i = 0; i \u003c m; i++) { cin \u003e\u003e q \u003e\u003e w; a[q].push_back(w), b[w]++; } while (v.size() != n) for (i = 1; i \u003c= n; i++) if (!b[i] \u0026\u0026 !c[i]) { c[i] = 1, v.push_back(i); for (int t : a[i]) b[t]--; break; } for (int t : v) cout \u003c\u003c t \u003c\u003c \" \"; cout \u003c\u003c endl; } ","date":"2020-03-16","objectID":"/2020-03-16-2252/:0:0","tags":["algorithm","C++","위상 정렬"],"title":"[백준]2252 줄 세우기","uri":"/2020-03-16-2252/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-2420/","tags":["algorithm","C++"],"title":"[백준]2420 사파리월드","uri":"/2020-03-16-2420/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2420 풀이: 두 유명도의 차이를 절댓값으로 출력한다. 두 도메인의 크기가 매우 크므로 long long 으로 받자. long long 형으로 받았으므로 abs 가 아닌 llabs를 쓰자 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; long long a, b; int main() { cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c llabs(a - b) \u003c\u003c endl; } ","date":"2020-03-16","objectID":"/2020-03-16-2420/:0:0","tags":["algorithm","C++"],"title":"[백준]2420 사파리월드","uri":"/2020-03-16-2420/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-2530/","tags":["algorithm","C++"],"title":"[백준]2530 인공지능 시계","uri":"/2020-03-16-2530/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2530 풀이: 요리에 필요한 시간 D를 초에 더한다. 초 C를 60으로 나눈 몫을 분에 더한다. 초는 나눈 나머지가 된다. 분 B를 60으로 나눈 몫을 시에 더하다. 분은 나눈 나머지가 된다. 시를 24로 나눈 나머지로 바꾼다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int a, b, c, d; int main() { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d; c += d, b += c / 60, c %= 60, a += b / 60, b %= 60, a %= 24; printf(\"%d %d %d\", a, b, c); } ","date":"2020-03-16","objectID":"/2020-03-16-2530/:0:0","tags":["algorithm","C++"],"title":"[백준]2530 인공지능 시계","uri":"/2020-03-16-2530/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-16","objectID":"/2020-03-16-5597/","tags":["algorithm","C++","구현"],"title":"[백준]5597 과제 안 내신 분..?","uri":"/2020-03-16-5597/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5597 풀이: 과제를 낸 28 명을 기록한다. 30 명 중 기록이 안돼어있는 학생 2명을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int a[31], i = 28, b; int main() { while (i--) { cin \u003e\u003e b; a[b] = 1; } for (i = 1; i \u003c= 30; i++) if (!a[i]) cout \u003c\u003c i \u003c\u003c endl; } ","date":"2020-03-16","objectID":"/2020-03-16-5597/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]5597 과제 안 내신 분..?","uri":"/2020-03-16-5597/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-15","objectID":"/2020-03-15-10824/","tags":["algorithm","C++"],"title":"[백준]10824 네 수","uri":"/2020-03-15-10824/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10824 풀이: A, B, C, D 를 각각 string으로 받아 붙힌 후 숫자로 변환하여 더해 출력한다. stoi 는 int형식으로 각각 1,000,000 까지 가능 한 두 수를 붙힌다면 넘어가므로 stoll을 사용하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; string a,b,c,d; int main() { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d; cout \u003c\u003c stoll(a + b) + stoll(c + d) \u003c\u003c endl; } ","date":"2020-03-15","objectID":"/2020-03-15-10824/:0:0","tags":["algorithm","C++"],"title":"[백준]10824 네 수","uri":"/2020-03-15-10824/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-15","objectID":"/2020-03-15-2644/","tags":["algorithm","C++","BFS"],"title":"[백준]2644 촌수계산","uri":"/2020-03-15-2644/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2644 풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003eusing namespace std; int n, k, e, q, w, m, d[102], b[102]; int main() { cin \u003e\u003e n \u003e\u003e k \u003e\u003e e \u003e\u003e m; vector\u003cvector\u003cint\u003e\u003e a(n + 1); priority_queue\u003cpair\u003cint, int\u003e\u003e p; while(m--) { cin \u003e\u003e q \u003e\u003e w; a[q].push_back(w), a[w].push_back(q); } fill(d, d + n + 1, 101); d[k] = 0; p.push({ 0, k }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = true; for (auto t : a[w]) { if (d[t] \u003e d[w] + 1) { d[t] = d[w] + 1; p.push({ -d[t], t }); } } } if (d[e] == 101) d[e] = -1; cout \u003c\u003c d[e] \u003c\u003c endl; } ","date":"2020-03-15","objectID":"/2020-03-15-2644/:0:0","tags":["algorithm","C++","BFS"],"title":"[백준]2644 촌수계산","uri":"/2020-03-15-2644/"},{"categories":["Learn"],"content":"learn","date":"2020-03-14","objectID":"/2020-03-14-topologicalsort/","tags":["Learn","C++","위상 정렬"],"title":"[C++]위상 정렬(Topological Sort)","uri":"/2020-03-14-topologicalsort/"},{"categories":["Learn"],"content":"위상 정렬(Topological Sort) 위상 정렬 방향 그래프의 노드에 대해 순서를 매겨 정렬하는 방법 정렬 후에 각 노드에 대해 순서가 위배되지 않아야한다. 사이클이 있다면 불가능하다. 들어오는 간선이 없는 노드를 삭제하면서, 정렬한다. ","date":"2020-03-14","objectID":"/2020-03-14-topologicalsort/:0:0","tags":["Learn","C++","위상 정렬"],"title":"[C++]위상 정렬(Topological Sort)","uri":"/2020-03-14-topologicalsort/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-14","objectID":"/2020-03-14-10797/","tags":["algorithm","C++","구현"],"title":"[백준]10797 10부제","uri":"/2020-03-14-10797/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10797 풀이: 날짜의 일의 자리 숫자와 자동차의 일의 자리 숫자가 같다면 차량의 대수를 +1 해준다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, s = 0; int main() { cin \u003e\u003e n; for (i = 0; i \u003c 5; i++) { cin \u003e\u003e m; if (n == m) s++; } cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-03-14","objectID":"/2020-03-14-10797/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]10797 10부제","uri":"/2020-03-14-10797/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-14","objectID":"/2020-03-14-10815/","tags":["algorithm","C++","이분 탐색"],"title":"[백준]10815 숫자 카드","uri":"/2020-03-14-10815/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10815 풀이: [C++]lower_bound, upper_bound 참고 cin, cout 은 시간초과가 날 수 있으므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m, i, k, a[500002]; int main() { cin \u003e\u003e n; for (i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; sort(a, a + n); cin \u003e\u003e m; while (m--) { cin \u003e\u003e k; if (*lower_bound(a, a + n, k) == k) cout \u003c\u003c \"1 \"; else cout \u003c\u003c \"0 \"; } cout \u003c\u003c endl; } ","date":"2020-03-14","objectID":"/2020-03-14-10815/:0:0","tags":["algorithm","C++","이분 탐색"],"title":"[백준]10815 숫자 카드","uri":"/2020-03-14-10815/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-14","objectID":"/2020-03-14-10974/","tags":["algorithm","C++","순열"],"title":"[백준]10974 모든 순열","uri":"/2020-03-14-10974/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10974 풀이: [C++]순열 참고 cin, cout 은 시간초과가 날 수 있으므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int n, i; vector\u003cint\u003e v; int main() { scanf(\"%d\",\u0026n); for (i = 1; i \u003c= n; i++) v.push_back(i); do { for (int i : v) printf(\"%d \",i); printf(\"\\n\"); } while (next_permutation(v.begin(), v.end())); } ","date":"2020-03-14","objectID":"/2020-03-14-10974/:0:0","tags":["algorithm","C++","순열"],"title":"[백준]10974 모든 순열","uri":"/2020-03-14-10974/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-14","objectID":"/2020-03-14-1916/","tags":["algorithm","C++","다익스트라"],"title":"[백준]1916 최소비용 구하기","uri":"/2020-03-14-1916/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1916 풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int n, m, u, d[1002], s, e, c, b[1002]; int main() { cin \u003e\u003e n \u003e\u003e m; priority_queue\u003cpair\u003cint, int\u003e\u003e p; vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003e a(n + 1); while (m--) { cin \u003e\u003e s \u003e\u003e e \u003e\u003e c; a[s].push_back({ e,c }); } cin \u003e\u003e s \u003e\u003e e; fill(d, d + n + 1, 987654321); d[s] = 0; p.push({ 0, s }); while (!p.empty()) { s = p.top().second; p.pop(); if (b[s]) continue; b[s] = true; for (auto t : a[s]) { u = t.first, c = t.second; if (d[u] \u003e d[s] + c) { d[u] = d[s] + c; p.push({ -d[u], u }); } } } cout \u003c\u003c d[e] \u003c\u003c endl; } ","date":"2020-03-14","objectID":"/2020-03-14-1916/:0:0","tags":["algorithm","C++","다익스트라"],"title":"[백준]1916 최소비용 구하기","uri":"/2020-03-14-1916/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-14","objectID":"/2020-03-14-2003/","tags":["algorithm","C++","구현"],"title":"[백준]2003 수들의 합 2","uri":"/2020-03-14-2003/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2003 풀이: A[i] 부터 A[j] 까지 하나씩 더해가는 값을 s라고 하자. 만약, s가 m과 같다면, 경우의 수를 +1 해준다. 만약, s가 m보다 크다면, i를 1 더해주고, 다시 반복한다. i가 n이 될때까지 반복 후 경우의 수를 출력해준다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, t, a[10002], s, c = 0; int main() { scanf(\"%d%d\",\u0026n,\u0026m); for (i = 0; i \u003c n; i++) scanf(\"%d\",\u0026a[i]); for (i = 0; i \u003c n; i++) { s = 0; for (t = i; t \u003c n; t++) { s += a[t]; if (s == m) c++; if (s \u003e= m) break; } } printf(\"%d\\n\",c); } ","date":"2020-03-14","objectID":"/2020-03-14-2003/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]2003 수들의 합 2","uri":"/2020-03-14-2003/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-14","objectID":"/2020-03-14-2446/","tags":["algorithm","C++"],"title":"[백준]2446 별 찍기 - 9","uri":"/2020-03-14-2446/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2446 풀이: [백준]2442 별찍기 - 5 에 나온 삼각형을 방향을 반대로 2번 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n; int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n - 1; i++) { for (int t = 0; t \u003c i; t++) cout \u003c\u003c \" \"; for (int t = 1; t \u003c (n -i) * 2; t++) cout \u003c\u003c \"*\"; cout \u003c\u003c endl; } for (int i = 0; i \u003c n; i++) { for (int t = 1; t \u003c n - i; t++) cout \u003c\u003c \" \"; for (int t = 0; t \u003c i * 2 + 1; t++) cout \u003c\u003c \"*\"; cout \u003c\u003c endl; } } ","date":"2020-03-14","objectID":"/2020-03-14-2446/:0:0","tags":["algorithm","C++"],"title":"[백준]2446 별 찍기 - 9","uri":"/2020-03-14-2446/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-14","objectID":"/2020-03-14-2583/","tags":["algorithm","C++","BFS","DFS"],"title":"[백준]2583 영역 구하기","uri":"/2020-03-14-2583/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2583 풀이: 직사각형이 들어있는 곳을 1, 없는곳을 0으로 해놓은 배열을 만든다. 배열을 순회하며, 현재 값이 0 이라면, 영역의 개수를 +1 해주고, 연결된 모든 영역을 순회하여 1로 바꿔주고, 영역의 넓이를 배열에 저장한다. 배열의 모든 숫자가 1이라면, 영역의 개수를 출력하고, 각 영역의 넓이를 오름차순으로 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m, k, i, t, a[102][102], x1, x2, yl, y2, s = 0, b[5002]; void A(int x, int y) { a[x][y] = 1, b[s - 1]++; if (x \u003e 0 \u0026\u0026 !a[x - 1][y]) A(x - 1, y); if (y \u003e 0 \u0026\u0026 !a[x][y - 1]) A(x, y - 1); if (x + 1 \u003c n \u0026\u0026 !a[x + 1][y]) A(x + 1, y); if (y + 1 \u003c m \u0026\u0026 !a[x][y + 1]) A(x, y + 1); } int main() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e k; while(k--) { cin \u003e\u003e x1 \u003e\u003e yl \u003e\u003e x2 \u003e\u003e y2; for (i = x1; i \u003c x2; i++) for (t = yl; t \u003c y2; t++) a[i][t] = 1; } for (i = 0; i \u003c n; i++) for (t = 0; t \u003c m; t++) if (!a[i][t]) s++, A(i, t); cout \u003c\u003c s \u003c\u003c endl; sort(b, b + s); for (i = 0; i \u003c s; i++) cout \u003c\u003c b[i] \u003c\u003c \" \"; cout \u003c\u003c endl; } ","date":"2020-03-14","objectID":"/2020-03-14-2583/:0:0","tags":["algorithm","C++","BFS","DFS"],"title":"[백준]2583 영역 구하기","uri":"/2020-03-14-2583/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-03-14","objectID":"/2020-03-14-coloringbook/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]카카오프렌즈 컬러링북","uri":"/2020-03-14-coloringbook/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: ","date":"2020-03-14","objectID":"/2020-03-14-coloringbook/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]카카오프렌즈 컬러링북","uri":"/2020-03-14-coloringbook/"},{"categories":["프로그래머스"],"content":"카카오 프렌즈 컬러링북 출판사의 편집자인 어피치는 네오에게 컬러링북에 들어갈 원화를 그려달라고 부탁하여 여러 장의 그림을 받았다. 여러 장의 그림을 난이도 순으로 컬러링북에 넣고 싶었던 어피치는 영역이 많으면 색칠하기가 까다로워 어려워진다는 사실을 발견하고 그림의 난이도를 영역의 수로 정의하였다. (영역이란 상하좌우로 연결된 같은 색상의 공간을 의미한다.) 그림에 몇 개의 영역이 있는지와 가장 큰 영역의 넓이는 얼마인지 계산하는 프로그램을 작성해보자. 위의 그림은 총 12개 영역으로 이루어져 있으며, 가장 넓은 영역은 어피치의 얼굴면으로 넓이는 120이다. 풀이: 배열의 처음부터 순회한다. 만약 배열의 숫자가 0이 아니라면, 그 숫자와 맞닿아있고, 그 숫자와 같은 숫자인 모든 영역을 0으로 바꾼다. 영역의 개수(answer[0]) 값을 +1 해준다. 영역의 넓이가 현재 answer[1] 에 들어있는 값보다 크다면 바꿔준다. 배열의 모든 원소가 0이라면 순회를 종료한다. answer 을 return 해준다. 코드: 사용언어 : c++ #include \u003cvector\u003eusing namespace std; int s; vector\u003cint\u003e answer = {0, 0}; vector\u003cvector\u003cint\u003e\u003e a; void A(int x, int y, int c) { a[x][y] = 0, s++; if (x \u003e 0 \u0026\u0026 a[x - 1][y] == c) A(x - 1, y, c); if (y \u003e 0 \u0026\u0026 a[x][y - 1] == c) A(x, y - 1, c); if (x + 1 \u003c a.size() \u0026\u0026 a[x + 1][y] == c) A(x + 1, y, c); if (y + 1 \u003c a[0].size() \u0026\u0026 a[x][y + 1] == c) A(x, y + 1, c); } vector\u003cint\u003e solution(int m, int n, vector\u003cvector\u003cint\u003e\u003e picture) { a = picture; for (int i = 0; i \u003c m; i++) for (int t = 0; t \u003c n; t++) { s = 0; if (a[i][t]) { answer[0]++, A(i, t, a[i][t]); answer[1] = answer[1] \u003c s ? s : answer[1]; } } return answer; } ","date":"2020-03-14","objectID":"/2020-03-14-coloringbook/:1:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]카카오프렌즈 컬러링북","uri":"/2020-03-14-coloringbook/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-13","objectID":"/2020-03-13-10799/","tags":["algorithm","C++","스택"],"title":"[백준]10799 쇠막대기","uri":"/2020-03-13-10799/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10799 풀이: [프로그래머스]쇠막대기 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstack\u003eusing namespace std; int n, i, b = 0; stack\u003cchar\u003e a; string s; int main() { cin \u003e\u003e s; for (i = 0; i \u003c s.size() - 1; i++) if (s[i] == '(') if (s[i + 1] == ')') b += a.size(), i++; else a.push(s[i]); else a.pop(), b++; cout \u003c\u003c b + 1 \u003c\u003c endl; } ","date":"2020-03-13","objectID":"/2020-03-13-10799/:0:0","tags":["algorithm","C++","스택"],"title":"[백준]10799 쇠막대기","uri":"/2020-03-13-10799/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-13","objectID":"/2020-03-13-11403/","tags":["algorithm","C++","플로이드-와샬"],"title":"[백준]11403 경로 찾기","uri":"/2020-03-13-11403/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11403 풀이: [C++]플로이드-와샬 알고리즘(Floyd-Warshall Algorithm) 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#define F(i,n)for(int i=0;i\u003cn;i++) using namespace std; int n, a[102][102]; int main() { cin \u003e\u003e n; F(i, n) F(t, n) cin \u003e\u003e a[i][t]; F(u, 2) F(i, n) F(t, n) F(y, n) if(!a[i][t]) a[i][t] = a[i][y] \u0026 a[y][t]; F(i, n) { F(t, n) cout \u003c\u003c a[i][t] \u003c\u003c \" \"; cout \u003c\u003c endl; } } ","date":"2020-03-13","objectID":"/2020-03-13-11403/:0:0","tags":["algorithm","C++","플로이드-와샬"],"title":"[백준]11403 경로 찾기","uri":"/2020-03-13-11403/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-13","objectID":"/2020-03-13-2468/","tags":["algorithm","C++","BFS","DFS"],"title":"[백준]2468 안전 영역","uri":"/2020-03-13-2468/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2468 풀이: 물의 높이가 h 일 때, 지역의 높이가 h보다 작거나 같다면 잠겨있는 지역이라고 한다. 모든 지역을 순회하며, 현재 지역이 잠겨있지 않다면, 방문 표시를 해두고, 왼쪽, 오른쪽, 위, 아래 에 잠겨있지 않은 곳을 순회하며 방문표시를 한다. 연결된 모든 곳을 방문했다면, 안전한 영역을 +1 해준다. 물의 높이를 0 ~ (지역 중 최대 높이) 까지 순회한 후 안전한 영역의 최대치를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#define F(i,n)for(int i=0;i\u003cn;i++) using namespace std; int n, m = 0, a[102][102], b[102][102], s, r = 0; void A(int x, int y) { b[x][y] = 0; if (x \u003e 0 \u0026\u0026 b[x - 1][y]) A(x - 1, y); if (y \u003e 0 \u0026\u0026 b[x][y - 1]) A(x, y - 1); if (x + 1 \u003c n \u0026\u0026 b[x + 1][y]) A(x + 1, y); if (y + 1 \u003c n \u0026\u0026 b[x][y + 1]) A(x, y + 1); } int main() { cin \u003e\u003e n; F(i,n)F(t,n){ cin \u003e\u003e a[i][t]; m = m \u003c a[i][t] ? a[i][t] : m; } while (m--) { s = 0; F(i, n) F(t, n) if (a[i][t] \u003e m) b[i][t] = 1; else b[i][t] = 0; F(i, n) F(t, n) if (b[i][t]) s++, A(i, t); r = r \u003c s ? s : r; } cout \u003c\u003c r \u003c\u003c endl; } ","date":"2020-03-13","objectID":"/2020-03-13-2468/:0:0","tags":["algorithm","C++","BFS","DFS"],"title":"[백준]2468 안전 영역","uri":"/2020-03-13-2468/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-12","objectID":"/2020-03-12-11724/","tags":["algorithm","C++","BFS","DFS"],"title":"[백준]11724 연결 요소의 개수","uri":"/2020-03-12-11724/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11724 풀이: 방문하지 않은 정점과 연결된 모든 정점을 방문표시하고, 요소의 개수를 +1 해준다. 더이상 방문할 정점이 없을때까지 반복한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int n, m, i, t, c = 0, b[1002]; vector\u003cvector\u003cint\u003e\u003e a; void T(int x) { if (b[x]) return; b[x] = 1; for (int o : a[x]) T(o); } int main() { cin \u003e\u003e n \u003e\u003e m; a.resize(n + 1); while (m--) { cin \u003e\u003e i \u003e\u003e t; a[i].push_back(t),a[t].push_back(i); } for (; n \u003e 0; n--) if (!b[n]) c++, T(n); cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-03-12","objectID":"/2020-03-12-11724/:0:0","tags":["algorithm","C++","BFS","DFS"],"title":"[백준]11724 연결 요소의 개수","uri":"/2020-03-12-11724/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-12","objectID":"/2020-03-12-13458/","tags":["algorithm","C++"],"title":"[백준]13458 시험 감독","uri":"/2020-03-12-13458/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/13458 풀이: 각 시험장에 총감독관 1명씩이 꼭 들어간다. 즉 각 시험장에 있는 응시자의 수에서 총감독관이 감시할 수 있는 응시자의 수 B를 빼준다. 빼준 값에서 부감독관이 감시할 수 있는 응시자의 수 C를 나눈 값을 올림해 준다면, 부감독관의 수가 나온다. 감독관들의 수를 모두 더한값을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cmath.h\u003eusing namespace std; long long n, i, b, c, a[1000002], s = 0; int main() { cin \u003e\u003e n; for (i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; cin \u003e\u003e b \u003e\u003e c; for (i = 0; i \u003c n; i++) { a[i] -= b; if (a[i] \u003e 0) s += ceil((double)a[i] / c); s++; } cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-03-12","objectID":"/2020-03-12-13458/:0:0","tags":["algorithm","C++"],"title":"[백준]13458 시험 감독","uri":"/2020-03-12-13458/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-12","objectID":"/2020-03-12-2309/","tags":["algorithm","C++","브루트 포스"],"title":"[백준]2309 일곱 난쟁이","uri":"/2020-03-12-2309/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2309 풀이: 아홉 난쟁이의 키의 합을 S라고 하자. 아홉 난쟁이 중 랜덤으로 뽑은 두 명의 키의 합을 T라고 하자. S - T = 100 이라면 뽑은 두 난쟁이를 제외하고 오름차순으로 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[9], i, t, s = 0; int main() { for (i = 0; i \u003c 9; i++) { cin \u003e\u003e a[i]; s += a[i]; } sort(a, a + 9); for (i = 0; i \u003c 9; i++) { for (t = i + 1; t \u003c 9; t++) if (s - a[i] - a[t] == 100) break; if (s - a[i] - a[t] == 100) break; } for (s = 0; s \u003c 9; s++) if (s != i \u0026\u0026 s != t) cout \u003c\u003c a[s] \u003c\u003c endl; } ","date":"2020-03-12","objectID":"/2020-03-12-2309/:0:0","tags":["algorithm","C++","브루트 포스"],"title":"[백준]2309 일곱 난쟁이","uri":"/2020-03-12-2309/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-12","objectID":"/2020-03-12-2442/","tags":["algorithm","C++","별찍기"],"title":"[백준]2442 별 찍기 - 5","uri":"/2020-03-12-2442/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2442 풀이: 1 번째 줄부터 차례대로 1개 3개 5개 . . . i * 2 - 1 개 의 별을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, i, t; int main() { cin \u003e\u003e n; for (i = 1; i \u003c= n; i++) { for (t = 0; t \u003c n - i; t++) cout \u003c\u003c \" \"; for (t = 0; t \u003c 2 * i - 1; t++) cout \u003c\u003c \"*\"; cout \u003c\u003c endl; } } ","date":"2020-03-12","objectID":"/2020-03-12-2442/:0:0","tags":["algorithm","C++","별찍기"],"title":"[백준]2442 별 찍기 - 5","uri":"/2020-03-12-2442/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-12","objectID":"/2020-03-12-4963/","tags":["algorithm","C++"],"title":"[백준]4963 섬의 개수","uri":"/2020-03-12-4963/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/4963 풀이: 모든 지도를 순회한다. 만약 지도의 한 부분이 땅이라면, 연결된 모든 땅을 바다로 바꾼 후 섬의 개수를 +1 해준다. 지도의 모든 부분이 바다로 바뀔때까지 반복한다. 섬의 개수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, m, i, t, a[52][52], c; void I(int x, int y) { a[x][y] = 0; if (x \u003e 0 \u0026\u0026 y \u003e 0 \u0026\u0026 a[x - 1][y - 1]) I(x - 1, y - 1); if (x \u003e 0 \u0026\u0026 a[x - 1][y]) I(x - 1, y); if (x \u003e 0 \u0026\u0026 y + 1 \u003c n \u0026\u0026 a[x - 1][y + 1]) I(x - 1, y + 1); if (y \u003e 0 \u0026\u0026 a[x][y - 1]) I(x, y - 1); if (y + 1 \u003c n \u0026\u0026 a[x][y + 1]) I(x, y + 1); if (x + 1 \u003c m \u0026\u0026 y \u003e 0 \u0026\u0026 a[x + 1][y - 1]) I(x + 1, y - 1); if (x + 1 \u003c m \u0026\u0026 a[x + 1][y]) I(x + 1, y); if (x + 1 \u003c m \u0026\u0026 y + 1 \u003c n \u0026\u0026 a[x + 1][y + 1]) I(x + 1, y + 1); } int main() { while (1) { cin \u003e\u003e n \u003e\u003e m; c = 0; if (!n) break; for (i = 0; i \u003c m; i++) for (t = 0; t \u003c n; t++) cin \u003e\u003e a[i][t]; for (i = 0; i \u003c m; i++) for (t = 0; t \u003c n; t++) if (a[i][t])c++, I(i, t); cout \u003c\u003c c \u003c\u003c endl; } } ","date":"2020-03-12","objectID":"/2020-03-12-4963/:0:0","tags":["algorithm","C++"],"title":"[백준]4963 섬의 개수","uri":"/2020-03-12-4963/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-12","objectID":"/2020-03-12-5543/","tags":["algorithm","C++","구현"],"title":"[백준]5543 상근날드","uri":"/2020-03-12-5543/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5543 풀이: 햅버거 중 가장 싼 것 + 음료 중 가장 싼 것 - 50원 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int a,b,c,d,e; int main() { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d \u003e\u003e e; a = a \u003c b ? a : b; a = a \u003c c ? a : c; d = d \u003c e ? d : e; cout \u003c\u003c a + d - 50 \u003c\u003c endl; } ","date":"2020-03-12","objectID":"/2020-03-12-5543/:0:0","tags":["algorithm","C++","구현"],"title":"[백준]5543 상근날드","uri":"/2020-03-12-5543/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-11","objectID":"/2020-03-11-1225/","tags":["algorithm","C++"],"title":"[백준]1225 이상한 곱셈","uri":"/2020-03-11-1225/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1225 풀이: 123 * 45 -\u003e 1*4 + 1*5 + 2*4 + 2*5 + 3*4 + 3*4 -\u003e 1(4 + 5) + 2(4 + 5) + 3(4 + 5) -\u003e (1 + 2 + 3)(4 + 5) 즉, (왼쪽 숫자의 각 자릿수의 합) * (오른쪽 숫자의 각 자릿수의 합) 이다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; long long q = 0, w = 0, i; int main() { string a, b; cin \u003e\u003e a \u003e\u003e b; for (i = 0; i \u003c a.size(); i++) q += a[i] - '0'; for (i = 0; i \u003c b.size(); i++) w += b[i] - '0'; cout \u003c\u003c q * w \u003c\u003c endl; } ","date":"2020-03-11","objectID":"/2020-03-11-1225/:0:0","tags":["algorithm","C++"],"title":"[백준]1225 이상한 곱셈","uri":"/2020-03-11-1225/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-11","objectID":"/2020-03-11-1373/","tags":["algorithm","C++"],"title":"[백준]1373 2진수 8진수","uri":"/2020-03-11-1373/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1373 풀이: 2진수를 8진수로 변환하여 출력. 변환하는 방법은 11001100(2) 일때, 뒤에서 부터 3자리로 끊어서 생각한다. 011 001 100 -\u003e 3 1 4 주어진 수의 ‘길이’ 가 1,000,000 까지 갈 수 있으므로 주의하자. (수가 1,000,000 이 아니다. 수의 길이 이므로 엄청나게 큰 수가 들어온다.) 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int b, c, i, t; int main() { string s, a; cin \u003e\u003e s; for (i = s.size() - 1; i \u003e= 0; i -= 3) { c = 1, b = 0; for (t = 0; t \u003c 3; t++) { if (i \u003e= t \u0026\u0026 s[i - t] == '1') b += c; c *= 2; } a += to_string(b); } for (i = a.size() - 1; i \u003e= 0; i--) cout \u003c\u003c a[i]; cout \u003c\u003c endl; } ","date":"2020-03-11","objectID":"/2020-03-11-1373/:0:0","tags":["algorithm","C++"],"title":"[백준]1373 2진수 8진수","uri":"/2020-03-11-1373/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-10","objectID":"/2020-03-10-1389/","tags":["algorithm","C++","플로이드-와샬"],"title":"[백준]1389 케빈 베이컨의 6단계 법칙","uri":"/2020-03-10-1389/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1389 풀이: [C++]플로이드-와샬 알고리즘(Floyd-Warshall Algorithm) 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int N, M, q, w, d[102][102], a, s = 987654321, c, i, t, y; int main() { cin \u003e\u003e N \u003e\u003e M; for (i = 0; i \u003c M; i++) { cin \u003e\u003e q \u003e\u003e w; d[q][w] = 1; d[w][q] = 1; } for (i = 1; i \u003c= N; i++) for (t = 1; t \u003c= N; t++) if (i != t \u0026\u0026 !d[i][t]) d[i][t] = 987654321; for (i = 1; i \u003c= N; i++) for (t = 1; t \u003c= N; t++) for (y = 1; y \u003c= N; y++) d[t][y] = min(d[t][y], d[t][i] + d[i][y]); for (i = 1; i \u003c= N; i++) { c = 0; for (t = 1; t \u003c= N; t++) if (i != t) c += d[i][t]; if (c \u003c s) { s = c; a = i; } } cout \u003c\u003c a \u003c\u003c endl; } ","date":"2020-03-10","objectID":"/2020-03-10-1389/:0:0","tags":["algorithm","C++","플로이드-와샬"],"title":"[백준]1389 케빈 베이컨의 6단계 법칙","uri":"/2020-03-10-1389/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-09","objectID":"/2020-03-09-1238/","tags":["algorithm","C++","다익스트라"],"title":"[백준]1238 파티","uri":"/2020-03-09-1238/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1238 풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003e#include \u003calgorithm\u003eusing namespace std; int V, E, k, u, v, w, i, t, d1[1002], d2[1002], b[1002], s = 0; int main() { cin \u003e\u003e V \u003e\u003e E \u003e\u003e k; priority_queue\u003cpair\u003cint, int\u003e\u003e p; vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003ea(V + 1); for (i = 0; i \u003c E; i++) { cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; a[u].push_back({ v,w }); } fill(d2, d2 + V + 1, 987654321); d2[k] = 0; p.push({ 0, k }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = 1; for (auto t : a[w]) { u = t.first, v = t.second; if (d2[u] \u003e d2[w] + v) { d2[u] = d2[w] + v; p.push({ -d2[u], u }); } } } for (i = 1; i \u003c= V; i++) { if (i == k) continue; fill(d1, d1 + V + 1, 987654321); fill(b, b + V + 1, 0); d1[i] = 0; p.push({ 0, i }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = 1; for (auto t : a[w]) { u = t.first, v = t.second; if (d1[u] \u003e d1[w] + v) { d1[u] = d1[w] + v; p.push({ -d1[u], u }); } } } s = max(s, d1[k] + d2[i]); } cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-03-09","objectID":"/2020-03-09-1238/:0:0","tags":["algorithm","C++","다익스트라"],"title":"[백준]1238 파티","uri":"/2020-03-09-1238/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-08","objectID":"/2020-03-08-1261/","tags":["algorithm","C++","다익스트라"],"title":"[백준]1261 알고스팟","uri":"/2020-03-08-1261/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1261 풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003e#include \u003calgorithm\u003eusing namespace std; int N, M, b[102][102], q, w, e, dp[102][102]; int main() { cin \u003e\u003e M \u003e\u003e N; fill(dp[0], dp[0] + 10201, 987654321); vector\u003cstring\u003e v(N); priority_queue\u003cpair\u003cint, pair\u003cint, int\u003e\u003e\u003e p; p.push({ 0,{0,0} }); dp[0][0] = 0; for (int i = 0; i \u003c N; i++) cin \u003e\u003e v[i]; while (!p.empty()) { q = p.top().second.first; w = p.top().second.second; e = p.top().first; p.pop(); if (b[q][w]) continue; b[q][w] = 1; if (w + 1 \u003c M \u0026\u0026 dp[q][w + 1] \u003e v[q][w + 1] - '0' - e) { dp[q][w + 1] = v[q][w + 1] - '0' - e; p.push({ -dp[q][w + 1], { q, w + 1 } }); } if (w \u003e 0 \u0026\u0026 dp[q][w - 1] \u003e v[q][w - 1] - '0' - e) { dp[q][w - 1] = v[q][w - 1] - '0' - e; p.push({ -dp[q][w - 1], { q, w - 1 } }); } if (q + 1 \u003c N \u0026\u0026 dp[q + 1][w] \u003e v[q + 1][w] - '0' - e) { dp[q + 1][w] = v[q + 1][w] - '0' - e; p.push({ -dp[q + 1][w], { q + 1, w } }); } if (q \u003e 0 \u0026\u0026 dp[q - 1][w] \u003e v[q - 1][w] - '0' - e) { dp[q - 1][w] = v[q - 1][w] - '0' - e; p.push({ -dp[q - 1][w], { q - 1, w } }); } } cout \u003c\u003c dp[N - 1][M - 1] \u003c\u003c endl; } ","date":"2020-03-08","objectID":"/2020-03-08-1261/:0:0","tags":["algorithm","C++","다익스트라"],"title":"[백준]1261 알고스팟","uri":"/2020-03-08-1261/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-07","objectID":"/2020-03-07-1120/","tags":["algorithm","C++","greedy","문자열","브루트 포스"],"title":"[백준]1120 문자열","uri":"/2020-03-07-1120/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1120 풀이: a 와 b의 (0번째 ~ a의 길이) 의 차이의 개수 a 와 b의 (1번째 ~ a의 길이) 의 차이의 개수 . . . a 와 b의 ()(b의 길이 - a의 길이)번째 ~ a의 길이) 의 차이의 개수 중 가장 작은것을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int c = 51; string a, b; cin \u003e\u003e a \u003e\u003e b; for (int i = 0; i \u003c= b.size() - a.size(); i++) { int d = 0; for (int t = 0; t \u003c a.size(); t++) if (a[t] != b[t + i]) d++; c = c \u003e d ? d : c; } cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-03-07","objectID":"/2020-03-07-1120/:0:0","tags":["algorithm","C++","greedy","문자열","브루트 포스"],"title":"[백준]1120 문자열","uri":"/2020-03-07-1120/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-07","objectID":"/2020-03-07-1158/","tags":["algorithm","C++"],"title":"[백준]1158 요세푸스 문제","uri":"/2020-03-07-1158/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1158 풀이: K번째 사람을 출력한다. K번째 사람을 배열에서 삭제한다. 삭제한 지점을 기준으로 K번째 사람을 출력한다. 반복한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int N, K, c; int main() { cin \u003e\u003e N \u003e\u003e K; vector\u003cint\u003e a; for (int i = 1; i \u003c= N; i++) a.push_back(i); c = K - 1; cout \u003c\u003c \"\u003c\"; while (a.size() != 1) { if (c \u003e= a.size()) c %= a.size(); cout \u003c\u003c a[c] \u003c\u003c \", \"; a.erase(a.begin() + c); c += K - 1; } cout \u003c\u003c a[0] \u003c\u003c \"\u003e\" \u003c\u003c endl; } ","date":"2020-03-07","objectID":"/2020-03-07-1158/:0:0","tags":["algorithm","C++"],"title":"[백준]1158 요세푸스 문제","uri":"/2020-03-07-1158/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-07","objectID":"/2020-03-07-1159/","tags":["algorithm","C++","문자열"],"title":"[백준]1159 농구 경기","uri":"/2020-03-07-1159/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1159 풀이: 각 선수의 성의 첫글자를 확인한다. a ~ z 까지의 배열 에서 첫글자에 해당하는 배열을 +1 해준다. a~ z 까지 확인한다. 5명 이상인 글자는 출력한다. 만약, 출력한 글자가 없다면, “PREDAJA” 를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int N, a[26], b = 0, i = 26; int main() { cin \u003e\u003e N; while(N--) { string s; cin \u003e\u003e s; a[122 - s[0]]++; } while(i--) if (a[i] \u003e 4) { b = 1; cout \u003c\u003c char(122 - i); } if (!b) cout \u003c\u003c \"PREDAJA\"; cout \u003c\u003c endl; } ","date":"2020-03-07","objectID":"/2020-03-07-1159/:0:0","tags":["algorithm","C++","문자열"],"title":"[백준]1159 농구 경기","uri":"/2020-03-07-1159/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-07","objectID":"/2020-03-07-1182/","tags":["algorithm","C++"],"title":"[백준]1182 부분수열의 합","uri":"/2020-03-07-1182/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1182 풀이: N개의 정수로 이루어진 수열을 a라고 했을 때, a의 부분수열을 모두 탐색하여 그 합이 S가 되는 갯수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int N, S, a[22], s = 0; void B(int x, int y) { if (x \u003e -1 \u0026\u0026 y == S) s++; while(++x \u003c N) B(x, y + a[x]); } int main() { cin \u003e\u003e N \u003e\u003e S; for (int i = 0; i \u003c N; i++) cin \u003e\u003e a[i]; B(-1, 0); cout \u003c\u003c s \u003c\u003c endl; } ","date":"2020-03-07","objectID":"/2020-03-07-1182/:0:0","tags":["algorithm","C++"],"title":"[백준]1182 부분수열의 합","uri":"/2020-03-07-1182/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-07","objectID":"/2020-03-07-1197/","tags":["algorithm","C++","최소 스패닝 트리"],"title":"[백준]1197 최소 스패닝 트리","uri":"/2020-03-07-1197/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1197 풀이: 배열 v를 현재 만들어진 트리에 들어있는 노드들의 집합 이라고 하자. 시작할 때 배열 v에 1 하나만 넣고 시작한다. 배열 v를 모두 순회하여 현재 트리에서 뻗어갈 수 있고, 가중치가 가장 작은 간선을 찾는다. 간선을 연결 한 후 연결된 노드를 배열 v에 저장한다. 배열 v에 모든 정점이 들어올때까지 반복한다. 트리에 모든 가중치를 더해 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003eusing namespace std; typedef pair\u003cint, int\u003e P; int N, E, q, w, e, b[10002] = { 1,1 }; vector\u003cpriority_queue\u003cP, vector\u003cP\u003e, greater\u003cP\u003e\u003e\u003e a; int main() { cin \u003e\u003e N \u003e\u003e E; a.resize(N + 1); vector\u003cint\u003e v = { 1 }; for (int i = 0; i \u003c E; i++) { cin \u003e\u003e q \u003e\u003e w \u003e\u003e e; a[q].push({ e,w }); a[w].push({ e,q }); } P p; q = 0; while (1) { p = { 1000002, 0 }; for (int i : v) { while (!a[i].empty()) { if (b[a[i].top().second]) a[i].pop(); else if (p.first \u003e a[i].top().first) p = a[i].top(); else break; } } if (p.first \u003c 1000001) { b[p.second]++; v.push_back(p.second); q += p.first; } else break; } cout \u003c\u003c q \u003c\u003c endl; } ","date":"2020-03-07","objectID":"/2020-03-07-1197/:0:0","tags":["algorithm","C++","최소 스패닝 트리"],"title":"[백준]1197 최소 스패닝 트리","uri":"/2020-03-07-1197/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-06","objectID":"/2020-03-06-1015/","tags":["algorithm","C++","정렬"],"title":"[백준]1015 수열 정렬","uri":"/2020-03-06-1015/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1015 풀이: 배열 A를 정렬한 배열을 배열 B라고 하자. 현재 위치가 i 일 때, A[i] 값이 배열 B의 어디에 위치해 있는지 찾아서 출력한다. ex) A 2 3 1 B 1 2 3 답: 1 2 0 수의 중복이 있을 수 있으므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int N, a[52], b[52], d[52], c; int main(void) { cin \u003e\u003e N; for (int i = 0; i \u003c N; i++) { cin \u003e\u003e a[i]; b[i] = a[i]; } sort(a, a + N); for (int i = 0; i \u003c N; i++) { c = lower_bound(a, a + N, b[i]) - a; while (d[c]) c++; cout \u003c\u003c c \u003c\u003c \" \"; d[c] = 1; } cout \u003c\u003c endl; } ","date":"2020-03-06","objectID":"/2020-03-06-1015/:0:0","tags":["algorithm","C++","정렬"],"title":"[백준]1015 수열 정렬","uri":"/2020-03-06-1015/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-06","objectID":"/2020-03-06-1024/","tags":["algorithm","C++","수학"],"title":"[백준]1024 수열의 합","uri":"/2020-03-06-1024/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1024 풀이: 길이가 적어도 L인 수열은 다음과 같이 나타낼 수 있다. n n + 1 n + 2 ... n + L - 2 n + L - 1 즉, 길이가 L인 수열들의 합은 L * n + Σ k (k = 1 ~ L - 1) = N ( N - Σ k (k = 1 ~ L - 1) ) % L == 0 인 L을 찾는다면, 답을 구할 수 있다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int N, L, s, a; int main() { cin \u003e\u003e N \u003e\u003e L; while (L \u003c= 100) { s = L, a = 0; while (s--) a += s; if (N \u003c a) L = 101; else if (!((N - a) % L)) break; L++; } if (L \u003c= 100) { a = (N - a) / L; while(L--) cout \u003c\u003c a++ \u003c\u003c \" \"; } else cout \u003c\u003c -1; cout \u003c\u003c endl; } ","date":"2020-03-06","objectID":"/2020-03-06-1024/:0:0","tags":["algorithm","C++","수학"],"title":"[백준]1024 수열의 합","uri":"/2020-03-06-1024/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-06","objectID":"/2020-03-06-1051/","tags":["algorithm","C++","브루트 포스"],"title":"[백준]1051 숫자 정사각형","uri":"/2020-03-06-1051/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1051 풀이: N, M 중 더 작은 값이 정사각형의 한 변의 길이의 최댓값이 된다. 최댓값을 1씩 줄여 가면서, 만들 수 있는 정사각형이 있는지 확인한다. 만들 수 있다면, 반복을 중지하고, 변을 제곱한 넓이를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int N, M, b, c = 1; int main(void) { cin \u003e\u003e N \u003e\u003e M; vector\u003cstring\u003e a(N); for (int i = 0; i \u003c N; i++) cin \u003e\u003e a[i]; b = N \u003e M ? M : N; while (c \u0026\u0026 --b) { for (int i = 0; i \u003c N - b; i++) for (int t = 0; t \u003c M - b; t++) if (a[i][t + b] == a[i][t] \u0026\u0026 a[i + b][t] == a[i][t] \u0026\u0026 a[i + b][t + b] == a[i][t]) c = 0; } cout \u003c\u003c (b + 1) * (b + 1) \u003c\u003c endl; } ","date":"2020-03-06","objectID":"/2020-03-06-1051/:0:0","tags":["algorithm","C++","브루트 포스"],"title":"[백준]1051 숫자 정사각형","uri":"/2020-03-06-1051/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-06","objectID":"/2020-03-06-1062/","tags":["algorithm","C++","문자열","브루트 포스"],"title":"[백준]1062 가르침","uri":"/2020-03-06-1062/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1062 풀이: a ~ z 중에 K개의 글자를 배웠을 떄, N개의 단어 중 몇개의 단어를 읽을 수 있는지 구한 후 그것들 중 최댓값을 출력한다. a, c, i, n, t 다섯개의 글자는 무조건 들어가므로 넣고 시작하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int N, K, b, c = 0, d, f; vector\u003cstring\u003e a; void T(int x, int y) { if (y == K) { d = 0; for (int i = 0; i \u003c N; i++) { f = 1; for (char s : a[i]) if (!((1 \u003c\u003c (s - 'a')) \u0026 b)) f = 0; if (f) d++; } c = max(c, d); } for (int i = x + 1; i \u003c 26; i++) if (!((1 \u003c\u003c i) \u0026 b)) { b |= (1 \u003c\u003c i); T(i, y + 1); b \u0026= ~(1 \u003c\u003c i); } } int main() { cin \u003e\u003e N \u003e\u003e K; a.resize(N); for (int i = 0; i \u003c N; i++) cin \u003e\u003e a[i]; b |= ((1 \u003c\u003c 0) + (1 \u003c\u003c 2) + (1 \u003c\u003c 13) + (1 \u003c\u003c 8) + (1 \u003c\u003c 19)); T(0, 5); cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-03-06","objectID":"/2020-03-06-1062/:0:0","tags":["algorithm","C++","문자열","브루트 포스"],"title":"[백준]1062 가르침","uri":"/2020-03-06-1062/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-06","objectID":"/2020-03-06-1080/","tags":["algorithm","C++","greedy"],"title":"[백준]1080 행렬","uri":"/2020-03-06-1080/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1080 풀이: (0, 0) 부터 하나씩 비교해 나간다. 만약 A 와 B 의 숫자가 다르다면, 현재 위치부터 3 * 3 전체를 반전시킨다. 반전 시켰다면, 뒤집은 횟수를 +1 해준다. 순환이 끝난 후 행렬 A 와 B 가 다르다면 -1을 같다면 뒤집은 횟수를 출력해준다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int N, M, c = 0, i, t, u, y; int main() { cin \u003e\u003e N \u003e\u003e M; vector\u003cstring\u003e a(N), b(N); for (i = 0; i \u003c N; i++) cin \u003e\u003e a[i]; for (i = 0; i \u003c N; i++) cin \u003e\u003e b[i]; for (i = 0; i \u003c N - 2; i++) for (t = 0; t \u003c M - 2; t++) if (a[i][t] != b[i][t]) { c++; for (y = 0; y \u003c 3; y++) for (u = 0; u \u003c 3; u++) a[i + y][t + u] = '1' - a[i + y][t + u] + '0'; } for (i = 0; i \u003c N; i++) if (a[i] != b[i]) c = -1; cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-03-06","objectID":"/2020-03-06-1080/:0:0","tags":["algorithm","C++","greedy"],"title":"[백준]1080 행렬","uri":"/2020-03-06-1080/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-05","objectID":"/2020-03-05-1005/","tags":["algorithm","C++","위상정렬"],"title":"[백준]1005 ACM Craft","uri":"/2020-03-05-1005/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1005 풀이: b[i] : i 건물을 짓는데 드는 최소시간 b[i] = max(b[i 건물을 짓는데 필요한 건물들]) -\u003e 바로 전 단계의 건물 중 건설시간이 오래 걸리는 것을 짓는다면, 그 시간동안 다른 건물은 다 지을 수 있기 떄문에, max값만 생각한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int T, N, K, q, e, w, a[1002], m, n, b[1002]; vector\u003cvector\u003cint\u003e\u003e v; int A(int x) { if (b[x] != -1) return b[x]; b[x] = 0; for (int i : v[x]) b[x] = max(b[x], A(i)); b[x] += a[x]; return b[x]; } int main(void) { cin \u003e\u003e T; while (T--) { cin \u003e\u003e N \u003e\u003e K; fill(b, b + N + 1, -1); v.clear(); v.resize(N + 1); for (int i = 1; i \u003c= N; i++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c K; i++) { cin \u003e\u003e q \u003e\u003e e; v[e].push_back(q); } cin \u003e\u003e w; cout \u003c\u003c A(w) \u003c\u003c endl; } } ","date":"2020-03-05","objectID":"/2020-03-05-1005/:0:0","tags":["algorithm","C++","위상정렬"],"title":"[백준]1005 ACM Craft","uri":"/2020-03-05-1005/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-05","objectID":"/2020-03-05-1049/","tags":["algorithm","C++","greedy"],"title":"[백준]1049 기타줄","uri":"/2020-03-05-1049/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1049 풀이: 여러 브랜드 중 6줄 패키지 가격의 최솟값과 낱개 가격의 최솟값을 저장해 놓는다. 낱개 * 6 보다 패키지 가격이 더 높다면, 패키지로 살 이유가 없으므로 낱개 가격을 출력한다. 필요한 줄의 갯수가 6개 이하라면, 낱개 가격과 패키지 가격 중 낮은 가격을 출력한다. 둘 다 아니라면, (전체를 패키지로 사는 것) 과 (6개로 나눠지는 만큼 패키지로 사고 나머지는 낱개로 사는 것) 둘 중 낮은 가격을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int N, M, q, w, a = 1001, b = 1001, dp[102] = { 0 }; int main(void) { cin \u003e\u003e N \u003e\u003e M; for (int i = 0; i \u003c M; i++) { cin \u003e\u003e q \u003e\u003e w; a = min(a, q); b = min(b, w); } for (int i = 1; i \u003c= N; i++) { dp[i] = (((i - 1) / 6) + 1) * a; dp[i] = min(dp[i], dp[i - 1] + b); } cout \u003c\u003c dp[N] \u003c\u003c endl; } 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int N, M, q, w, a = 1001, b = 1001; int main(void) { cin \u003e\u003e N \u003e\u003e M; for (int i = 0; i \u003c M; i++) { cin \u003e\u003e q \u003e\u003e w; a = min(a, q); b = min(b, w); } if (N \u003c= 6) cout \u003c\u003c min(a, b * N) \u003c\u003c endl; else if (b * 6 \u003c a) cout \u003c\u003c b * N \u003c\u003c endl; else cout \u003c\u003c min((((N - 1) / 6) + 1) * a, (N / 6) * a + (N % 6) * b) \u003c\u003c endl; } ","date":"2020-03-05","objectID":"/2020-03-05-1049/:0:0","tags":["algorithm","C++","greedy"],"title":"[백준]1049 기타줄","uri":"/2020-03-05-1049/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-05","objectID":"/2020-03-05-1068/","tags":["algorithm","C++","트리"],"title":"[백준]1068 트리","uri":"/2020-03-05-1068/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1068 풀이: v[i] : i의 자식 노드들이 들어있다. 삭제 해야하는 노드가 w 라면, w를 큐에 푸쉬한다. w의 자식노드를 큐에 푸쉬한 후 w를 삭제한다. 자식노드가 없어질 때까지 반복한다. v[ 0 ~ N - 1 ] 까지 모두 순환한다. 노드가 현제 존재하며, 자식노드가 없다면, 리프 노드이므로 +1 해준다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003eusing namespace std; int N, a; bool b[52], c; int main(void) { cin \u003e\u003e N; vector\u003cvector\u003cint\u003e\u003e v(N); queue\u003cint\u003e q; for (int i = 0; i \u003c N; i++) { cin \u003e\u003e a; if(a != -1) v[a].push_back(i); } cin \u003e\u003e a; q.push(a); while (!q.empty()) { b[q.front()] = true; for (int i : v[q.front()]) q.push(i); q.pop(); } a = 0; for (int i = 0; i \u003c N; i++) { if (b[i]) continue; c = true; for (int t : v[i]) if (!b[t]) c = false; if (c) a++; } cout \u003c\u003c a \u003c\u003c endl; } ","date":"2020-03-05","objectID":"/2020-03-05-1068/:0:0","tags":["algorithm","C++","트리"],"title":"[백준]1068 트리","uri":"/2020-03-05-1068/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-04","objectID":"/2020-03-04-1057/","tags":["algorithm","C++","수학"],"title":"[백준]1057 토너먼트","uri":"/2020-03-04-1057/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1057 풀이: ​ 1 2 ​ 1 2 3 4 1 2 3 4 5 6 7 8 현재 번호가 i 라고 할 때, 위로 갈 수록 배정받는 번호는 (i + 1) / 2 가 된다. 즉, 김지민과 임한수의 번호가 x, y 라고 할 때, ( x + 1 ) / 2 == ( y + 1 ) / 2 가 되는 순간이 둘이 대결하는 순간이다. 토너먼트가 끝날 때까지 둘이 대결하지 않는 경우는 없으므로 -1 출력은 하지않는다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, a, b, c = 0; int main() { cin \u003e\u003e n \u003e\u003e a \u003e\u003e b; a--; b--; while (a != b) { a /= 2; b /= 2; c++; } cout \u003c\u003c c \u003c\u003c endl; } ","date":"2020-03-04","objectID":"/2020-03-04-1057/:0:0","tags":["algorithm","C++","수학"],"title":"[백준]1057 토너먼트","uri":"/2020-03-04-1057/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-04","objectID":"/2020-03-04-1074/","tags":["algorithm","C++","수학"],"title":"[백준]1074 집합","uri":"/2020-03-04-1074/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1074 풀이: 배열의 크기를 점차 줄여가면서, 위에 방문할 수 있는 배열의 크기를 계산하여, 더해가면서 구한다. ex) 3 7 7 8 * 8 배열에서 왼쪽위, 오른쪽 위, 왼쪽 아래 4 * 4 배열은 필요없으니까 48 만큼 뺀 후, 오른쪽 아래 배열로만 4 * 4 배열로 줄여서 다시 만든다. 그렇다면, ( 7, 7 ) 은 ( 3, 3 )이 되어야 하므로 (7 % 4, 7 % 4) 가 된다. 배열의 크기가 0이 될때까지 반복한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, r, c, a = 0; int main() { cin \u003e\u003e n \u003e\u003e r \u003e\u003e c; n = (1 \u003c\u003c (n - 1)); while (n) { a += r / n * n * n * 2 + c / n * n * n; r %= n; c %= n; n /= 2; } cout \u003c\u003c a \u003c\u003c endl; } ","date":"2020-03-04","objectID":"/2020-03-04-1074/:0:0","tags":["algorithm","C++","수학"],"title":"[백준]1074 집합","uri":"/2020-03-04-1074/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-04","objectID":"/2020-03-04-11723/","tags":["algorithm","C++","비트마스크"],"title":"[백준]11723 집합","uri":"/2020-03-04-11723/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11723 풀이: [C++]비트연산자 참고 add : or 연산을 통해 값을 추가한다. remove : 값이 있는지 확인 후 있다면, xor 연산으로 삭제한다. check : 값이 있는지 and 연산으로 확인 후 있다면 1, 없다면 0을 출력한다. toggle : 값이 있다면 삭제하고, 없다면 추가한다. all : 비트값을 (2^20) - 1 로 바꿔주어, 1 ~ 20 까지 채워놓는다. empty : 비트값을 0으로 바꿔주어, 공집합으로 만들어놓는다. 시간제한이있으므로 비트마스크를 통해 연산하도록한다. cin, cout 을 사용할 경우 시간초과가 나므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring.h\u003eusing namespace std; int M, n, a = 0; char s[7]; int main() { scanf(\"%d\", \u0026M); while (M--) { scanf(\"%s\", \u0026s); if (!strcmp(s, \"all\")) a |= 0x1FFFFF; else if (!strcmp(s, \"empty\")) a \u0026= 0; else { scanf(\"%d\", \u0026n); n--; if (!strcmp(s, \"add\")) a |= (1 \u003c\u003c n); else if (!strcmp(s, \"remove\") \u0026\u0026 a \u0026 (1 \u003c\u003c n)) a ^= (1 \u003c\u003c n); else if (!strcmp(s, \"check\")) if (a \u0026 (1 \u003c\u003c n)) printf(\"1\\n\"); else printf(\"0\\n\"); else if (!strcmp(s, \"toggle\")) if (a \u0026 (1 \u003c\u003c n)) a ^= (1 \u003c\u003c n); else a |= (1 \u003c\u003c n); } } } ","date":"2020-03-04","objectID":"/2020-03-04-11723/:0:0","tags":["algorithm","C++","비트마스크"],"title":"[백준]11723 집합","uri":"/2020-03-04-11723/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-03-04","objectID":"/2020-03-04-listofmatches/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]예상 대진표","uri":"/2020-03-04-listofmatches/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: △△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, … , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다. 이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다. 풀이: [백준]1057 토너먼트 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e using namespace std; int solution(int n, int a, int b) { int answer = 0; a--; b--; while (a != b) { a /= 2; b /= 2; answer++; } return answer; } ","date":"2020-03-04","objectID":"/2020-03-04-listofmatches/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]예상 대진표","uri":"/2020-03-04-listofmatches/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-03","objectID":"/2020-03-03-11404/","tags":["algorithm","C++","최단 경로"],"title":"[백준]11404 웜홀","uri":"/2020-03-03-11404/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11404 풀이: [C++]플로이드-와샬 알고리즘(Bellman-Ford Algorithm) 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m, i, a1, a2, a3, a[102][102]; int main() { cin \u003e\u003e n \u003e\u003e m; fill(a[0], a[0] + 10404, 987654321); for (i = 0; i \u003c m; i++) { cin \u003e\u003e a1 \u003e\u003e a2 \u003e\u003e a3; a[a1][a2] = min(a[a1][a2], a3); } for (i = 1; i \u003c= n; i++) for (int t = 1; t \u003c= n; t++) for (int y = 1; y \u003c= n; y++) if (t == y) a[t][y] = 0; else a[t][y] = min(a[t][y], a[t][i] + a[i][y]); for (i = 1; i \u003c= n; i++) { for (int t = 1; t \u003c= n; t++) if (a[i][t] == 987654321) cout \u003c\u003c \"0 \"; else cout \u003c\u003c a[i][t] \u003c\u003c \" \"; cout \u003c\u003c endl; } } ","date":"2020-03-03","objectID":"/2020-03-03-11404/:0:0","tags":["algorithm","C++","최단 경로"],"title":"[백준]11404 웜홀","uri":"/2020-03-03-11404/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-03","objectID":"/2020-03-03-1865/","tags":["algorithm","C++","최단 경로"],"title":"[백준]1865 웜홀","uri":"/2020-03-03-1865/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1865 풀이: [C++]벨만-포드 알고리즘(Bellman-Ford Algorithm) 참고 벨만-포드 알고리즘으로 모든 정점을 순환 한 뒤, 음수 사이클이 있는지 판단 후 있다면, “YES” 를 없다면 “NO\"를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int T, n, m, k, i, d[502], a1, a2, a3; int main() { cin \u003e\u003e T; while (T--) { bool b = true; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; vector\u003cpair\u003cpair\u003cint, int\u003e, int\u003e\u003e a; for (i = 0; i \u003c m; i++) { cin \u003e\u003e a1 \u003e\u003e a2 \u003e\u003e a3; a.push_back({ {a1,a2},a3 }); a.push_back({ {a2,a1},a3 }); } for (i = 0; i \u003c k; i++) { cin \u003e\u003e a1 \u003e\u003e a2 \u003e\u003e a3; a.push_back({ {a1,a2},-a3 }); } fill(d, d + n + 1, 987654321); for (i = 1; i \u003c= n; i++) for (auto t : a) if (d[t.first.second] \u003e d[t.first.first] + t.second) { d[t.first.second] = d[t.first.first] + t.second; if (i == n) b = false; } if (b) cout \u003c\u003c \"NO\" \u003c\u003c endl; else cout \u003c\u003c \"YES\" \u003c\u003c endl; } } ","date":"2020-03-03","objectID":"/2020-03-03-1865/:0:0","tags":["algorithm","C++","최단 경로"],"title":"[백준]1865 웜홀","uri":"/2020-03-03-1865/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-02","objectID":"/2020-03-02-11657/","tags":["algorithm","C++","최단 경로"],"title":"[백준]11657 타임머신","uri":"/2020-03-02-11657/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11657 풀이: [C++]벨만-포드 알고리즘(Bellman-Ford Algorithm) 참고 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; #define INF 987654321 int n, m, i, d[502], a1, a2, a3; pair\u003cpair\u003cint, int\u003e, int\u003e a[6002]; int main() { cin \u003e\u003e n \u003e\u003e m; for (i = 0; i \u003c m; i++) cin \u003e\u003e a[i].first.first \u003e\u003e a[i].first.second \u003e\u003e a[i].second; fill(d, d + n + 1, INF); d[1] = 0; for (i = 1; i \u003c= n; i++) for (auto t : a) if (d[t.first.first] != INF \u0026\u0026 d[t.first.second] \u003e d[t.first.first] + t.second) { d[t.first.second] = d[t.first.first] + t.second; if (i == n) { cout \u003c\u003c -1 \u003c\u003c endl; return 0; } } for (i = 2; i \u003c= n; i++) if (d[i] == INF) cout \u003c\u003c -1 \u003c\u003c endl; else cout \u003c\u003c d[i] \u003c\u003c endl; } ","date":"2020-03-02","objectID":"/2020-03-02-11657/:0:0","tags":["algorithm","C++","최단 경로"],"title":"[백준]11657 타임머신","uri":"/2020-03-02-11657/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-02","objectID":"/2020-03-02-9370/","tags":["algorithm","C++","최단 경로"],"title":"[백준]9370 미확인 도착지","uri":"/2020-03-02-9370/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9370 풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고 s -\u003e g -\u003e h -\u003e x s -\u003e h -\u003e g -\u003e x 두 가지 경로가 있는데, 둘 중 하나라도 최단 경로일 경우 x를 배열에 저장한다. 저장된 x를 오름차순으로 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int T, n, m, t, u, v, w, i, s, g, h, v1, v2, a1, c, d[2002]; bool b[2002]; priority_queue\u003cpair\u003cint, int\u003e\u003e p; priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q; int main() { cin \u003e\u003e T; while (T--) { cin \u003e\u003e n \u003e\u003e m \u003e\u003e t; vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003e a(n + 1); cin \u003e\u003e s \u003e\u003e g \u003e\u003e h; for (i = 0; i \u003c m; i++) { cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; a[u].push_back({ v,w }); a[v].push_back({ u,w }); if ((u == g \u0026\u0026 v == h) || (u == h \u0026\u0026 v == g)) a1 = w; } fill(d, d + n + 1, 3000000); fill(b, b + n + 1, 0); d[s] = 0; p.push({ 0, s }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = true; for (auto t : a[w]) { u = t.first, v = t.second; if (d[u] \u003e d[w] + v) { d[u] = d[w] + v; p.push({ -d[u], u }); } } } v1 = d[g] + a1; v2 = d[h] + a1; for (i = 0; i \u003c t; i++) { cin \u003e\u003e c; fill(d, d + n + 1, 3000000); fill(b, b + n + 1, 0); d[c] = 0; p.push({ 0, c }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = true; for (auto t : a[w]) { u = t.first, v = t.second; if (d[u] \u003e d[w] + v) { d[u] = d[w] + v; p.push({ -d[u], u }); } } } if (v1 + d[h] == d[s] || v2 + d[g] == d[s]) q.push(c); } while (!q.empty()) { cout \u003c\u003c q.top() \u003c\u003c \" \"; q.pop(); } cout \u003c\u003c endl; } } ","date":"2020-03-02","objectID":"/2020-03-02-9370/:0:0","tags":["algorithm","C++","최단 경로"],"title":"[백준]9370 미확인 도착지","uri":"/2020-03-02-9370/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-01","objectID":"/2020-03-01-1504/","tags":["algorithm","C++","최단 경로"],"title":"[백준]1504 최단 경로","uri":"/2020-03-01-1504/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1504 풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고 지나야 하는 두 개의 정점을 v1, v2 라고 할때, 1 ~ v1 ~ v2 ~ N 1 ~ v2 ~ v1 ~ N 으로 나눠서 풀어본다. 1~v1, v2 과 v1 ~ v2 과 v1, v2 ~ N 을 다익스트라 알고리즘으로 각각 구하여 더한값이 최소인 값을 구한다. 만약 경로가 없다면 -1을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int V, E, u, v, w, i, d[805], v1, v2, a1, a2; priority_queue\u003cpair\u003cint, int\u003e\u003e p; bool b[805]; int main() { cin \u003e\u003e V \u003e\u003e E; vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003ea(V + 1); for (i = 0; i \u003c E; i++) { cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; a[u].push_back({ v,w }); a[v].push_back({ u,w }); } cin \u003e\u003e v1 \u003e\u003e v2; fill(d, d + V + 1, 8000000); d[1] = 0; p.push({ 0, 1 }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = true; for (auto t : a[w]) { u = t.first, v = t.second; if (d[u] \u003e d[w] + v) { d[u] = d[w] + v; p.push({ -d[u], u }); } } } a1 = d[v1]; a2 = d[v2]; fill(d, d + V + 1, 8000000); fill(b, b + V + 1, 0); d[v1] = 0; p.push({ 0, v1 }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = true; for (auto t : a[w]) { u = t.first, v = t.second; if (d[u] \u003e d[w] + v) { d[u] = d[w] + v; p.push({ -d[u], u }); } } } a1 += d[v2]; a2 += d[v2]; fill(d, d + V + 1, 8000000); fill(b, b + V + 1, 0); d[V] = 0; p.push({ 0, V }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = true; for (auto t : a[w]) { u = t.first, v = t.second; if (d[u] \u003e d[w] + v) { d[u] = d[w] + v; p.push({ -d[u], u }); } } } a1 += d[v2]; a2 += d[v1]; a1 = a1 \u003e a2 ? a2 : a1; if (a1 \u003e= 8000000) cout \u003c\u003c -1 \u003c\u003c endl; else cout \u003c\u003c a1 \u003c\u003c endl; } ","date":"2020-03-01","objectID":"/2020-03-01-1504/:0:0","tags":["algorithm","C++","최단 경로"],"title":"[백준]1504 최단 경로","uri":"/2020-03-01-1504/"},{"categories":["백준"],"content":"algorithm","date":"2020-03-01","objectID":"/2020-03-01-1753/","tags":["algorithm","C++","최단 경로"],"title":"[백준]1753 최단 경로","uri":"/2020-03-01-1753/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1753 풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int V, E, k, u, v, w, i; vector\u003cint\u003e d; priority_queue\u003cpair\u003cint, int\u003e\u003e p; bool b[20002]; int main() { cin \u003e\u003e V \u003e\u003e E \u003e\u003e k; vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003ea(V + 1); for (i = 0; i \u003c= V; i++) d.push_back(987654321); for (i = 0; i \u003c E; i++) { cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; a[u].push_back({ v,w }); } d[k] = 0; p.push({ 0, k }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = true; for (auto t : a[w]) { u = t.first, v = t.second; if (d[u] \u003e d[w] + v) { d[u] = d[w] + v; p.push({ d[u], u }); } } } for (i = 1; i \u003c= V; i++) if (d[i] \u003e= 987654321) cout \u003c\u003c \"INF\" \u003c\u003c endl; else cout \u003c\u003c d[i] \u003c\u003c endl; } ","date":"2020-03-01","objectID":"/2020-03-01-1753/:0:0","tags":["algorithm","C++","최단 경로"],"title":"[백준]1753 최단 경로","uri":"/2020-03-01-1753/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-03-01","objectID":"/2020-03-01-furthestnode/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]가장 먼 노드","uri":"/2020-03-01-furthestnode/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다. 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요. 풀이: 현재 위치를 i 라고 하자. 이때까지 방문을 한적이 없고, i와의 거리가 1차이나는 노드를 배열에 저장한 후 visit을 true로 바꿔준다. 반복도중 배열이 비었다면, 반복을 중지하고, 그 전 배열의 사이즈를 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int n, vector\u003cvector\u003cint\u003e\u003e edge) { int answer = 0; vector\u003cvector\u003cint\u003e\u003e a(n + 1), c; vector\u003cbool\u003e b(n + 1); for (auto i : edge) { a[i[0]].push_back(i[1]); a[i[1]].push_back(i[0]); } c.push_back({ 1 }); b[1] = true; while (1) { vector\u003cint\u003e v; for (auto i : c.back()) for (auto t : a[i]) if (!b[t]) { v.push_back(t); b[t] = true; } if(v.empty()) break; c.push_back(v); } return c.back().size(); } ","date":"2020-03-01","objectID":"/2020-03-01-furthestnode/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]가장 먼 노드","uri":"/2020-03-01-furthestnode/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-29","objectID":"/2020-02-29-1697/","tags":["algorithm","C++","BFS"],"title":"[백준]1697 숨바꼭질","uri":"/2020-02-29-1697/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1697 풀이: 현재 위치를 x라고 할 때, x + 1, x - 1, x * 2 위치를 BFS 를 통해 하나씩 찾아간다. 동생의 위치와 같아진다면 몇번 이동했는지 출력한다. x + 1 은 동생의 위치보다 커질 필요가없으므로 동생의 위치보다 작을때만 이동한다. x * 2 는 동생의 위치 + 1 보다 크다면 (x - 2) * 2 를 하는 것이 이득이므로 제외한다. 현재 위치는 0보다 작아질 수 없으므로 제외한다. 이미 한번 방문한 위치는 다시 방문할 필요없으므로 제외시킨다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int n, m, k, i = 1, q = 0, dps; bool a[100005]; queue\u003cint\u003e dp; int main() { cin \u003e\u003e n \u003e\u003e k; dp.push(n); a[n] = true; while (!q) { dps = dp.size(); while (dps--) { m = dp.front(); if (m == k) { q = i; break; } if (m \u003e 0 \u0026\u0026 !a[m - 1]) { dp.push(m - 1); a[m - 1] = true; } if (m \u003c= k \u0026\u0026 !a[m + 1]) { dp.push(m + 1); a[m + 1] = true; } if (m + m \u003c k + 2 \u0026\u0026 !a[m + m]) { dp.push(m + m); a[m + m] = true; } dp.pop(); } i++; } cout \u003c\u003c q - 1 \u003c\u003c endl; } ","date":"2020-02-29","objectID":"/2020-02-29-1697/:0:0","tags":["algorithm","C++","BFS"],"title":"[백준]1697 숨바꼭질","uri":"/2020-02-29-1697/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-29","objectID":"/2020-02-29-2206/","tags":["algorithm","C++","BFS"],"title":"[백준]2206 벽 부수고 이동하기","uri":"/2020-02-29-2206/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2206 풀이: [백준]2178 미로 탐색 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int n, m, k = -1, q, w, e, dps; vector\u003cstring\u003e a; queue\u003cpair\u003cint, pair\u003cint, int\u003e\u003e\u003e dp; bool b[2][1002][1002]; int main() { cin \u003e\u003e n \u003e\u003e m; a.resize(n); for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; dp.push({ 1, { 0,0 } }); for (int i = 1; i \u003c n * m + 1; i++) { dps = dp.size(); while (dps--) { q = dp.front().first; w = dp.front().second.first; e = dp.front().second.second; if (w == n - 1 \u0026\u0026 e == m - 1) { k = i; i = n * m + 1; break; } b[q][w][e] = true; if (e + 1 \u003c m \u0026\u0026 a[w][e + 1] == '0' \u0026\u0026 !b[q][w][e + 1]) { dp.push({ q,{w, e + 1 } }); b[q][w][e + 1] = true; } if (w + 1 \u003c n \u0026\u0026 a[w + 1][e] == '0' \u0026\u0026 !b[q][w + 1][e]) { dp.push({ q,{w + 1, e } }); b[q][w + 1][e] = true; } if (w \u003e= 1 \u0026\u0026 a[w - 1][e] == '0' \u0026\u0026 !b[q][w - 1][e]) { dp.push({ q,{w - 1, e} }); b[q][w - 1][e] = true; } if (e \u003e= 1 \u0026\u0026 a[w][e - 1] == '0' \u0026\u0026 !b[q][w][e - 1]) { dp.push({ q,{w,e - 1 } }); b[q][w][e - 1] = true; } if (q) { if (e + 1 \u003c m \u0026\u0026 a[w][e + 1] == '1' \u0026\u0026 !b[q - 1][w][e + 1]) { dp.push({ q - 1,{w, e + 1 } }); b[q - 1][w][e + 1] = true; } if (w + 1 \u003c n \u0026\u0026 a[w + 1][e] == '1' \u0026\u0026 !b[q - 1][w + 1][e]) { dp.push({ q - 1,{w + 1, e } }); b[q - 1][w + 1][e] = true; } if (w \u003e= 1 \u0026\u0026 a[w - 1][e] == '1' \u0026\u0026 !b[q - 1][w - 1][e]) { dp.push({ q - 1,{w - 1, e} }); b[q - 1][w - 1][e] = true; } if (e \u003e= 1 \u0026\u0026 a[w][e - 1] == '1' \u0026\u0026 !b[q - 1][w][e - 1]) { dp.push({ q - 1,{w,e - 1 } }); b[q - 1][w][e - 1] = true; } } dp.pop(); } } cout \u003c\u003c k \u003c\u003c endl; } ","date":"2020-02-29","objectID":"/2020-02-29-2206/:0:0","tags":["algorithm","C++","BFS"],"title":"[백준]2206 벽 부수고 이동하기","uri":"/2020-02-29-2206/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-29","objectID":"/2020-02-29-7569/","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]7569 토마토","uri":"/2020-02-29-7569/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/7569 풀이: [백준]7576 토마토 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int n, m, h, k, q, w, e, a[102][102][102]; queue\u003cpair\u003cint, pair\u003cint, int\u003e\u003e\u003e dp2; int main() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e h; for (int y = 0; y \u003c h; y++) for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c m; t++) { cin \u003e\u003e a[y][i][t]; if (a[y][i][t] == 1) dp2.push({ y, {i,t} }); } for (int i = 0;; i++) { queue\u003cpair\u003cint, pair\u003cint, int\u003e\u003e\u003e dp1; while (!dp2.empty()) { q = dp2.front().first; w = dp2.front().second.first; e = dp2.front().second.second; if (w + 1 \u003c n \u0026\u0026 !a[q][w + 1][e]) { dp1.push({ q,{w + 1, e} }); a[q][w + 1][e]++; } if (q + 1 \u003c h \u0026\u0026 !a[q + 1][w][e]) { dp1.push({ q + 1,{w, e} }); a[q + 1][w][e]++; } if (w \u003e= 1 \u0026\u0026 !a[q][w - 1][e]) { dp1.push({ q,{w - 1, e} }); a[q][w - 1][e]++; } if (q \u003e= 1 \u0026\u0026 !a[q - 1][w][e]) { dp1.push({ q - 1,{w, e} }); a[q - 1][w][e]++; } if (e + 1 \u003c m \u0026\u0026 !a[q][w][e + 1]) { dp1.push({ q,{w, e + 1} }); a[q][w][e + 1]++; } if (e \u003e= 1 \u0026\u0026 !a[q][w][e - 1]) { dp1.push({ q,{w, e - 1} }); a[q][w][e - 1]++; } dp2.pop(); } if (dp1.empty()) { k = i; break; } dp2 = dp1; } for (int y = 0; y \u003c h; y++) for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c m; t++) if (!a[y][i][t]) { k = -1; break; } cout \u003c\u003c k \u003c\u003c endl; } ","date":"2020-02-29","objectID":"/2020-02-29-7569/:0:0","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]7569 토마토","uri":"/2020-02-29-7569/"},{"categories":["Learn"],"content":"learn","date":"2020-02-28","objectID":"/2020-02-28-bitoperator/","tags":["Learn","C++","비트마스크"],"title":"[C++]비트연산자","uri":"/2020-02-28-bitoperator/"},{"categories":["Learn"],"content":"비트연산자 비트연산자 DP문제를 푸는데 있어, 연산속도를 빠르게 하기 위해 사용 « , » 시프트 연산자. 비트의 자리를 옮겨줌 ex) 1 « 3 1000 NOT - ( ~ ) 0 은 1로 1은 0으로 반대로 바꿔준다. ex) 0000000 1111111 AND - ( \u0026 ) 둘 다 1 일때만 1, 아니면 0 ex) 1100110 \u0026 1011001 1000110 OR - ( | ) 둘 중 하나라도 1이라면 1, 아니면 0 ex) 1100110 | 1010110 1110110 XOR - ( ^ ) 같으면 0, 다르면 1 ex) 1100110 ^ 1011010 0111100 ","date":"2020-02-28","objectID":"/2020-02-28-bitoperator/:0:0","tags":["Learn","C++","비트마스크"],"title":"[C++]비트연산자","uri":"/2020-02-28-bitoperator/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-28","objectID":"/2020-02-28-1012/","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]1012 유기농 배추","uri":"/2020-02-28-1012/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1012 풀이: [백준]2667 단지번호붙이기 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring.h\u003eusing namespace std; int n, T, m, k, q, w, sum, a[52][52]; bool b[52][52]; void num(int x, int y) { b[x][y] = true; if (x + 1 \u003c n \u0026\u0026 a[x + 1][y] \u0026\u0026 !b[x + 1][y]) num(x + 1, y); if (y + 1 \u003c m \u0026\u0026 a[x][y + 1] \u0026\u0026 !b[x][y + 1]) num(x, y + 1); if (x - 1 \u003e= 0 \u0026\u0026 a[x - 1][y] \u0026\u0026 !b[x - 1][y]) num(x - 1, y); if (y - 1 \u003e= 0 \u0026\u0026 a[x][y - 1] \u0026\u0026 !b[x][y - 1]) num(x, y - 1); } int main() { cin \u003e\u003e T; while (T--) { sum = 0; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); cin \u003e\u003e m \u003e\u003e n \u003e\u003e k; while (k--) { cin \u003e\u003e q \u003e\u003e w; a[w][q] = 1; } for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c m; t++) if (a[i][t] \u0026\u0026 !b[i][t]) { sum++; num(i, t); } cout \u003c\u003c sum \u003c\u003c endl; } } ","date":"2020-02-28","objectID":"/2020-02-28-1012/:0:0","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]1012 유기농 배추","uri":"/2020-02-28-1012/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-28","objectID":"/2020-02-28-2178/","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]2178 미로 탐색","uri":"/2020-02-28-2178/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2178 풀이: 이동횟수가 i 일때, 이동횟수가 i - 1 인 값들에서 왼쪽, 오른쪽, 위, 아래 중 값이 1이고, 방문한적 없는 곳을 찾아 좌표를 큐에 넣는다. 만약 현재 좌표가 도착위치라면, 이동횟수 i를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int n, m, k, q, w; vector\u003cstring\u003e a; queue\u003cpair\u003cint, int\u003e\u003e dp2; bool b[102][102]; int main() { cin \u003e\u003e n \u003e\u003e m; a.resize(n); for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; dp2.push({ 0,0 }); for (int i = 1; i \u003c n * m + 1; i++) { queue\u003cpair\u003cint, int\u003e\u003e dp1; while (!dp2.empty()) { q = dp2.front().first; w = dp2.front().second; if (q == n - 1 \u0026\u0026 w == m - 1) { k = i; i = n * m + 1; break; } b[q][w] = true; if (w + 1 \u003c m \u0026\u0026 a[q][w + 1] == '1' \u0026\u0026 !b[q][w + 1]) { dp1.push({ q,w + 1 }); b[q][w + 1] = true; } if (q + 1 \u003c n \u0026\u0026 a[q + 1][w] == '1' \u0026\u0026 !b[q + 1][w]) { dp1.push({ q + 1,w }); b[q + 1][w] = true; } if (w \u003e= 1 \u0026\u0026 a[q][w - 1] == '1' \u0026\u0026 !b[q][w - 1]) { dp1.push({ q,w - 1 }); b[q][w - 1] = true; } if (q \u003e= 1 \u0026\u0026 a[q - 1][w] == '1' \u0026\u0026 !b[q - 1][w]) { dp1.push({ q - 1,w }); b[q - 1][w] = true; } dp2.pop(); } dp2 = dp1; } cout \u003c\u003c k \u003c\u003c endl; } ","date":"2020-02-28","objectID":"/2020-02-28-2178/:0:0","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]2178 미로 탐색","uri":"/2020-02-28-2178/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-28","objectID":"/2020-02-28-7576/","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]7576 토마토","uri":"/2020-02-28-7576/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/7576 풀이: [백준]2178 미로 탐색 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int n, m, k, q, w, a[1002][1002]; queue\u003cpair\u003cint, int\u003e\u003e dp2; int main() { cin \u003e\u003e m \u003e\u003e n; for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c m; t++) { cin \u003e\u003e a[i][t]; if (a[i][t] == 1) dp2.push({ i,t }); } for (int i = 0;; i++) { queue\u003cpair\u003cint, int\u003e\u003e dp1; while (!dp2.empty()) { q = dp2.front().first; w = dp2.front().second; if (w + 1 \u003c m \u0026\u0026 !a[q][w + 1]) { dp1.push({ q,w + 1 }); a[q][w + 1]++; } if (q + 1 \u003c n \u0026\u0026 !a[q + 1][w]) { dp1.push({ q + 1,w }); a[q + 1][w]++; } if (w \u003e= 1 \u0026\u0026 !a[q][w - 1]) { dp1.push({ q,w - 1 }); a[q][w - 1]++; } if (q \u003e= 1 \u0026\u0026 !a[q - 1][w]) { dp1.push({ q - 1,w }); a[q - 1][w]++; } dp2.pop(); } if (dp1.empty()) { k = i; break; } dp2 = dp1; } for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c m; t++) if (!a[i][t]) { k = -1; break; } cout \u003c\u003c k \u003c\u003c endl; } ","date":"2020-02-28","objectID":"/2020-02-28-7576/:0:0","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]7576 토마토","uri":"/2020-02-28-7576/"},{"categories":["Learn"],"content":"learn","date":"2020-02-27","objectID":"/2020-02-27-floydwarshall/","tags":["Learn","C++","최단 경로"],"title":"[C++]플로이드-와샬 알고리즘(Floyd-Warshall Algorithm)","uri":"/2020-02-27-floydwarshall/"},{"categories":["Learn"],"content":"플로이드-와샬 알고리즘(Floyd-Warshall Algorithm) 플로이드-와샬 알고리즘(Floyd-Warshall Algorithm) 한번의 실행으로 “모든 노드” 간 최단 경로를 구하는 알고리즘. 시간복잡도 $$ O(n^3) $$ 위 그림의 초기값은 다음과 같다. 0 5 ∞ 9 1 5 0 2 ∞ ∞ ∞ 2 0 7 ∞ 9 ∞ 7 0 2 1 ∞ ∞ 2 0 이때, 1 번 노드를 중간 노드로 한다면, 2 - 1 - 4 로 가는 길이 14 짜리 경로를 만들 수 있고, 2 - 1 - 5 로 가는 길이 6 짜리 경로를 만들 수 있다. 0 5 ∞ 9 1 5 0 2 14 6 ∞ 2 0 7 ∞ 9 14 7 0 2 1 6 ∞ 2 0 위와 같은 방식으로 모든 노드가 중간노드로 선택될 때까지 반복한다. 이때 반복이 종료된다면, 모든 노드간 최단거리가 들어있게 된다. 0 5 7 3 1 5 0 2 8 6 7 2 0 7 8 3 8 7 0 2 1 6 8 2 0 코드 for (int i = 1; i \u003c= n; i++) for (int t = 1; t \u003c= n; t++) if(i == t) d[i][t] = 0; else if(a[i][t]) d[i][t] = a[i][t]; else d[i][t] = INF; for (int i = 1; i \u003c= n; i++) for (int t = 1; t \u003c= n; t++) for (int y = 1; y \u003c= n; y++) d[t][y] = min(d[t][y], d[t][i] + d[i][y]); ","date":"2020-02-27","objectID":"/2020-02-27-floydwarshall/:0:0","tags":["Learn","C++","최단 경로"],"title":"[C++]플로이드-와샬 알고리즘(Floyd-Warshall Algorithm)","uri":"/2020-02-27-floydwarshall/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-27","objectID":"/2020-02-27-10942/","tags":["algorithm","C++","DP"],"title":"[백준]10942 팰린드롬?","uri":"/2020-02-27-10942/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10942 풀이: DP[i][t] : i 번쨰 수 부터 t 번째 까지 수가 팰린드롬을 이룬다면 1, 아니라면 0 a[i] == a[t] 라면, DP[i][t] = DP[i + 1][t - 1] a[i] != a[t] 라면, DP[i][t] = 0 테스트 케이스가 많아 시간초과가 날 수 있으므로 메모이제이션을 하자! 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring.h\u003eusing namespace std; int m, n, q, w, a[2002], dp[2002][2002]; int p(int x, int y) { if (dp[x][y] != -1) return dp[x][y]; if (x \u003e y) dp[x][y] = 1; else if (a[x] == a[y]) dp[x][y] = p(x + 1, y - 1); else dp[x][y] = 0; return dp[x][y]; } int main() { scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); scanf(\"%d\", \u0026m); memset(dp, -1, sizeof(dp)); while (m--) { scanf(\"%d %d\", \u0026q, \u0026w); printf(\"%d\\n\", p(q, w)); } } ","date":"2020-02-27","objectID":"/2020-02-27-10942/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]10942 팰린드롬?","uri":"/2020-02-27-10942/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-27","objectID":"/2020-02-27-1260/","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]1260 DFS와 BFS","uri":"/2020-02-27-1260/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1260 풀이: DFS 와 BFS를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cstring.h\u003eusing namespace std; int n, m, v, q, w, a[1002][1002] = {}; bool b[1002]; void dfs(int x) { b[x] = true; cout \u003c\u003c x \u003c\u003c \" \"; for (int i = 1; i \u003c= n; i++) if (a[x][i] \u0026\u0026 !b[i]) dfs(i); } int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e v; for (int i = 0; i \u003c m; i++) { cin \u003e\u003e q \u003e\u003e w; a[q][w] = 1; a[w][q] = 1; } dfs(v); cout \u003c\u003c endl; memset(b, 0, n + 1); queue\u003cint\u003e c; c.push(v); b[v] = true; while (!c.empty()) { cout \u003c\u003c c.front() \u003c\u003c \" \"; for (int i = 1; i \u003c= n; i++) if (a[c.front()][i] \u0026\u0026 !b[i]) { c.push(i); b[i] = true; } c.pop(); } cout \u003c\u003c endl; } ","date":"2020-02-27","objectID":"/2020-02-27-1260/:0:0","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]1260 DFS와 BFS","uri":"/2020-02-27-1260/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-27","objectID":"/2020-02-27-1520/","tags":["algorithm","C++","DP"],"title":"[백준]1520 내리막 길","uri":"/2020-02-27-1520/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1520 풀이: DP[i][t] : (1,1) ~ (i, t) 까지 내리막으로 갈 수 있는 경우의 수 현재 값에서 왼쪽, 오른쪽, 위, 아래 값이 각각 현재 값보다 크다면, DP[현재] += DP[왼쪽, 오른쪽, 위, 아래] 로 구할 수 있다. 시간초과가 날 수 있으므로 메모이제이션을 하자! 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring.h\u003eusing namespace std; int m, n, a[502][502], dp[502][502]; int r(int x, int y) { if (dp[x][y] != -1) return dp[x][y]; dp[x][y] = 0; if (a[x][y] \u003c a[x - 1][y]) dp[x][y] += r(x - 1, y); if (a[x][y] \u003c a[x + 1][y]) dp[x][y] += r(x + 1, y); if (a[x][y] \u003c a[x][y + 1]) dp[x][y] += r(x, y + 1); if (a[x][y] \u003c a[x][y - 1]) dp[x][y] += r(x, y - 1); return dp[x][y]; } int main() { cin \u003e\u003e m \u003e\u003e n; for (int i = 1; i \u003c= m; i++) for (int t = 1; t \u003c= n; t++) cin \u003e\u003e a[i][t]; memset(dp, -1, sizeof(dp)); dp[1][1] = 1; cout \u003c\u003c r(m, n) \u003c\u003c endl; } ","date":"2020-02-27","objectID":"/2020-02-27-1520/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1520 내리막 길","uri":"/2020-02-27-1520/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-27","objectID":"/2020-02-27-2618/","tags":["algorithm","C++","DP"],"title":"[백준]2618 경찰차","uri":"/2020-02-27-2618/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2618 풀이: DP[i][t] : 첫번째 경찰차가 i 번째 사건을, 두번째 경찰차가 t 번째 사건을 처리했을 때, 이동하는 거리의 합의 최소값 i 와 t 의 차이가 1 이라면, DP[i][t] = DP[i][0 ~ t - 1] (t 번째와 0 ~ t - 1 번째 사이의 거리)까지의 최소값 1이 아니라면, DP[i][t] = DP[i][t - 1] + (t 번째와 t - 1 번째 사이의 거리) 을 통해 최솟값을 구할 수 있다. 최솟값을 구한 후, 최솟값을 구한 경로를 역순으로 추적하여, 맡겨진 경찰차의 번호를 구한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int m, n, x[1002], y[1002], dp[1002][1002], mi = 987654321, q, w, e[1002]; int po(int a, int b) { if ((!a \u0026\u0026 !b) || dp[a][b]) return dp[a][b]; if (a \u003c b) if (b - a == 1) { dp[a][b] = po(a, 0) + 2 * n - x[b] - y[b]; for (int i = 1; i \u003c a; i++) dp[a][b] = min(dp[a][b], po(a, i) + abs(x[b] - x[i]) + abs(y[b] - y[i])); } else dp[a][b] = po(a, b - 1) + abs(x[b - 1] - x[b]) + abs(y[b - 1] - y[b]); else if (a - b == 1) { dp[a][b] = po(0, b) + x[a] + y[a] - 2; for (int i = 1; i \u003c b; i++) dp[a][b] = min(dp[a][b], po(i, b) + abs(x[a] - x[i]) + abs(y[a] - y[i])); } else dp[a][b] = po(a - 1, b) + abs(x[a - 1] - x[a]) + abs(y[a - 1] - y[a]); return dp[a][b]; } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= m; i++) cin \u003e\u003e x[i] \u003e\u003e y[i]; for (int i = 0; i \u003c m; i++) { po(m, i); po(i, m); if (mi \u003e dp[m][i]) { mi = dp[m][i]; q = m, w = i; } if (mi \u003e dp[i][m]) { mi = dp[i][m]; q = i, w = m; } } for (int i = m; i \u003e 0; i--) { if (q == i) { e[i] = 1; if (w == i - 1) { for (int t = 0; t \u003c w; t++) { if (dp[t][w] + abs(x[q] - x[t]) + abs(y[q] - y[t]) == dp[q][w]) { q = t; break; } } } else q--; } else if (w == i) { e[i] = 2; if (q == i - 1) { e[i - 1] = 1; for (int t = 0; t \u003c q; t++) { if (dp[q][t] + abs(x[w] - x[t]) + abs(y[w] - y[t]) == dp[q][w]) { w = t; break; } } } else w--; } } cout \u003c\u003c mi \u003c\u003c endl; for (int i = 1; i \u003c= m; i++) cout \u003c\u003c e[i] \u003c\u003c endl; } ","date":"2020-02-27","objectID":"/2020-02-27-2618/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2618 경찰차","uri":"/2020-02-27-2618/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-27","objectID":"/2020-02-27-2667/","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]2667 단지번호붙이기","uri":"/2020-02-27-2667/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2667 풀이: 전체를 순회한다. 만약 집이있는 곳 ( 배열에 1인 곳 ) 을 찾았다면, 연결된 모든 단지를 찾아 단지 크기를 배열에 저장한다. 순회가 끝났다면, 배열의 사이즈 (총 단지수) 를 출력한다. 그 후 단지내 집의 수를 오름차순으로 정렬하여 출력하여야하므로 배열을 정렬한 후 배열의 원소를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003calgorithm\u003eusing namespace std; int n; bool b[26][26]; vector\u003cstring\u003e a; vector\u003cint\u003e c; void num(int x, int y) { b[x][y] = true; c.back()++; if (x + 1 \u003c n \u0026\u0026 a[x + 1][y] == '1' \u0026\u0026 !b[x + 1][y]) num(x + 1, y); if (y + 1 \u003c n \u0026\u0026 a[x][y + 1] == '1' \u0026\u0026 !b[x][y + 1]) num(x, y + 1); if (x - 1 \u003e= 0 \u0026\u0026 a[x - 1][y] == '1' \u0026\u0026 !b[x - 1][y]) num(x - 1, y); if (y - 1 \u003e= 0 \u0026\u0026 a[x][y - 1] == '1' \u0026\u0026 !b[x][y - 1]) num(x, y - 1); } int main() { cin \u003e\u003e n; a.resize(n); for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c n; t++) if (a[i][t] == '1' \u0026\u0026 !b[i][t]) { c.push_back(0); num(i, t); } cout \u003c\u003c c.size() \u003c\u003c endl; sort(c.begin(), c.end()); for (int i : c) cout \u003c\u003c i \u003c\u003c endl; } ","date":"2020-02-27","objectID":"/2020-02-27-2667/:0:0","tags":["algorithm","C++","DFS","BFS"],"title":"[백준]2667 단지번호붙이기","uri":"/2020-02-27-2667/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-10816/","tags":["algorithm","C++","이분 탐색"],"title":"[백준]10816 숫자 카드2","uri":"/2020-02-26-10816/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10816 풀이: 배열에 숫자 카드들을 넣는다. 배열을 정렬한다. 몇 개 가지고 있는지 구해야 할 카드를 k 라고 할 때, k가 최초로 나오는 위치 = lower_bound, k보다 큰 값이 최초로 나오는 위치 = upper_bound 로 구할 수 있다. 즉 upper_bound - lower_bound를 실행한다면 답을 구할 수 있다. cout과 cin 을 쓰면 시간초과가 나므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m, k, a[500001]; int main() { scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026a[i]); sort(a, a + n); scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"%d\", \u0026k); auto l = lower_bound(a, a + n, k); auto r = upper_bound(a, a + n, k); printf(\"%d \", r - l); } printf(\"\\n\"); return 0; } ","date":"2020-02-26","objectID":"/2020-02-26-10816/:0:0","tags":["algorithm","C++","이분 탐색"],"title":"[백준]10816 숫자 카드2","uri":"/2020-02-26-10816/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-11049/","tags":["algorithm","C++","DP"],"title":"[백준]11049 행렬 곱셈 순서","uri":"/2020-02-26-11049/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11049 풀이: DP[i][t] : i ~ t 까지의 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값 dp[x][y] = min(dp[x][y], f(x, i) + f(i + 1, y) + a[x] * b[i] * b[y]) x ~ i 까지의 행렬 곱셈 + (i + 1) ~ y 까지의 행렬 곱셈 + 그 둘의 곱셈 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; long long n, a[502], b[502], dp[502][502] = {}; long long f(int x, int y) { if (x == y || dp[x][y]) return dp[x][y]; dp[x][y] = f(x, x) + f(x + 1, y) + a[x] * b[x] * b[y]; for (int i = x + 1; i \u003c y; i++) dp[x][y] = min(dp[x][y], f(x, i) + f(i + 1, y) + a[x] * b[i] * b[y]); return dp[x][y]; } int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i] \u003e\u003e b[i]; cout \u003c\u003c f(1, n) \u003c\u003c endl; } ","date":"2020-02-26","objectID":"/2020-02-26-11049/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11049 행렬 곱셈 순서","uri":"/2020-02-26-11049/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-11066/","tags":["algorithm","C++","DP"],"title":"[백준]11066 파일 합치기","uri":"/2020-02-26-11066/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11066 풀이: dp[i][t] = i 장 부터 t 장까지 수록한 파일을 합쳤을 때, 필요한 최소비용 sum[i] = 1 ~ i 까지의 파일 크기의 합 dp[i][t] = min(dp[i][t], dp[i][i] ~ dp[i][t - 1] + dp[i + 1][t] ~ dp[t][t]) 로 구할 수 있다. 겹치는 숫자들이 있으므로, dp를 구할 때 마다, dp[i][t] += sum[t] - sum[i - 1] 을 해주어야 한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int T, n, a[502], dp[502][502] = {}, sum[502]; int f(int a, int b) { if (dp[a][b] != 987654321) return dp[a][b]; for (int i = 0; a + i \u003c b; i++) dp[a][b] = min(dp[a][b], f(a, a + i) + f(i + a + 1, b)); if (a != 1 || b != n) dp[a][b] += sum[b] - sum[a - 1]; return dp[a][b]; } int main() { cin \u003e\u003e T; while (T--) { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) for (int t = 1; t \u003c= n; t++) dp[i][t] = 987654321; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; dp[i][i] = a[i]; sum[i] = a[i] + sum[i - 1]; } cout \u003c\u003c f(1, n) \u003c\u003c endl; } } ","date":"2020-02-26","objectID":"/2020-02-26-11066/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11066 파일 합치기","uri":"/2020-02-26-11066/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-11286/","tags":["algorithm","C++","힙"],"title":"[백준]11286 절댓값 힘","uri":"/2020-02-26-11286/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11286 풀이: 0이 나온다면, 배열에 있는 값중 절댓값이 가장 작은 값을 출력한다.(절댓값이 같다면, 가장 작은 값을 출력한다.) 그 값을 배열에서 제외시킨다. 만약 배열이 비어있다면, 0을 출력한다. 0이 아닌 다른 숫자가 나온다면, 그 값을 배열에 넣는다. cout, cin 을 사용하면, 시간초과가 나므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int n, i, m; bool com(int a, int b) { if (abs(a) == abs(b)) return a \u003e b; return abs(a) \u003e abs(b); } int main() { priority_queue\u003cint, vector\u003cint\u003e, decltype(\u0026com)\u003e a(\u0026com); scanf(\"%d\", \u0026n); for (i = 0; i \u003c n; i++) { scanf(\"%d\", \u0026m); if (!m) if (a.empty()) printf(\"0\\n\"); else { printf(\"%d\\n\", a.top()); a.pop(); } else a.push(m); } } 코드: predicate를 사용하지않은 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int n, m; int main() { priority_queue\u003cpair\u003cint, int\u003e\u003e a; cin \u003e\u003e n; while(n--) { scanf(\"%d\", \u0026m); if (m) a.push({ -abs(m), -m }); else if (a.empty()) printf(\"0\\n\"); else { printf(\"%d\\n\", -a.top().second); a.pop(); } } } ","date":"2020-02-26","objectID":"/2020-02-26-11286/:0:0","tags":["algorithm","C++","힙"],"title":"[백준]11286 절댓값 힘","uri":"/2020-02-26-11286/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-1654/","tags":["algorithm","C++","이분 탐색"],"title":"[백준]1654 랜선 자르기","uri":"/2020-02-26-1654/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1654 풀이: 배열을 받아온다. 배열의 들어있는 랜선의 길이 중 최댓값이 만들 수 있는 최대 길이의 랜선이므로 최댓값을 설정한다. 최솟값은 1로 설정한다. 최댓값과 최솟값의 중간값을 m이라고 하자. 모든 배열의 원소를 m으로 나눈 몫을 모두 더한다. 더한 값이 필요한 랜선의 갯수보다 작다면, m값이 너무 크다는 것이므로 최댓값을 m - 1 로 바꿔준다. 더한 값이 필요한 랜선의 갯수보다 크거나 같다면, 만들 수 있다는 것이므로 답에 저장해 놓는다. 이때, 랜선의 최대 길이를 찾아야 하므로, 랜선의 갯수와 같다고 바로 끝내지 말고 위로 가면서 최댓값을 찾아야한다. l 을 0으로 설정할 경우 m이 0이 나와 0으로 나누게 되어 런타임 에러가 날 수도 있으니 조심하자. 랜선의 길이가 2^31 - 1 보다 작거나 같으므로 int 보다는 long long 을 사용하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; long long n, k, i, a[10001], sum, m, l = 1, r = 0, c = 0; int main() { cin \u003e\u003e k \u003e\u003e n; for (i = 0; i \u003c k; i++) { cin \u003e\u003e a[i]; r = max(r, a[i]); } while (l \u003c= r) { sum = 0; m = (r + l) / 2; for (i = 0; i \u003c k; i++) sum += a[i] / m; if (sum \u003c n) r = m - 1; else { c = max(c, m); l = m + 1; } } cout \u003c\u003c c \u003c\u003c endl; return 0 } ","date":"2020-02-26","objectID":"/2020-02-26-1654/:0:0","tags":["algorithm","C++","이분 탐색"],"title":"[백준]1654 랜선 자르기","uri":"/2020-02-26-1654/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-1655/","tags":["algorithm","C++","힙"],"title":"[백준]1655 가운데를 말해요","uri":"/2020-02-26-1655/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1655 풀이: 하나씩 숫자를 받아온다. 첫번째 숫자를 mid 라고 할 때, 현재 숫자가 mid보다 크거나 같다면, 배열 r 에 작다면, 배열 l 에 저장한다. mid를 배열 r 에 넣고, 배열 l 의 값 중 가장 큰 값으로 바꾼다. 만약, 배열 r과 l의 사이즈 차이가 2이상 난다면, mid값을 조정해준다. cout, cin 을 사용하면, 시간초과가 나므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int n, m, mid; int main() { priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e r; priority_queue\u003cint\u003e l; scanf(\"%d %d\", \u0026n, \u0026mid); printf(\"%d\\n\", mid); while (--n) { scanf(\"%d\", \u0026m); m \u003c mid ? l.push(m) : r.push(m); if (!l.empty()) { r.push(mid); mid = l.top(); l.pop(); } while ((int)r.size() - (int)l.size() \u003e= 2) { l.push(mid); mid = r.top(); r.pop(); } while ((int)l.size() - (int)r.size() \u003e= 2) { r.push(mid); mid = l.top(); l.pop(); } printf(\"%d\\n\", mid); } } ","date":"2020-02-26","objectID":"/2020-02-26-1655/:0:0","tags":["algorithm","C++","힙"],"title":"[백준]1655 가운데를 말해요","uri":"/2020-02-26-1655/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-2110/","tags":["algorithm","C++","이분 탐색"],"title":"[백준]2110 공유기 설치","uri":"/2020-02-26-2110/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2110 풀이: [백준]1654 랜선 자르기 참고 최대 거리를 설정하고, 그 거리를 기준으로 공유기를 설치할 수 있는지 확인하고, 이분탐색으로 최대 거리를 조절해 나간다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; long long n, k, i, a[200001], sum, m, l = 1, r, c = 0, d; int main() { cin \u003e\u003e k \u003e\u003e n; for (i = 0; i \u003c k; i++) cin \u003e\u003e a[i]; sort(a, a + k); r = a[k - 1]; while (l \u003c= r) { sum = 1; m = (r + l) / 2; d = a[0]; for (i = 1; i \u003c k; i++) if (d + m \u003c= a[i]) { d = a[i]; sum++; } if (sum \u003c n) r = m - 1; else { c = max(c, m); l = m + 1; } } cout \u003c\u003c c \u003c\u003c endl; return 0; } ","date":"2020-02-26","objectID":"/2020-02-26-2110/:0:0","tags":["algorithm","C++","이분 탐색"],"title":"[백준]2110 공유기 설치","uri":"/2020-02-26-2110/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-2805/","tags":["algorithm","C++","이분 탐색"],"title":"[백준]2805 나무 자르기","uri":"/2020-02-26-2805/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2805 풀이: [백준]1654 랜선 자르기 참고 m값이 배열의 값보다 작은데 a[i] - m을 할 경우 -값이 나오므로 주의하자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; long long n, k, i, a[1000001], sum, m, l = 1, r = 0, c = 0; int main() { cin \u003e\u003e k \u003e\u003e n; for (i = 0; i \u003c k; i++) { cin \u003e\u003e a[i]; r = max(r, a[i]); } while (l \u003c= r) { sum = 0; m = (r + l) / 2; for (i = 0; i \u003c k; i++) sum += a[i] \u003c m ? 0 : a[i] - m; if (sum \u003c n) r = m - 1; else { c = max(c, m); l = m + 1; } } cout \u003c\u003c c \u003c\u003c endl; return 0; } ","date":"2020-02-26","objectID":"/2020-02-26-2805/:0:0","tags":["algorithm","C++","이분 탐색"],"title":"[백준]2805 나무 자르기","uri":"/2020-02-26-2805/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-1300/","tags":["algorithm","C++","이분 탐색"],"title":"[백준]k번째 수","uri":"/2020-02-26-1300/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1300 풀이: [백준]1654 랜선 자르기 참고 현재 숫자의 순서가 k를 넘어간다면, 오른쪽 탐색을, 아니라면 왼쪽으로 탐색한다. int형 사이즈를 넘어가니 long long으로 바꿔주자. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; long long n, k, i, sum, m, l = 1, r, c; int main() { cin \u003e\u003e n \u003e\u003e k; r = n * n; c = r; while (l \u003c= r) { sum = 0; m = (r + l) / 2; for (i = 1; i \u003c= n; i++) sum += min(n, m / i); if (sum \u003c k) l = m + 1; else { c = min(c, m); r = m - 1; } } cout \u003c\u003c c \u003c\u003c '\\n'; } ","date":"2020-02-26","objectID":"/2020-02-26-1300/:0:0","tags":["algorithm","C++","이분 탐색"],"title":"[백준]k번째 수","uri":"/2020-02-26-1300/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-26","objectID":"/2020-02-26-matrix/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]최적의 행렬 곱셈","uri":"/2020-02-26-matrix/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 크기가 a by b인 행렬과 크기가 b by c 인 행렬이 있을 때, 두 행렬을 곱하기 위해서는 총 a x b x c 번 곱셈해야합니다. 예를 들어서 크기가 5 by 3인 행렬과 크기가 3 by 2인 행렬을 곱할때는 총 5 x 3 x 2 = 30번의 곱하기 연산을 해야 합니다. 행렬이 2개일 때는 연산 횟수가 일정 하지만, 행렬의 개수가 3개 이상일 때는 연산의 순서에 따라서 곱하기 연산의 횟수가 바뀔 수 있습니다. 예를 들어서 크기가 5 by 3인 행렬 A, 크기가 3 by 10인 행렬 B, 크기가 10 by 6인 행렬 C가 있을 때, 순서대로 A와 B를 먼저 곱하고, 그 결과에 C를 곱하면 A와 B행렬을 곱할 때 150번을, AB 에 C를 곱할 때 300번을 연산을 해서 총 450번의 곱하기 연산을 합니다. 하지만, B와 C를 먼저 곱한 다음 A 와 BC를 곱하면 180 + 90 = 270번 만에 연산이 끝납니다. 각 행렬의 크기 matrix_sizes 가 매개변수로 주어 질 때, 모든 행렬을 곱하기 위한 최소 곱셈 연산의 수를 return하는 solution 함수를 완성해 주세요. 풀이: [백준]11049 행렬 곱셈 순서 참고 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int dp[202][202] = {}; vector\u003cvector\u003cint\u003e\u003e v; int f(int x, int y) { if (x == y || dp[x][y]) return dp[x][y]; dp[x][y] = f(x, x) + f(x + 1, y) + v[x][0] * v[x][1] * v[y][1]; for (int i = x + 1; i \u003c y; i++) dp[x][y] = min(dp[x][y], f(x, i) + f(i + 1, y) + v[x][0] * v[i][1] * v[y][1]); return dp[x][y]; } int solution(vector\u003cvector\u003cint\u003e\u003e matrix_sizes) { v = matrix_sizes; return f(0, matrix_sizes.size() - 1); } ","date":"2020-02-26","objectID":"/2020-02-26-matrix/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]최적의 행렬 곱셈","uri":"/2020-02-26-matrix/"},{"categories":["Learn"],"content":"learn","date":"2020-02-25","objectID":"/2020-02-25-bellmanford/","tags":["Learn","C++","최단 경로"],"title":"[C++]벨만-포드 알고리즘(Bellman-Ford Algorithm)","uri":"/2020-02-25-bellmanford/"},{"categories":["Learn"],"content":"벨만-포드 알고리즘(Bellman-Ford Algorithm) 벨만-포드 알고리즘(Bellman-Ford Algorithm) 특정 노드에서부터 모든 노드로 가는 최단 경로를 구하는 알고리즘. 그래프에 “음수 사이클\"이 있는 경우 찾아낼 수 있음. 시간복잡도는 O(nm) 음수 사이클 음수 사이클이 있는지 판단하기 위해서는 n번의 라운드를 추가로 진행해 주면된다. 만약, n번째 라운드에서도 감소하는 경우가 있다면, 음수 사이클이 있다고 판단할 수 있다. 코드 for (i = 0; i \u003c= V; i++) d.push_back(INF); d[x] = 0; for(int i = 1; i \u003c= n - 1; i++) for(auto t : edge(a,b,c)) // a 에서 b로 가는 간선, 가중치 c d[b] = min(d[b], d[a] + c); ","date":"2020-02-25","objectID":"/2020-02-25-bellmanford/:0:0","tags":["Learn","C++","최단 경로"],"title":"[C++]벨만-포드 알고리즘(Bellman-Ford Algorithm)","uri":"/2020-02-25-bellmanford/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-25","objectID":"/2020-02-25-1780/","tags":["algorithm","C++","분할 정복"],"title":"[백준]1780 종이의 개수","uri":"/2020-02-25-1780/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1780 풀이: [백준]2630 색종이 만들기 참고 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, c[2200][2200], W = 0, B = 0, D = 0; void se(int x, int y, int a) { bool w = true, b = true, d = true; for (int i = 0; i \u003c a; i++) for (int t = 0; t \u003c a; t++) if (!w \u0026\u0026 !b \u0026\u0026 !d) break; else if (c[x + i][y + t] == -1) { w = false; b = false; } else if (c[x + i][y + t]) { w = false; d = false; } else { d = false; b = false; } W += 1 \u0026 w; B += 1 \u0026 b; D += 1 \u0026 d; if (!w \u0026\u0026 !b \u0026\u0026 !d) { a /= 3; for (int i = 0; i \u003c 3; i++) for (int t = 0; t \u003c 3; t++) se(x + i * a, y + t * a, a); } } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c n; t++) cin \u003e\u003e c[i][t]; se(0, 0, n); cout \u003c\u003c D \u003c\u003c endl \u003c\u003c W \u003c\u003c endl \u003c\u003c B \u003c\u003c endl; return 0; } ","date":"2020-02-25","objectID":"/2020-02-25-1780/:0:0","tags":["algorithm","C++","분할 정복"],"title":"[백준]1780 종이의 개수","uri":"/2020-02-25-1780/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-25","objectID":"/2020-02-25-1992/","tags":["algorithm","C++","분할 정복"],"title":"[백준]1992 쿼드트리","uri":"/2020-02-25-1992/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1992 풀이: [백준]2630 색종이 만들기 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int n; string s, c[65]; void se(int x, int y, int a) { if (x \u003e= n || y \u003e= n || !a) return; bool w = true, b = true; for (int i = 0; i \u003c a; i++) for (int t = 0; t \u003c a; t++) if (!w \u0026\u0026 !b) break; else if (c[x + i][y + t] == '1') w = false; else b = false; if (w) s += '0'; else if (b) s += '1'; else{ s += '('; a /= 2; se(x, y, a); se(x, y + a, a); se(x + a, y, a); se(x + a, y + a, a); s += ')'; } } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) cin \u003e\u003e c[i]; se(0, 0, n); cout \u003c\u003c s \u003c\u003c endl; return 0; } ","date":"2020-02-25","objectID":"/2020-02-25-1992/:0:0","tags":["algorithm","C++","분할 정복"],"title":"[백준]1992 쿼드트리","uri":"/2020-02-25-1992/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-25","objectID":"/2020-02-25-2630/","tags":["algorithm","C++","분할 정복"],"title":"[백준]2630 색종이 만들기","uri":"/2020-02-25-2630/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2630 풀이: n을 2로 나누어 가며 1로 이루어진 곳인지 0으로 이루어진 곳인지 판단한다. 0으로 이루어져있다면 W를 +1 , 1로 이루어져있다면 B를 +1 해준다. 하얀색 색종이와 파란색 색종이의 갯수를 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int n, c[129][129], W = 0, B = 0; void se(int x, int y, int a) { if (x \u003e= n || y \u003e= n || !a) return; bool w = true, b = true; for (int i = 0; i \u003c a; i++) for (int t = 0; t \u003c a; t++) if (!w \u0026\u0026 !b) break; else if (c[x + i][y + t]) w = false; else b = false; W += 1 \u0026 w; B += 1 \u0026 b; if (!w \u0026\u0026 !b){ a /= 2; se(x, y, a); se(x + a, y, a); se(x, y + a, a); se(x + a, y + a, a); } } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c n; t++) cin \u003e\u003e c[i][t]; se(0, 0, n); cout \u003c\u003c W \u003c\u003c endl \u003c\u003c B \u003c\u003c endl; return 0; } ","date":"2020-02-25","objectID":"/2020-02-25-2630/:0:0","tags":["algorithm","C++","분할 정복"],"title":"[백준]2630 색종이 만들기","uri":"/2020-02-25-2630/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-25","objectID":"/2020-02-25-6549/","tags":["algorithm","C++","분할 정복","스택"],"title":"[백준]6549 히스토그램에서 가장 큰 직사각형","uri":"/2020-02-25-6549/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/6549 풀이: 값을 하나씩 받아온다. 현재 값보다 스택에 있는 값이 더 크다면, max(현재 max값, 스택의 탑값 * (스택의 탑 바로 전 값의 위치와 현재 위치의 차이)) 을 수행하고, 현재 탑에 있는 값을 pop한다. 스택에 모든 값이 현재 있는 값보다 작거나 같다면, 스택에 현재 값을 push한다. 모든 값을 받았다면, 스택이 빌 때까지 max(현재 max값, 스택의 탑값 * (스택의 탑 바로 전 값의 위치와 전체 히스토그램의 길이의 차이)) 를 수행한다. 히스토그램의 길이가 0일경우 반복을 중지한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstack\u003e#include \u003calgorithm\u003eusing namespace std; typedef long long ll; ll n, m, i, ma, c; int main() { while (1) { ma = 0; cin \u003e\u003e n; if (!n) break; stack\u003cpair\u003cll, ll\u003e\u003e a; a.push({ 0, 0 }); for (i = 1; i \u003c= n; i++) { cin \u003e\u003e m; while (m \u003c a.top().second) { c = a.top().second; a.pop(); ma = max(ma, c * (i - a.top().first - 1)); } a.push({ i, m }); } c = a.top().second; a.pop(); while (!a.empty()) { ma = max(ma, c * (n - a.top().first)); c = a.top().second; a.pop(); } cout \u003c\u003c ma \u003c\u003c endl; } return 0; } ","date":"2020-02-25","objectID":"/2020-02-25-6549/:0:0","tags":["algorithm","C++","분할 정복","스택"],"title":"[백준]6549 히스토그램에서 가장 큰 직사각형","uri":"/2020-02-25-6549/"},{"categories":["Learn"],"content":"learn","date":"2020-02-24","objectID":"/2020-02-24-dijkstra/","tags":["Learn","C++","최단 경로"],"title":"[C++]다익스트라 알고리즘(Dijkstra Algorithm)","uri":"/2020-02-24-dijkstra/"},{"categories":["Learn"],"content":"다익스트라 알고리즘(Dijkstra Algorithm) 다익스트라 알고리즘(Dijkstra Algorithm) 특정 노드에서부터 모든 노드로 가는 최단 경로를 구하는 알고리즘. 가중치가 음수인 간선이 없는 경우에만 사용할 수 있다. 시간복잡도 : O(n + mlog m) (n : 노드의 개수, m : 간선의 갯수) 코드 for (i = 0; i \u003c= V; i++) d.push_back(INF); d[k] = 0; p.push({ 0, k }); while (!p.empty()) { w = p.top().second; p.pop(); if (b[w]) continue; b[w] = true; for (auto t : a[w]) { u = t.first, v = t.second; if (d[u] \u003e d[w] + v) { d[u] = d[w] + v; p.push({ d[u], u }); } } ","date":"2020-02-24","objectID":"/2020-02-24-dijkstra/:0:0","tags":["Learn","C++","최단 경로"],"title":"[C++]다익스트라 알고리즘(Dijkstra Algorithm)","uri":"/2020-02-24-dijkstra/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-11054/","tags":["algorithm","C++","DP"],"title":"[백준]11054 가장 긴 바이토닉 부분 수열","uri":"/2020-02-24-11054/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11054 풀이: b[i] = i 위치 왼쪽에 있는 값들 중 m[i] 보다 작은 수들의 최대 갯수 s[i] = i 위치 오른쪽에 있는 값들 중 m[i] 보다 작은 수들의 최대 갯수 가장 긴 수열의 길이 = 모든 i 에 대해 (b[i] + s[i] + 1) 의 최댓값 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m[1001], b[1001], s[1001], ma = 0; int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) cin \u003e\u003e m[i]; for (int i = n - 2; i \u003e= 0; i--) for (int t = n - 1; t \u003e i; t--) if (m[i] \u003e m[t]) s[i] = max(s[i], s[t] + 1); for (int i = 0; i \u003c n; i++) { for (int t = 0; t \u003c i; t++) if (m[i] \u003e m[t]) b[i] = max(b[i], b[t] + 1); ma = max(ma, b[i] + s[i] + 1); } cout \u003c\u003c ma \u003c\u003c endl; return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-11054/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11054 가장 긴 바이토닉 부분 수열","uri":"/2020-02-24-11054/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-12865/","tags":["algorithm","C++","DP"],"title":"[백준]12865 평범한 배낭","uri":"/2020-02-24-12865/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/12865 풀이: DP[i] : i 무게일 때, 배낭에 넣을 수 있는 물건의 가치의 최댓값 DP[i + w] = max(DP[i + w], DP[i] + v) 무게가 i + w 일 때, 최댓값은 이전에 있었던 i + w 일때의 값과, i 에 있는 값에 w 무게 물건의 가치인 v를 더한 값 중 최댓값이다. (DP를 DP[2][100001] 처럼 두개로 나누어 놓은 이유는 물건의 갯수가 1개씩이기 때문에 물건 중복을 피하기위해 나누어놓았다.) ex) 무게가 4이고, 가치가 5일때, DP[4] = 5 가 되지만, DP[8] = DP[4] + 5 가 되어 10이 되는 불상사가 일어날 수 있기 때문에, 두개로 나누어 놓앗다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, k, w, v, c[2][100001], ma = 0; int main() { cin \u003e\u003e n \u003e\u003e k; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e w \u003e\u003e v; for (int t = 0; t \u003c w; t++) c[i % 2][t] = max(c[(i + 1) % 2][t], c[i % 2][t]); for (int t = 0; t \u003c= k - w; t++) { c[i % 2][w + t] = max(c[(i + 1) % 2][w + t], v + c[(i + 1) % 2][t]); ma = max(ma, c[i % 2][w + t]); } } cout \u003c\u003c ma \u003c\u003c endl; return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-12865/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]12865 평범한 배낭","uri":"/2020-02-24-12865/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-14888/","tags":["algorithm","C++","브루트 포스"],"title":"[백준]14888 연산자 끼워넣기","uri":"/2020-02-24-14888/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/14888 풀이: 각 숫자를 순서대로 배열에 넣어놓는다. +, -, *, / 를 갯수만큼 각 숫자사이의 끼워넣어 식을 만든다. 만들 식의 값들을 배열에 저장해놓는다. 배열에 들어있는 수 중 최댓값, 최솟값을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int n, num[101], op[4]; vector\u003cint\u003e sumn; void o(int a, int b) { if (a == n - 1) { sumn.push_back(b); return; } if (op[0] \u003e 0) { op[0]--; o(a + 1, b + num[a + 1]); op[0]++; } if (op[1] \u003e 0) { op[1]--; o(a + 1, b - num[a + 1]); op[1]++; } if (op[2] \u003e 0) { op[2]--; o(a + 1, b * num[a + 1]); op[2]++; } if (op[3] \u003e 0) { op[3]--; o(a + 1, b / num[a + 1]); op[3]++; } } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) cin \u003e\u003e num[i]; cin \u003e\u003e op[0] \u003e\u003e op[1] \u003e\u003e op[2] \u003e\u003e op[3]; o(0, num[0]); sort(sumn.begin(), sumn.end()); cout \u003c\u003c sumn.back() \u003c\u003c endl \u003c\u003c sumn.front() \u003c\u003c endl; return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-14888/:0:0","tags":["algorithm","C++","브루트 포스"],"title":"[백준]14888 연산자 끼워넣기","uri":"/2020-02-24-14888/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-14889/","tags":["algorithm","C++","브루트 포스"],"title":"[백준]14889 스타트와 링크","uri":"/2020-02-24-14889/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/14889 풀이: n / 2 명의 스타트 팀과 n / 2 팀의 링크팀을 만든다. 스타트팀만 만든다면, 자동적으로 남는 사람들은 링크팀이된다. 구하는 팀에 1은 무조건 들어가도록한다. (1을 포함한 팀을 전부 구한다면, 1을 포함하지 않는 팀은 상대팀에 모두 있기 때문에) 스타트팀의 모든 Sij 값의 합과 링크팀의 모든 Sij 값의 합의 차이를 구한다. 구한 차이들 중 가장 작은 값을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m[21][21], mn = 100000, start, link; bool s[21]; void st(int a, int b) { if (a == n / 2) { start = 0; link = 0; for (int i = 0; i \u003c n; i++) if (s[i]) { for (int t = i + 1; t \u003c n; t++) if (s[t]) start += m[i][t] + m[t][i]; } else for (int t = i + 1; t \u003c n; t++) if (!s[t]) link += m[i][t] + m[t][i]; start = start \u003e link ? start - link : link - start; mn = min(mn, start); } else for (int i = b; i \u003c n; i++) { s[i] = true; st(a + 1, i + 1); s[i] = false; } } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c n; t++) cin \u003e\u003e m[i][t]; s[0] = true; st(1, 1); cout \u003c\u003c mn \u003c\u003c endl; return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-14889/:0:0","tags":["algorithm","C++","브루트 포스"],"title":"[백준]14889 스타트와 링크","uri":"/2020-02-24-14889/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-1541/","tags":["algorithm","C++","greedy"],"title":"[백준]1541 잃어버린 괄호","uri":"/2020-02-24-1541/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1541 풀이: 문자열을 하나씩 확인한다. + 라면, 괄호를 치지않는다. - 라면, 괄호를 친다. 즉, -가 나오면 시작괄호를 치고, 다음 -가 나오면, 끝나는 괄호가 된다. ex) 45 + 55 - 65 + 45 - 67 + 67 = 45 + 55 - (65 + 45) - (67 + 67) 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cstring\u003eusing namespace std; int main() { string s; vector\u003cint\u003e a; int n = 0; cin \u003e\u003e s; a.push_back(stoi(s)); for (int i = 0; i \u003c s.size(); i++) if (s[i] == '+') a.back() += stoi(s.substr(i + 1, 6)); else if (s[i] == '-') { n -= a.back(); a.push_back(stoi(s.substr(i + 1, 6))); } cout \u003c\u003c n + (a[0] * 2) - a.back() \u003c\u003c endl; return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-1541/:0:0","tags":["algorithm","C++","greedy"],"title":"[백준]1541 잃어버린 괄호","uri":"/2020-02-24-1541/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-1676/","tags":["algorithm","C++","수학"],"title":"[백준]1676 팩도리얼 0의 개수","uri":"/2020-02-24-1676/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1676 풀이: 뒤에서 0이 나오려면 팩토리얼을 곱할때, 5 가 곱해져야한다. 즉, 5의 배수가 지나간다면, 팩토리얼의 갯수가 1씩 늘어날 것이다. 팩토리얼을 만드는 동안 5가 몇번 곱해지는지 계산한다면, 0의 갯수를 구할 수 있다. (이 문제는 N의 제한이 500 까지이기 때문에, 팩토리얼을 전체 계산해서 구하기는 힘들다.) 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int n, m = 0; cin \u003e\u003e n; while (n) { n /= 5; m += n; } cout \u003c\u003c m \u003c\u003c endl; return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-1676/:0:0","tags":["algorithm","C++","수학"],"title":"[백준]1676 팩도리얼 0의 개수","uri":"/2020-02-24-1676/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-1931/","tags":["algorithm","C++","greedy"],"title":"[백준]1931 회의실배정","uri":"/2020-02-24-1931/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1931 풀이: 회의 정보를 배열에 저장한다. 저장된 배열을 끝나는 시간을 기준으로 정렬한다. (끝나는 시간이 같다면, 시작하는 시간을 기준으로 정렬) 배열을 처음부터 순회해간다. 저장된 끝값보다 현재 시작시간이 더 크다면, 끝값을 현재 끝나는 시간으로 바꾸고 사용할 수 있는 회의 수를 +1 해준다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int n, ma = 0, e = -1; int main() { cin \u003e\u003e n; vector\u003cpair\u003cint, int\u003e\u003e v(n); for (int i = 0; i \u003c n; i++) cin \u003e\u003e v[i].second \u003e\u003e v[i].first; sort(v.begin(), v.end()); for (int i = 0; i \u003c n; i++) if (e \u003c= v[i].second) { e = v[i].first; ma++; } cout \u003c\u003c ma \u003c\u003c endl; return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-1931/:0:0","tags":["algorithm","C++","greedy"],"title":"[백준]1931 회의실배정","uri":"/2020-02-24-1931/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-2565/","tags":["algorithm","C++","DP"],"title":"[백준]2565 전깃줄","uri":"/2020-02-24-2565/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2565 풀이: c[i] = i 위치 이전 값 중 겹치는 것이 없는 갯수의 최대 연결된 전깃줄 A와 전깃줄 B 를 배열에 저장한다. 저장된 배열을 전깃줄 A를 기준으로 정렬한다. 첫번째 원소부터, 이전 원소 중 전깃줄 B가 더 작은 값 중 c[i] 의 최댓값 + 1을 저장한다. max값에 c[i]의 최댓값 + 1 중 최댓값을 저장한다. n - max값을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int n, a, b, c[101], ma = 0; vector\u003cpair\u003cint, int\u003e\u003e v; int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a \u003e\u003e b; v.push_back(pair\u003cint, int\u003e(a, b)); } sort(v.begin(), v.end()); for (int i = 0; i \u003c n; i++) { for (int t = 0; t \u003c i; t++) if (v[i].second \u003e v[t].second) c[i] = max(c[i], c[t] + 1); ma = max(ma, c[i] + 1); } cout \u003c\u003c n - ma \u003c\u003c endl; return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-2565/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2565 전깃줄","uri":"/2020-02-24-2565/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-5430/","tags":["algorithm","C++","덱"],"title":"[백준]5430 AC","uri":"/2020-02-24-5430/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5430 풀이: 배열안에 들어있는 원소를 R이 나오면 뒤집고, D가 나오면 맨 앞 숫자를 버린다. 만약 D가 나왔는데, 배열이 비어있다면, error 를 출력한다. 시간초과에 주의하자 : cout » printf, cin » scanf 특히 strlen을 주의하자 시간을 많이잡아먹는다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring.h\u003e#include \u003cqueue\u003eusing namespace std; int main() { int T, n, m; cin \u003e\u003e T; while (T--) { deque\u003cint\u003e a; char p[100001], s[300001], *tok; bool b = true, l = true; scanf(\"%s %d %s\", \u0026p, \u0026n, \u0026s); if (n) { tok = strtok(s, \"[,]\"); do { a.push_back(atoi(tok)); } while (tok = strtok(NULL, \"[,]\")); } m = strlen(p); for (int i = 0; i \u003c m; i++) if (p[i] == 'R') l ^= true; else if (a.empty()) { b = false; break; } else if (l) a.pop_front(); else a.pop_back(); if (b) { printf(\"[\"); if (a.empty()) printf(\"]\\n\"); else if (l){ for (int i = 0; i \u003c a.size() - 1; i++) printf(\"%d,\", a[i]); printf(\"%d]\\n\", a.back()); } else { for (int i = a.size() - 1; i \u003e 0; i--) printf(\"%d,\", a[i]); printf(\"%d]\\n\", a.front()); } } else printf(\"error\\n\"); } return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-5430/:0:0","tags":["algorithm","C++","덱"],"title":"[백준]5430 AC","uri":"/2020-02-24-5430/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-24","objectID":"/2020-02-24-9375/","tags":["algorithm","C++","수학"],"title":"[백준]9375 패션왕 신해빈","uri":"/2020-02-24-9375/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9375 풀이: 프로그래머스]위장 을 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cmap\u003eusing namespace std; int main() { int n, m, ma; cin \u003e\u003e n; while (n--) { ma = 1; cin \u003e\u003e m; string s; map\u003cstring, int\u003e a; for (int i = 0; i \u003c m; i++) { cin \u003e\u003e s \u003e\u003e s; a[s]++; } for (auto i = a.begin(); i != a.end(); i++) ma *= i-\u003esecond + 1; cout \u003c\u003c ma - 1 \u003c\u003c endl; } return 0; } ","date":"2020-02-24","objectID":"/2020-02-24-9375/:0:0","tags":["algorithm","C++","수학"],"title":"[백준]9375 패션왕 신해빈","uri":"/2020-02-24-9375/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-23","objectID":"/2020-02-23-9663/","tags":["algorithm","C++","백트래킹"],"title":"[백준]9663 N-Queen","uri":"/2020-02-23-9663/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9663 풀이: https://jyukki97.github.io/blog/2020-02-23-nqueen/ 을 참고 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; bool visit[16][16]; int n, sum = 0; bool po(int a, int b) { for (int i = 1; i \u003c= a || i \u003c= b; i++) { if ((a - i \u003e= 0 \u0026\u0026 b - i \u003e= 0 \u0026\u0026 visit[a - i][b - i]) || (a - i \u003e= 0 \u0026\u0026 b + i \u003c n \u0026\u0026 visit[a - i][b + i]) || (a - i \u003e= 0 \u0026\u0026 visit[a - i][b])) return false; } return true; } void nq(int a) { for (int i = 0; i \u003c n; i++) { if (po(a, i)) { if (a == n - 1) sum++; else { visit[a][i] = true; nq(a + 1); visit[a][i] = false; } } } } int main() { cin \u003e\u003e n; nq(0); cout \u003c\u003c sum \u003c\u003c endl; return 0; } ","date":"2020-02-23","objectID":"/2020-02-23-9663/:0:0","tags":["algorithm","C++","백트래킹"],"title":"[백준]9663 N-Queen","uri":"/2020-02-23-9663/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-23","objectID":"/2020-02-23-nqueen/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]N-Queen","uri":"/2020-02-23-nqueen/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 가로, 세로 길이가 n인 정사각형으로된 체스판이 있습니다. 체스판 위의 n개의 퀸이 서로를 공격할 수 없도록 배치하고 싶습니다. 예를 들어서 n이 4인경우 다음과 같이 퀸을 배치하면 n개의 퀸은 서로를 한번에 공격 할 수 없습니다. 체스판의 가로 세로의 세로의 길이 n이 매개변수로 주어질 때, n개의 퀸이 조건에 만족 하도록 배치할 수 있는 방법의 수를 return하는 solution함수를 완성해주세요. 풀이: 첫번째 줄부터 n번째 줄까지 퀸을 하나 씩 놓을 수 있다. i번째 줄에 0 ~ n까지 퀸을 놓는다고 할 때, (i , x) 의 왼쪽 대각선, 위, 오른쪽 대각선 에 다른 퀸이 있는지 확인한다. 없다면 퀸을 놓고 i + 1 줄로 가서 다시 한다. n - 1 번째 줄에 퀸을 놓을 수 있는 경우, answer을 하나씩 +1 해준다 answer을 return 해준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; bool visit[13][13]; int m, sum = 0; bool po(int a, int b) { for (int i = 1; i \u003c= a || i \u003c= b; i++) { if ((a - i \u003e= 0 \u0026\u0026 b - i \u003e= 0 \u0026\u0026 visit[a - i][b - i]) || (a - i \u003e= 0 \u0026\u0026 b + i \u003c m \u0026\u0026 visit[a - i][b + i]) || (a - i \u003e= 0 \u0026\u0026 visit[a - i][b])) return false; } return true; } void nq(int a) { for (int i = 0; i \u003c m; i++) { if (po(a, i)) { if (a == m - 1) sum++; else { visit[a][i] = true; nq(a + 1); visit[a][i] = false; } } } } int solution(int n) { m = n; nq(0); return sum; } ","date":"2020-02-23","objectID":"/2020-02-23-nqueen/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]N-Queen","uri":"/2020-02-23-nqueen/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-22","objectID":"/2020-02-22-1181/","tags":["algorithm","C++","정렬"],"title":"[백준]1181 단어 정렬","uri":"/2020-02-22-1181/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1181 풀이: 배열에 들어있는 string을 길이 순서로 정렬 후 길이가 같다면, 사전순으로 정렬한다. 이 때, 중복된 문자가 있다면, 제거한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cset\u003e#include \u003cstring\u003eusing namespace std; bool com(string a, string b) { if (a.size() == b.size()) return a \u003c b; return a.size() \u003c b.size(); } int main() { int n; cin \u003e\u003e n; string s; set\u003cstring, decltype(\u0026com)\u003e a(\u0026com); for (int i = 0; i \u003c n; i++) { cin \u003e\u003e s; a.insert(s); } for (auto i : a) cout \u003c\u003c i \u003c\u003c endl; return 0; } ","date":"2020-02-22","objectID":"/2020-02-22-1181/:0:0","tags":["algorithm","C++","정렬"],"title":"[백준]1181 단어 정렬","uri":"/2020-02-22-1181/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-21","objectID":"/2020-02-21-1018/","tags":["algorithm","C++","브루트 포스"],"title":"[백준]1018 체스판 다시 칠하기","uri":"/2020-02-21-1018/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1018 풀이: (0, 0) ~ (8, 8) ….. (n - 8, m - 8) ~ (n, m) 까지의 모든 8 X 8 체스판을 서치한다. 체스판이 WBWBWB… 순서로 되어있는지 확인 후 안되어 있는 칸이 몇 칸인지 찾는다. 찾아낸 수를 C라고 할 때, 64 - C와 C 중 더 작은 값을 저장한다. 저장된 값들 중 가장 작은 값을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003calgorithm\u003eusing namespace std; int main() { int n, m, c, ma = 64; cin \u003e\u003e n \u003e\u003e m; vector\u003cstring\u003e a(n); for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c n - 7; i++) { for (int t = 0; t \u003c m - 7; t++) { c = 0; for (int y = 0; y \u003c 8; y++) for (int u = 0; u \u003c 8; u++) { bool b = (y % 2) ^ (u % 2) ^ (a[i + y][t + u] == 'B' ? 1 : 0); c += b; } c = min(c, 64 - c); ma = min(ma, c); } } cout \u003c\u003c ma \u003c\u003c endl; return 0; } ","date":"2020-02-21","objectID":"/2020-02-21-1018/:0:0","tags":["algorithm","C++","브루트 포스"],"title":"[백준]1018 체스판 다시 칠하기","uri":"/2020-02-21-1018/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-20","objectID":"/2020-02-20-2231/","tags":["algorithm","C++"],"title":"[백준]2231 분해합","uri":"/2020-02-20-2231/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2231 풀이: n - (n의 자릿수 * 9) ~ n 까지의 수 중 n의 생성자를 찾아 출력한다. 없다면 0을 출력 n의 자릿수 * 9를 뺀 수부터 시작하는 이유는 생성자가 n + (n의 각 자릿수의 합) 이므로 각 자릿수의 최댓값인 9를 자릿수 만큼 곱한 후 n에서 빼준 값이 생성자의 최소 조건이 된다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int c(int a) { int n = a; while (a) { n += a % 10; a /= 10; } return n; } int main() { string m; bool b = true; cin \u003e\u003e m; int n = stoi(m), a = n - 9 * m.size(); if (a \u003c 0) a = 1; for (int i = a; i \u003c= n; i++) if (c(i) == n) { b = false; cout \u003c\u003c i \u003c\u003c endl; break; } if (b) cout \u003c\u003c 0 \u003c\u003c endl; return 0; } ","date":"2020-02-20","objectID":"/2020-02-20-2231/:0:0","tags":["algorithm","C++"],"title":"[백준]2231 분해합","uri":"/2020-02-20-2231/"},{"categories":["Learn"],"content":"learn","date":"2020-02-19","objectID":"/2020-02-19-bound/","tags":["Learn","C++","이분 탐색"],"title":"[C++]lower_bound, upper_bound","uri":"/2020-02-19-bound/"},{"categories":["Learn"],"content":"lower_bound, upper_bound - 기본적으로 두개 모두 “이진 탐색(Binary Serch)” 기반의 탐색방법 lower_bound lower_bound(arr, arr + n, key); - key 값의 가장 낮은 위치를 찾는다. - key 값이 없다면 key 값보다 큰 가장 작은 정수의 위치를 반환한다. - 반환값이 “iterator” 이다. upper_bound upper_bound(arr, arr + n, key); - key 값을 초과하는 가장 첫번째 원소의 위치. - 반환값이 “iterator” 이다. ","date":"2020-02-19","objectID":"/2020-02-19-bound/:0:0","tags":["Learn","C++","이분 탐색"],"title":"[C++]lower_bound, upper_bound","uri":"/2020-02-19-bound/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-19","objectID":"/2020-02-19-2798/","tags":["algorithm","C++"],"title":"[백준]2798 블랙잭","uri":"/2020-02-19-2798/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2798 풀이: 3장을 뽑을 수 있는 모든 경우의 수를 확인하여 3장의 합이 M값을 넘지않는 최댓값을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int main() { int n, m, ma = 0; cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003e a(n, 0); for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c n - 2; i++) for (int t = i + 1; t \u003c n - 1; t++) for (int y = t + 1; y \u003c n; y++) if (a[i] + a[t] + a[y] \u003c= m) ma = max(ma, a[i] + a[t] + a[y]); cout \u003c\u003c ma \u003c\u003c endl; return 0; } ","date":"2020-02-19","objectID":"/2020-02-19-2798/:0:0","tags":["algorithm","C++"],"title":"[백준]2798 블랙잭","uri":"/2020-02-19-2798/"},{"categories":["백준"],"content":"algorithm","date":"2020-02-18","objectID":"/2020-02-18-11729/","tags":["algorithm","C++","분할 정복"],"title":"[백준]11729 하노이 탑 이동 순서","uri":"/2020-02-18-11729/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11729 풀이: https://jyukki97.github.io/blog/2020-02-18-towerofhanoi/ 를 참고 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; void h(int n, int a, int b, int c) { if (!n) return; else { h(n - 1, a, c, b); printf(\"%d %d\\n\", a, b); h(n - 1, c, b, a); } } int main() { int n, a = 1; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) a *= 2; cout \u003c\u003c a - 1 \u003c\u003c endl; h(n, 1, 3, 2); return 0; } ","date":"2020-02-18","objectID":"/2020-02-18-11729/:0:0","tags":["algorithm","C++","분할 정복"],"title":"[백준]11729 하노이 탑 이동 순서","uri":"/2020-02-18-11729/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-18","objectID":"/2020-02-18-towerofhanoi/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]하노이의 탑","uri":"/2020-02-18-towerofhanoi/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 하노이 탑(Tower of Hanoi)은 퍼즐의 일종입니다. 세 개의 기둥과 이 기동에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있습니다. 게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것입니다. 한 번에 하나의 원판만 옮길 수 있습니다. 큰 원판이 작은 원판 위에 있어서는 안됩니다. 하노이 탑의 세 개의 기둥을 왼쪽 부터 1번, 2번, 3번이라고 하겠습니다. 1번에는 n개의 원판이 있고 이 n개의 원판을 3번 원판으로 최소 횟수로 옮기려고 합니다. 1번 기둥에 있는 원판의 개수 n이 매개변수로 주어질 때, n개의 원판을 3번 원판으로 최소로 옮기는 방법을 return하는 solution를 완성해주세요. 풀이: 함수 h(n, a, b, c)를 n번 원판을 a에서 b로 옮기는 것이라고 하자. n번 원판을 a에서 b로 옮기려면, n - 1을 a에서 c로 옮긴 후 옮길 수 있으므로 h(n - 1, a, c, b)를 실행 한다. 그 후 n번 원판을 a에서 b로 옮긴 후 h(n - 1, c, b, a)를 실행하여 c로 옮긴 n - 1을 b로 가져온다. n이 0이 될 때까지 반복한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cvector\u003cint\u003e\u003e answer; void h(int n, int a, int b, int c) { if (!n) return; else { h(n - 1, a, c, b); answer.push_back(vector\u003cint\u003e{a, b}); h(n - 1, c, b, a); } } vector\u003cvector\u003cint\u003e\u003e solution(int n) { h(n, 1, 3, 2); return answer; } ","date":"2020-02-18","objectID":"/2020-02-18-towerofhanoi/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]하노이의 탑","uri":"/2020-02-18-towerofhanoi/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-17","objectID":"/2020-02-17-wordtranslation/","tags":["algorithm","C++","DFS","BFS","Level 3"],"title":"[프로그래머스]단어 변환","uri":"/2020-02-17-wordtranslation/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다. 1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다. 2. words에 있는 단어로만 변환할 수 있습니다. 예를 들어 begin이 hit, target가 cog, words가 [hot,dot,dog,lot,log,cog]라면 hit -\u003e hot -\u003e dot -\u003e dog -\u003e cog와 같이 4단계를 거쳐 변환할 수 있습니다. 두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요. 풀이: 배열 words에 target 단어가 없다면 0을 return 한다. 만약 begin 과 target의 단어가 한개의 알파벳만 다를때 까지 반복을 개시한다. words의 들어 있는 배열 중 begin과 알파벳 하나 차이나는 단어를 찾는다. begin을 그 단어로 바꾼 후 words에서 삭제한다. answer 값을 +1 해준다. 반복이 끝난 후 answer + 1 을 return 해준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; bool com(string a, string b) { int c = 0; for (int i = 0; i \u003c a.size(); i++) if (a[i] == b[i]) c++; if (c == a.size() - 1) return true; return false; } int solution(string begin, string target, vector\u003cstring\u003e words) { int answer = 0; bool b = true; for (string s : words) if (s == target) { b = false; break; } if (b) return answer; while (!com(begin, target)) { for (int i = 0; i \u003c words.size(); i++) { if (com(begin, words[i])) { begin = words[i]; answer++; words.erase(words.begin() + i); break; } } } return answer + 1; } ","date":"2020-02-17","objectID":"/2020-02-17-wordtranslation/:0:0","tags":["algorithm","C++","DFS","BFS","Level 3"],"title":"[프로그래머스]단어 변환","uri":"/2020-02-17-wordtranslation/"},{"categories":["Learn"],"content":"learn","date":"2020-02-16","objectID":"/2020-02-16-setpredicate/","tags":["Learn","C++","set"],"title":"[C++]set predicate","uri":"/2020-02-16-setpredicate/"},{"categories":["Learn"],"content":"set predicate set 이라는 컨테이너는 기본적으로 “오름차순” 으로 정렬된다. 이를 바꾸기 위해 정렬 기준을 바꿔 주어야한다. 정렬기준은 bool compare(const key_type key_typeA, const key_type key_typeB){ return key_typeA \u003c key_typeB; } 와 같이 bool 형식을 통해 바꿀 수 있다. 정렬기준을 적용하는 방법은 set\u003ckey_type, decltype(\u0026compare)\u003e a(\u0026compare) 과 같이 하면된다. ","date":"2020-02-16","objectID":"/2020-02-16-setpredicate/:0:0","tags":["Learn","C++","set"],"title":"[C++]set predicate","uri":"/2020-02-16-setpredicate/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-16","objectID":"/2020-02-16-immigration/","tags":["algorithm","C++","이분탐색","Level 3"],"title":"[프로그래머스]입국심사","uri":"/2020-02-16-immigration/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다. 처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다. 모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다. 입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요. 풀이: 최소값을 0으로 최댓값을 한 심사관의 시간 * 심사관 인원수로 시작한다. 그 둘의 평균값을 m이라 놓고 반복을 시작한다. m / times[i] 값을 전부 더한 값을 sum 이라한다. sum 값이 n값보다 크거나 같다면, m보다 시간이 적게 걸린다는 것이므로 e를 m으로 바꿔준다. sum 값이 n값보다 작다면, m보다 시간이 더 걸린다는 것이므로 s를 m + 1로 바꿔준다. 계속 반복하다가 s값이 e값과 같다면 반복을 중지한다. m값이 모든 사람이 심가를 받는데 걸리는 시간이다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; long long solution(int n, vector\u003cint\u003e times) { long long m, sum, s = 0, e = times.back() * n; while (1) { sum = 0; m = (s + e) / 2; if (s == e) break; for (int i : times) sum += m / i; if (sum \u003e= n) e = m; else s = m + 1; } return m; } ","date":"2020-02-16","objectID":"/2020-02-16-immigration/:0:0","tags":["algorithm","C++","이분탐색","Level 3"],"title":"[프로그래머스]입국심사","uri":"/2020-02-16-immigration/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-15","objectID":"/2020-02-15-joystick/","tags":["algorithm","C++","greedy","Level 2"],"title":"[프로그래머스]조이스틱","uri":"/2020-02-15-joystick/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다. ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. ▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다. - 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다. 따라서 11번 이동시켜 \"JAZ\"를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 풀이: 현재 위치에서 왼쪽, 오른쪽 중 ‘A’ 가 아닌 문자가 먼저 오는 곳으로 위치를 바꾼다. 바꾼 만큼 answer 값을 + 해준다. 현재 위치값에서 ‘A’ 와의 차이와 ‘Z’ 와의 차이 중 더 작은 것을 answer 에 +해준다. 현재 값을 ‘A’로 바꿔준다. name값이 전부 ‘A’ 라면 반복을 종료한다. greedy로 풀이를 한 문제라 “ABABAAAAAAABA” 같은 값은 정확한 값을 도출하지 못한다. 그러나 문제에서 원하는 방식이 greedy라서 결과또한 greedy값을 원하는 것 같다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(string name) { string a(name.size(), 'A'); int answer = 0, c = 0, r, l; while (name != a) { answer += min(name[c] - 'A', 'Z' - name[c] + 1); name[c] = 'A'; for (int i = 1; i \u003c= name.size() / 2; i++) { r = c + i; l = c - i; if (r \u003e= name.size()) r -= name.size(); if (l \u003c 0) l += name.size(); if (name[r] != 'A') { answer += i; c = r; break; } else if (name[l] != 'A') { answer += i; c = l; break; } } } return answer; } ","date":"2020-02-15","objectID":"/2020-02-15-joystick/:0:0","tags":["algorithm","C++","greedy","Level 2"],"title":"[프로그래머스]조이스틱","uri":"/2020-02-15-joystick/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-14","objectID":"/2020-02-14-lifeboat/","tags":["algorithm","C++","greedy","Level 2"],"title":"[프로그래머스]구명보트","uri":"/2020-02-14-lifeboat/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 풀이: 배열 people을 정렬한다. people에 들어있는 값 중 최댓값 + 최솟값 이 limit 보다 작거나 같다면 최대 최소값을 없애고 보트 갯수를 +1 해준다. 최댓값 + 최솟값 이 limit 보다 크다면 최대값만 없애고 보트 갯수를 +1 해준다. people에 들어있는 값이 모두 사라질 때까지 반복한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(vector\u003cint\u003e people, int limit) { int answer = 0, f = 0, l = people.size() - 1; sort(people.begin(), people.end()); while (f \u003c= l) { if (people[f] + people[l] \u003c= limit) { f++; l--; } else l--; answer++; } return answer; } ","date":"2020-02-14","objectID":"/2020-02-14-lifeboat/:0:0","tags":["algorithm","C++","greedy","Level 2"],"title":"[프로그래머스]구명보트","uri":"/2020-02-14-lifeboat/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-13","objectID":"/2020-02-13-compression/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]압축","uri":"/2020-02-13-compression/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다. 어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다. LZW 압축은 다음 과정을 거친다. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다. w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다. 단계 2로 돌아간다. 압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자. 색인 번호 1 2 3 … 24 25 26 단어 A B C … X Y Z 예를 들어 입력으로 KAKAO가 들어온다고 하자. 현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다. 두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, A의 색인 번호 1을 출력하고, AK를 사전에 28 번째로 등록한다. 세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 다음 글자 O를 포함한 KAO를 29 번째로 등록한다. 마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다. 현재 입력(w) 다음 글자(c) 출력 사전 추가(w+c) K A 11 27: KA A K 1 28: AK KA O 27 29: KAO O 15 이 과정을 거쳐 다섯 글자의 문장 KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다. 입력으로 TOBEORNOTTOBEORTOBEORNOT가 들어오면 다음과 같이 압축이 진행된다. 현재 입력(w) 다음 글자(c) 출력 사전 추가(w+c) T O 20 27: TO O B 15 28: OB B E 2 29: BE E O 5 30: EO O R 15 31: OR R N 18 32: RN N O 14 33: NO O T 15 34: OT T T 20 35: TT TO B 27 36: TOB BE O 29 37: BEO OR T 31 38: ORT TOB E 36 39: TOBE EO R 30 40: EOR RN O 32 41: RNO OT 34 풀이: map 에 ‘A’ ~ ‘Z’ 까지 저장해 놓는다. msg를 처음 문자부터 순회한다. i 번째 있는 문자를 string s에 저장한다. s에 저장된 문자가 map에 있다면, s에 i + 1 번째 문자를 추가한다. s에 저장된 문자가 이번에도 map에 있다면, s에 i + 1 번째 문자를 추가한다. . . . s에 저장된 문자가 map에 없다면, map에 s를 추가한다. s에 마지막 문자를 지운 후 s가 map에 몇번째로 들어간 문자인지 answer에 푸쉬한다. s에 저장된 문자만큼 msg의 문자를 건너뛴 후 반복을 재개한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cmap\u003eusing namespace std; vector\u003cint\u003e solution(string msg) { vector\u003cint\u003e answer; map\u003cstring, int\u003e a; for (int i = 0; i \u003c 26; i++) a[string(1, 'A' + i)] = i + 1; for (int i = 0; i \u003c msg.size(); i++) { string s; int t = i; do { s += msg[t]; t++; } while (a.find(s) != a.end()); a[s] = a.size() + 1; s.erase(s.size() - 1); answer.push_back(a[s]); i = t - 2; } return answer; } ","date":"2020-02-13","objectID":"/2020-02-13-compression/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]압축","uri":"/2020-02-13-compression/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-12","objectID":"/2020-02-12-cache/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]캐시","uri":"/2020-02-12-cache/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다. 이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다. 어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다. 어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오. 풀이: 대소문자 구별을 안하므로 도시를 모두 대문자로 바꿔준다. 배열 a에 들어있는 도시들 중 현재 도시와 같은 이름이 있다면, answer 을 +1 해주고 배열 a에서 현재 도시를 지운다. 만약 배열 a에 현재 도시와 같은 이름이 없다면, answer 을 +5 해준다. 현재 도시의 이름을 배열 a에 넣는다. 배열 a의 사이즈가 캐시 크기보다 크다면, 배열의 맨 처음값을 삭제해준다. transform(s.begin(), s.end(), s.begin(), ::toupper); 이 부분에서 toupper 부분 앞에 :: 을 빼면 오류가 난다. 이유는 모르겠다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(int cacheSize, vector\u003cstring\u003e cities) { vector\u003cstring\u003e a; int answer = 0; for (string s : cities) { bool b = true; transform(s.begin(), s.end(), s.begin(), ::toupper); for (int i = 0; i \u003c a.size(); i++) { if (s == a[i]){ answer++; b = false; a.erase(a.begin() + i); break; } } if (b) answer += 5; a.push_back(s); if (a.size() \u003e cacheSize) a.erase(a.begin()); } return answer; } ","date":"2020-02-12","objectID":"/2020-02-12-cache/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]캐시","uri":"/2020-02-12-cache/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-11","objectID":"/2020-02-11-dartgame/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]다트 게임","uri":"/2020-02-11-dartgame/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다. 갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다. 다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다. 옵션으로 스타상(*) , 아차상(#)이 존재하며 스타상(*) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다. 스타상(*)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(*)의 점수만 2배가 된다. (예제 4번 참고) 스타상(*)의 효과는 다른 스타상(*)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(*) 점수는 4배가 된다. (예제 4번 참고) 스타상(*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고) Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다. 스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다. 0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라. 풀이: 문자열을 처음부터 순회한다. 만약 숫자라면 배열에 숫자를 넣는다. 그다음 문자가 ‘D’ 라면 방금 넣은 숫자를 제곱해준다. 만약 다음 문자가 ‘T’ 라면 3제곱 해준다. 그 다음 문자가 ‘*’ 이라면, 방금 넣은 숫자를 *2 해준다. 이전에 숫자가 더 있다면, 그 숫자 또한 *2 해준다. 만약 다음 문자가 ‘#’ 이라면 현재 숫자를 *(-1) 해준다. 배열에 넣어진 모든 숫자를 더한 값을 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003eusing namespace std; int solution(string dartResult) { vector\u003cint\u003e a; int c = -1; int answer = 0; for (int i = 0; i \u003c dartResult.size(); i++) { if (dartResult[i] \u003e= '0' \u0026\u0026 dartResult[i] \u003c= '9') { a.push_back(stoi(string(dartResult.begin() + i, dartResult.end()))); c++; if (a[c] == 10) i++; switch (dartResult[i + 1]) { case 'D': a[c] *= a[c]; break; case 'T': a[c] *= a[c] * a[c]; break; } switch (dartResult[i + 2]) { case '*': a[c] *= 2; if (c \u003e 0) a[c - 1] *= 2; break; case '#': a[c] *= -1; break; } } } for (int i : a) answer += i; return answer; } ","date":"2020-02-11","objectID":"/2020-02-11-dartgame/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]다트 게임","uri":"/2020-02-11-dartgame/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-10","objectID":"/2020-02-10-stringsort/","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]문자열 내 마음대로 정렬하기","uri":"/2020-02-10-stringsort/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [sun, bed, car]이고 n이 1이면 각 단어의 인덱스 1의 문자 u, e, a로 strings를 정렬합니다. 풀이: n번째 글자를 기준으로 오름차순 정렬을 한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; vector\u003cstring\u003e solution(vector\u003cstring\u003e strings, int n) { vector\u003cstring\u003e answer; for (int i = 0; i \u003c strings.size(); i++) strings[i].insert(0, string(1, strings[i][n])); sort(strings.begin(), strings.end()); for (int i = 0; i \u003c strings.size(); i++) strings[i].erase(0, 1); return strings; } 깔끔한 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int i; bool compare (string a, string b) { return a[i] == b[i] ? a \u003c b : a[i] \u003c b[i]; } vector\u003cstring\u003e solution(vector\u003cstring\u003e strings, int n) { i = n; sort (strings.begin(), strings.end(), compare); return strings; } ","date":"2020-02-10","objectID":"/2020-02-10-stringsort/:0:0","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]문자열 내 마음대로 정렬하기","uri":"/2020-02-10-stringsort/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-09","objectID":"/2020-02-09-correctbrackets/","tags":["algorithm","C++","Level 4"],"title":"[프로그래머스]올바른 괄호의 갯수","uri":"/2020-02-09-correctbrackets/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 올바른 괄호란 (())나 ()와 같이 올바르게 모두 닫힌 괄호를 의미합니다. )(나 ())() 와 같은 괄호는 올바르지 않은 괄호가 됩니다. 괄호 쌍의 개수 n이 주어질 때, n개의 괄호 쌍으로 만들 수 있는 모든 가능한 괄호 문자열의 갯수를 반환하는 함수 solution을 완성해 주세요. 풀이: 괄호를 () 라고 했을 때, 이것을 ( 따로 ) 따로 생각해서 순열을 구한다고 해보자. 이 때, 나열 할 수 있는 경우의 수는 (2*n)! 이 된다. 그러나 ( 의 갯수와 ) 의 갯수가 각각 n개씩 중복되므로 (n! * n!) 로 나눠주게 된다. 그리고 ()() 와 ())( 를 봣을 때 오른쪽 것은 틀린 것이므로 오른쪽 왼쪽을 같은 순열이라고 취급하여 n으로 한번 더 나눠준다면, (2 * n) ! / (n! * n! * n) 이 답이 되게된다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int n) { long long m1 = 1; for(int i = 2 * n; i \u003e n; i--) m1 *= i; for(int i = 2; i \u003c= n + 1; i++) m1 /= i; return m1; } ","date":"2020-02-09","objectID":"/2020-02-09-correctbrackets/:0:0","tags":["algorithm","C++","Level 4"],"title":"[프로그래머스]올바른 괄호의 갯수","uri":"/2020-02-09-correctbrackets/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-08","objectID":"/2020-02-08-numblock/","tags":["algorithm","C++","Level 4"],"title":"[프로그래머스]숫자 블록","uri":"/2020-02-08-numblock/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 그렙시에는 0으로 된 도로에 숫자 블록을 설치하기로 하였습니다. 숫자 블록의 규칙은 다음과 같습니다. 블록의 번호가 n 일 때, 가장 처음 블록은 n * 2번째 위치에 설치합니다. 그다음은 n * 3, 그다음은 n * 4, …로 진행합니다.만약 기존에 블록이 깔려있는 자리라면 그 블록을빼고 새로운 블록으로 집어넣습니다. 예를 들어 1번 블록은 2,3,4,5, … 인 위치에 우선 설치합니다. 그다음 2번 블록은 4,6,8,10, … 인 위치에 설치하고, 3번 블록은 6,9,12… 인 위치에 설치합니다. 이렇게 3번 블록까지 설치하고 나면 첫 10개의 블록은 0, 1, 1, 2, 1, 3, 1, 2, 3, 2이됩니다. 그렙시는 길이가 1,000,000,000인 도로에 1번 블록부터 시작하여 10,000,000번 블록까지 위의 규칙으로 모두 놓았습니다. 그렙시의 시장님은 특정 구간의 어떤 블록이 깔려 있는지 알고 싶습니다. 구간을 나타내는 두 수 begin, end 가 매개변수로 주어 질 때, 그 구간에 깔려 있는 블록의 숫자 배열(리스트)을 return하는 solution 함수를 완성해 주세요. 풀이: begin 부터 end 까지 순회한다. i가 소수라면 1을 푸쉬한다. i가 1이라면 0을 푸쉬한다. i가 둘 다 아니라면, i의 약수 중 i를 제외한 최댓값을 푸쉬한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; vector\u003cint\u003e solution(long long begin, long long end) { vector\u003cint\u003e answer; for(long long i = begin; i \u003c= end; i++){ int n = 0; for(long long t = 2; t \u003c= sqrt(i); t++) if(!(i % t)){ n = i / t; break; } if(i != 1 \u0026\u0026 !n) n = 1; answer.push_back(n); } return answer; } ","date":"2020-02-08","objectID":"/2020-02-08-numblock/:0:0","tags":["algorithm","C++","Level 4"],"title":"[프로그래머스]숫자 블록","uri":"/2020-02-08-numblock/"},{"categories":["Learn"],"content":"learn","date":"2020-02-07","objectID":"/2020-02-07-transform/","tags":["Learn","C++","문자열"],"title":"[C++]transform","uri":"/2020-02-07-transform/"},{"categories":["Learn"],"content":"transform #include\u003calgorithm\u003e 사용하기 위해서는 algorithm을 include해준다. 기본적인 사용법은 이렇게된다. transform(a.begin(), a.end(), a.begin(), fuc()); // transform(시작주소, 끝 주소, 저장할 곳의 시작 주소, 함수); ex) 배열 a의 모든 값을 3씩 증가시키기 #include \u003ciostream\u003e #include \u003cvector\u003e#include \u003calgorithm\u003e using namespace std; int func(int n) { return n + 3; } int main() { vector\u003cint\u003e a; for(int i = 0; i \u003c 5; i++) a.push_back(i); transform(a.begin(), a.end(), a.begin(), func); for(int i : a) cout \u003c\u003c i \u003c\u003c endl; return 0; } 출력) 3 4 5 6 7 ex) 문자열 배열 a에 모든 값을 대문자로 바꾸기 #include \u003ciostream\u003e #include \u003cvector\u003e#include \u003cstring\u003e#include \u003calgorithm\u003e using namespace std; int main() { vector\u003cstring\u003e a = { \"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\" ,\"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\" }; transform(a.begin(), a.end(), a.begin(), toupper); for(string s : a) cout \u003c\u003c s \u003c\u003c endl; return 0; } 출력) JEJU PANGYO SEOUL JEJU PANGYO SEOUL JEJU PANGYO SEOUL ","date":"2020-02-07","objectID":"/2020-02-07-transform/:0:0","tags":["Learn","C++","문자열"],"title":"[C++]transform","uri":"/2020-02-07-transform/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-07","objectID":"/2020-02-07-cardgame/","tags":["algorithm","C++","DP","Level 4"],"title":"[프로그래머스]카드 게임","uri":"/2020-02-07-cardgame/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 카드게임이 있다. 게임에 사용하는 각 카드에는 양의 정수 하나가 적혀있고 같은 숫자가 적힌 카드는 여러 장 있을 수 있다. 게임방법은 우선 짝수개의 카드를 무작위로 섞은 뒤 같은 개수의 두 더미로 나누어 하나는 왼쪽에 다른 하나는 오른쪽에 둔다. 각 더미의 제일 위에 있는 카드끼리 서로 비교하며 게임을 한다. 게임 규칙은 다음과 같다. 지금부터 왼쪽 더미의 제일 위 카드를 왼쪽 카드로, 오른쪽 더미의 제일 위 카드를 오른쪽 카드로 부르겠다. 1. 언제든지 왼쪽 카드만 통에 버릴 수도 있고 왼쪽 카드와 오른쪽 카드를 둘 다 통에 버릴 수도 있다. 이때 얻는 점수는 없다. 2. 오른쪽 카드에 적힌 수가 왼쪽 카드에 적힌 수보다 작은 경우에는 오른쪽 카드만 통에 버릴 수도 있다. 오른쪽 카드만 버리는 경우에는 오른쪽 카드에 적힌 수만큼 점수를 얻는다. 3. (1)과 (2)의 규칙에 따라 게임을 진행하다가 어느 쪽 더미든 남은 카드가 없다면 게임이 끝나며 그때까지 얻은 점수의 합이 최종 점수가 된다. 왼쪽 더미의 카드에 적힌 정수가 담긴 배열 left와 오른쪽 더미의 카드에 적힌 정수가 담긴 배열 right가 매개변수로 주어질 때, 얻을 수 있는 최종 점수의 최대값을 return 하도록 solution 함수를 작성하시오. 풀이: DP[i][t]를 왼쪽이 i번째, 오른쪽이 t번째가 맨 위에 있을 때, 얻을 수 있는 점수의 최댓값이라 하자. i와 t를 0부터 각각 left size, right size 까지 반복한다. 이 때, -1 일 경우 왼쪽과 오른쪽이 i, t 인 경우의 수를 만들 수 없다는 뜻이므로 하지않는다. right[t] 가 left[i] 보다 작다면, 점수를 얻으므로 DP[i][t] 에 right[t] 만큼 더해준다. 그리고 오른쪽 하나를 버리므로 DP[i][t + 1] 값에 DP[i][t] 와 DP[i][t + 1] 의 최댓값을 넣어준다. right[t] 가 left[i] 보다 크거나 같다면, 왼쪽을 버리거나 둘 다 버려야 하므로, 둘 다 버릴 때인 DP[i + 1][t + 1] 에 DP[i + 1][t] 와 DP[i][t] 의 최댓값을 넣어주고, 왼쪽 하나 버릴 때인DP[i + 1][t] 에 DP[i][t] 값을 넣어준다. 최대 점수를 찾아야 하므로 answer에 DP[i][t] 값과 현재 answer값 중 최댓값을 저장해 놓는다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(vector\u003cint\u003e left, vector\u003cint\u003e right) { vector\u003cvector\u003cint\u003e\u003e a(left.size() + 1, vector\u003cint\u003e(right.size() + 1, -1)); a[0][0] = 0; int answer = 0; for (int i = 0; i \u003c left.size(); i++) { for (int t = 0; t \u003c right.size(); t++) { if (a[i][t] != -1) { if (right[t] \u003c left[i]) { a[i][t] += right[t]; a[i][t + 1] = max(a[i][t + 1], a[i][t]); } else { a[i + 1][t + 1] = max(a[i + 1][t], a[i][t]) a[i + 1][t] = a[i][t]; } } answer = max(answer, a[i][t]); } } return answer; } ","date":"2020-02-07","objectID":"/2020-02-07-cardgame/:0:0","tags":["algorithm","C++","DP","Level 4"],"title":"[프로그래머스]카드 게임","uri":"/2020-02-07-cardgame/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-06","objectID":"/2020-02-06-3xn/","tags":["algorithm","C++","Level 4"],"title":"[프로그래머스]3 X n 타일링","uri":"/2020-02-06-3xn/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 3이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다 타일을 가로로 배치 하는 경우 타일을 세로로 배치 하는 경우 예를들어서 n이 8인 직사각형은 다음과 같이 채울 수 있습니다. 직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요. 풀이: 가로의 길이가 홀수라면 타일을 놓을 수 없으므로 제외한다. 짝 수일때, 가로의 길이가 n이라면 a[n / 2] = 3 * a[(n / 2) - 1] + 2 * (a[(n / 2) - 2] 까지의 합) 으로 나타낼 수 있다. 이 때, 경우의 수가 매우 크므로 1,000,000,007로 나눈 나머지를 출력하도록 한다. 또한, 자료형을 long long으로 바꾸도록 하자. a[n / 2] = 4 * a[(n / 2) - 1] - a[(n / 2) - 2] 로도 풀 수 있으나, 수가 매우 커지면서 4 * a[(n / 2) - 1] \u003c a[(n / 2) - 2] 이 되는 경우의 수가 생기게 되어 마이너스 값이 나올 수 있으므로 이렇게 풀지 말자. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int n) { vector\u003clong long\u003e a = {1, 3}; long long sum = 0; if(n % 2) return 0; for(int i = 2; i \u003c= n / 2; i++){ sum += a[i - 2] % 1000000007; a.push_back((3 * a[i - 1] + 2 * sum) % 1000000007); } return a[n / 2]; } ","date":"2020-02-06","objectID":"/2020-02-06-3xn/:0:0","tags":["algorithm","C++","Level 4"],"title":"[프로그래머스]3 X n 타일링","uri":"/2020-02-06-3xn/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-05","objectID":"/2020-02-05-overtimeindex/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]야근 지수","uri":"/2020-02-05-overtimeindex/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요. 풀이: 작업량 works에 들어있는 값 중 최댓값에서 1을 빼는 작업을 퇴근 까지 남은 시간인 N시간 만큼 반복한다. 최댓값이 0이라면 반복을 중지한다. 반복이 끝났을 떄, works에 들어있는 남은 작업량을 제곱한 값을 모두 더해 answer에 넣은 후 return 한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; long long solution(int n, vector\u003cint\u003e works) { priority_queue\u003cint\u003e a; long long answer = 0; for (int i : works) a.push(i); while (a.top() \u0026\u0026 n) { int m = a.top(); a.pop(); m--; n--; a.push(m); } while (!a.empty()) { answer += a.top() * a.top(); a.pop(); } return answer; } ","date":"2020-02-05","objectID":"/2020-02-05-overtimeindex/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]야근 지수","uri":"/2020-02-05-overtimeindex/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-04","objectID":"/2020-02-04-longjump/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]멀리 뛰기","uri":"/2020-02-04-longjump/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는 (1칸, 1칸, 1칸, 1칸) (1칸, 2칸, 1칸) (1칸, 1칸, 2칸) (2칸, 1칸, 1칸) (2칸, 2칸) 의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다. 풀이: 1칸 있을 때, 1가지, 2칸 있을 때, 2가가지, 3칸 있을 때, 1칸의 가짓수+ 2칸의 가짓수 = 3칸 …… n칸 있을 때, (n - 1)칸의 가짓수 + (n - 2)칸의 가짓수 수가 너무 크게 증가할 수 있으므로 1234567로 나눈 나머지를 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; long long solution(int n) { vector\u003clong long\u003e a = { 0, 1, 2 }; for(int i = 3; i \u003c= n; i++) a[i % 3] = (a[(i - 1) % 3] + a[(i - 2) % 3]) % 1234567; return a[n % 3]; } ","date":"2020-02-04","objectID":"/2020-02-04-longjump/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]멀리 뛰기","uri":"/2020-02-04-longjump/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-03","objectID":"/2020-02-03-nextbignum/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]다음 큰 숫자","uri":"/2020-02-03-nextbignum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다. 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다. 예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다. 자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요. 풀이: 자연수 n을 2의 배수들로 표현한 배열 b를 만든다. (제일 첫번째 원소가 가장 큼) 배열 b의 마지막 원소부터 b[i] * 2 != b[i - 1] 인 위치를 찾는다. 찾았다면 b[i]값을 x2해주고, i까지의 모든 값을 1, 2, 4…. 2의 배수로 순서대로 바꿔준다. 만약 i가 0이될 때 까지 순환했다면 b[i] 값으로 위에처럼 해준다. 바뀐 배열의 값들을 모두 더해 return한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int n) { int a = 2; vector\u003cint\u003e b; while (a \u003c n) a *= 2; while (n) { while (a \u003e n) a /= 2; b.push_back(a); n -= a; } a = 1; for (int i = b.size() - 1; i \u003e= 0; i--) { if (!i || b[i] * 2 != b[i - 1]) { b[i] *= 2; for (int t = b.size() - 1; t \u003e i; t--) { b[t] = a; a *= 2; } break; } } for (int i : b) n += i; return n; } ","date":"2020-02-03","objectID":"/2020-02-03-nextbignum/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]다음 큰 숫자","uri":"/2020-02-03-nextbignum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-02","objectID":"/2020-02-02-howtolineup/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]줄 서는 방법","uri":"/2020-02-02-howtolineup/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: n명의 사람이 일렬로 줄을 서고 있습니다. n명의 사람들에게는 각각 1번부터 n번까지 번호가 매겨져 있습니다. n명이 사람을 줄을 서는 방법은 여러가지 방법이 있습니다. 예를 들어서 3명의 사람이 있다면 다음과 같이 6개의 방법이 있습니다. [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1] 사람의 수 n과, 자연수 k가 주어질 때, 사람을 나열 하는 방법을 사전 순으로 나열 했을 때, k번째 방법을 return하는 solution 함수를 완성해주세요. 풀이: 1 ~ n 까지의 숫자를 저장한 배열을 만든다. 저장한 배열의 (k - 1) / (n - 1)! 번째 숫자를 answer에 push한다. 저장한 숫자를 배열에서 지운다. k를 (n - 1)! 로 나눈 나머지로 바꾼다. n을 -1 해준다. 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 각 자릿수를 n이라고 했을 때, (맨 오른쪽을 1이라고 한다.) 각 자릿수의 값은 (n - 1)! 마다 변하게 된다. 즉 (n - 1)! 의 배수를 확인한다면 맨 앞자리를 구할 수 있다. 그 후 맨 앞자리를 없앤 후 계속 반복한다면 k번째 방법을 구할 수 있다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003eusing namespace std; vector\u003cint\u003e solution(int n, long long k) { vector\u003cint\u003e answer; vector\u003cint\u003e a; long long m = 1; for(int i = 1; i \u003c= n; i++){ a.push_back(i); m *= i; } while(n){ m /= n; long long num = !k ? n - 1 : (k - 1) / m; answer.push_back(a[num]); a.erase(a.begin() + num); k %= m; n--; } return answer; } ","date":"2020-02-02","objectID":"/2020-02-02-howtolineup/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]줄 서는 방법","uri":"/2020-02-02-howtolineup/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-02-01","objectID":"/2020-02-01-biggestnum/","tags":["algorithm","C++","Level 2","정렬"],"title":"[프로그래머스]가장 큰 수","uri":"/2020-02-01-biggestnum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요. 풀이: int 배열을 string으로 바꿔서 정렬한다. string[1] + string[0] \u003e string[0] + string[1] 이라면 string[0]과 string[1] 값을 바꿔준다. 전체적으로 가장 큰 수가 될때까지 반복한다. 마지막에 0000같은 수가 나올 수 있으므로 맨 앞자리가 0이라면 “0\"을 return 하도록 해준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; string solution(vector\u003cint\u003e numbers) { vector\u003cstring\u003e a; for (int i : numbers) a.push_back(to_string(i)); sort(a.begin(), a.end(), greater\u003cstring\u003e()); string answer; for (int i = 0; i \u003c numbers.size() - 1; i++) { if (a[i + 1] + a[i] \u003e a[i] + a[i + 1]) { swap(a[i], a[i + 1]); if (!i) i = -1; else i -= 2; } } for (string s : a) answer += s; if(answer[0] == '0') return \"0\"; return answer; } 더 나은 코드: 사용언어 : c++ #include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003cvector\u003e using namespace std; bool compare(const string \u0026a, const string \u0026b) { if (b + a \u003c a + b) return true; return false; } string solution(vector\u003cint\u003e numbers) { string answer = \"\"; vector\u003cstring\u003e strings; for (int i : numbers) strings.push_back(to_string(i)); sort(strings.begin(), strings.end(), compare); for (auto iter = strings.begin(); iter \u003c strings.end(); ++iter) answer += *iter; if (answer[0] == '0') answer = \"0\"; return answer; } ","date":"2020-02-01","objectID":"/2020-02-01-biggestnum/:0:0","tags":["algorithm","C++","Level 2","정렬"],"title":"[프로그래머스]가장 큰 수","uri":"/2020-02-01-biggestnum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-31","objectID":"/2020-01-31-findprimnum/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]소수 찾기","uri":"/2020-01-31-findprimnum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 풀이: 문자열 numbers로 만들 수 있는 모든 순열을 set에 넣는다. (중복된 숫자를 거르기 위함) set에 들어있는 수들을 모두 순회하여 소수라면 answer값을 +1 해준다. (맨 처음에 sort를 하지않을 경우 실패가 뜨는데 왜 그런지는 잘 모르겠다.) 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003calgorithm\u003eusing namespace std; int solution(string numbers) { int answer = 0; set\u003cint\u003ea; sort(numbers.begin(),numbers.end()); do { for (int i = 1; i \u003c= numbers.size(); ++i) a.insert(stoi(numbers.substr(0, i))); } while (next_permutation(numbers.begin(), numbers.end())); for (set\u003cint\u003e::iterator ite = a.begin(); ite != a.end(); ite++) { bool b = true; for (int i = 2; i \u003c= sqrt(*ite); i++) { if (!(*ite % i)) { b = false; break; } } if (*ite != 0 \u0026\u0026 *ite != 1 \u0026\u0026 b) answer++; } return answer; } ","date":"2020-01-31","objectID":"/2020-01-31-findprimnum/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]소수 찾기","uri":"/2020-01-31-findprimnum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-30","objectID":"/2020-01-30-openchating/","tags":["algorithm","C++","Level 2","문자열 분리"],"title":"[프로그래머스]오픈 채팅방","uri":"/2020-01-30-openchating/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다. 신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다. [닉네임]님이 들어왔습니다. 채팅방에서 누군가 나가면 다음 메시지가 출력된다. [닉네임]님이 나갔습니다. 채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다. 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다. 채팅방에서 닉네임을 변경한다. 닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다. 예를 들어, 채팅방에 Muzi와 Prodo라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다. Muzi님이 들어왔습니다. Prodo님이 들어왔습니다. 채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다. Muzi님이 들어왔습니다. Prodo님이 들어왔습니다. Muzi님이 나갔습니다. Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다. Prodo님이 들어왔습니다. Prodo님이 들어왔습니다. Prodo님이 나갔습니다. Prodo님이 들어왔습니다. 채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다. Prodo님이 들어왔습니다. Ryan님이 들어왔습니다. Prodo님이 나갔습니다. Prodo님이 들어왔습니다. 채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라. 풀이: 문자열을 공백을 기준으로 분리한다. 첫번째 문자열이 Enter 이거나 Change라면 두번째 문자열인 id에 매칭되어있는 닉네임을 세번째 문자열로 교체해준다. 다시 맨 처음으로 가서 공백을 기준으로 분리한 후 id에 매칭되어있는 닉네임을 string에 저장한다. 첫번째 문자열이 Enter라면, string에 “님이 들어왔습니다.” 를 추가한다. 첫번째 문자열이 Leave라면, string에 “님이 나갔습니다.” 를 추가한다. 만들어진 string을 answer에 push한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003csstream\u003e#include \u003cmap\u003eusing namespace std; vector\u003cstring\u003e solution(vector\u003cstring\u003e record) { vector\u003cstring\u003e answer; map\u003cstring, string\u003e m; vector\u003cvector\u003cstring\u003e\u003e r(record.size(), vector\u003cstring\u003e(3)); for (int i = 0; i \u003c record.size(); i++) { stringstream c(record[i]); c \u003e\u003e r[i][0]; c \u003e\u003e r[i][1]; if (r[i][0] == \"Enter\" || r[i][0] == \"Change\") { c \u003e\u003e r[i][2]; m[r[i][1]] = r[i][2]; } } for (int i = 0; i \u003c record.size(); i++) { string s = m[r[i][1]]; if (r[i][0] == \"Enter\") s += \"님이 들어왔습니다.\"; else if (r[i][0] == \"Leave\") s += \"님이 나갔습니다.\"; else continue; answer.push_back(s); } return answer; } ","date":"2020-01-30","objectID":"/2020-01-30-openchating/:0:0","tags":["algorithm","C++","Level 2","문자열 분리"],"title":"[프로그래머스]오픈 채팅방","uri":"/2020-01-30-openchating/"},{"categories":["Learn"],"content":"learn","date":"2020-01-29","objectID":"/2020-01-29-sort/","tags":["Learn","C++","정렬"],"title":"[C++]정렬","uri":"/2020-01-29-sort/"},{"categories":["Learn"],"content":"정렬 ( sort ) #include\u003calgorithm\u003e 사용하기 위해서는 algorithm을 include해준다. 기본적인 사용법은 이렇게된다. sort(a.begin(), a.end()); 기본적인 방식은 오름차순 정렬이다. 정렬의 방식을 바꾸기 위해서는 다음과 같은 방식을 사용한다. sort(a.begin(), a.end(), compare); 이 때, compare 함수는 따로 만들어 주어야한다. 예를들어 내림차 순으로 정렬하기 위해서는 bool compare(int a, int b){ return a \u003e b; } 과 같이 만들어 주면 된다. 이를 응용한다면 bool compare(pair\u003cint, int\u003e a, pair\u003cint, int\u003e b){ return a.second \u003e b.second; } 과 같이 응용할 수도 있다. ","date":"2020-01-29","objectID":"/2020-01-29-sort/:0:0","tags":["Learn","C++","정렬"],"title":"[C++]정렬","uri":"/2020-01-29-sort/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-29","objectID":"/2020-01-29-makeprimenum/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]소수 만들기","uri":"/2020-01-29-makeprimenum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요. 풀이: 3개의 숫자를 더한 값이 소수인지 아닌지 판별 후 소수라면 answer을 +1 해준다. 코드: 사용언어 : c++ #include \u003cvector\u003e#include \u003ciostream\u003e#include \u003cmath.h\u003eusing namespace std; int solution(vector\u003cint\u003e nums) { int answer = 0; for(int i = 0;i \u003c nums.size() - 2;i++) for(int t = i + 1;t \u003c nums.size() - 1;t++) for(int y = t + 1;y \u003c nums.size();y++){ bool b = true; for(int u = 2;u \u003c= sqrt(nums[i] + nums[t] + nums[y]);u++){ if((nums[i] + nums[t] + nums[y]) % u == 0){ b = false; break; } } if(b) answer++; } return answer; } ","date":"2020-01-29","objectID":"/2020-01-29-makeprimenum/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]소수 만들기","uri":"/2020-01-29-makeprimenum/"},{"categories":["Learn"],"content":"learn","date":"2020-01-28","objectID":"/2020-01-28-next_permutation/","tags":["Learn","C++","순열"],"title":"[C++]순열 ","uri":"/2020-01-28-next_permutation/"},{"categories":["Learn"],"content":"순열 ( next_permutation ) #include\u003ciostream\u003e#include\u003cstring\u003e#include\u003calgorithm\u003eusing namespace std; int main() { string str = \"123\"; sort(str.begin(), str.end()); do { for (int i = 1; i \u003c= str.size(); ++i) { int n = stoi(str.substr(0, i)); cout \u003c\u003c n \u003c\u003c endl; } }while (next_permutation(str.begin(), str.end())); return 0; } 출력 : 1 12 123 1 13 132 2 21 213 2 23 231 3 31 312 3 32 321 ","date":"2020-01-28","objectID":"/2020-01-28-next_permutation/:0:0","tags":["Learn","C++","순열"],"title":"[C++]순열 ","uri":"/2020-01-28-next_permutation/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-28","objectID":"/2020-01-28-matrixmultiplication/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]행렬의 곱셈","uri":"/2020-01-28-matrixmultiplication/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 2차원 행렬 arr1과 arr2를 입력받아, arr1에 arr2를 곱한 결과를 반환하는 함수, solution을 완성해주세요. 풀이: arr1의 가로행과 arr2의 세로열의 값들을 각각 곱한것을 더한 값을 a에 저장한다. 저장된 배열 a를 answer에 푸쉬 한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cvector\u003cint\u003e\u003e solution(vector\u003cvector\u003cint\u003e\u003e arr1, vector\u003cvector\u003cint\u003e\u003e arr2) { vector\u003cvector\u003cint\u003e\u003e answer; for (int i = 0; i \u003c arr1.size(); i++){ vector\u003cint\u003ea; for (int t = 0; t \u003c arr2[0].size(); t++){ int sum = 0; for (int y = 0; y \u003c arr1[0].size(); y++) sum += arr1[i][y] * arr2[y][t]; a.push_back(sum); } answer.push_back(a); } return answer; } ","date":"2020-01-28","objectID":"/2020-01-28-matrixmultiplication/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]행렬의 곱셈","uri":"/2020-01-28-matrixmultiplication/"},{"categories":["Learn"],"content":"learn","date":"2020-01-27","objectID":"/2020-01-27-stringstream/","tags":["Learn","C++","문자열 분리"],"title":"[C++]문자열 분리 ","uri":"/2020-01-27-stringstream/"},{"categories":["Learn"],"content":"stringstream - 공백을 기준으로 분리 stringstream s_stream(string a); s_stream에 a에 있는 문장을 공백을 기준으로 분리해서 넣는다. #include \u003csstream\u003e 사용하기 위해서는 sstream을 include해서 사용하자. string a = \"a b c d\"; stringstream s_stream(a); string c; while(s_stream \u003e\u003e c){ cout \u003c\u003c c \u003c\u003c endl; } 출력 : a b c d ","date":"2020-01-27","objectID":"/2020-01-27-stringstream/:1:0","tags":["Learn","C++","문자열 분리"],"title":"[C++]문자열 분리 ","uri":"/2020-01-27-stringstream/"},{"categories":["Learn"],"content":"strtok - 주어진 문자를 기준으로 분리 strtok(char* a, char* b); a를 b를 기준으로 분리한다. 이때, b는 한 단어가 아닌 문장이어도 성립한다. ex) char a[] = \"abcd1efg hijk2lmn\"; char b[] = \" 12\"; char *token; token = strtok(a, b); do{ cout \u003c\u003c token \u003c\u003c endl; }while(token = strtok(NULL, b)); 출력 : abcd efg hijk lmn ","date":"2020-01-27","objectID":"/2020-01-27-stringstream/:2:0","tags":["Learn","C++","문자열 분리"],"title":"[C++]문자열 분리 ","uri":"/2020-01-27-stringstream/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-27","objectID":"/2020-01-27-ramenfactory/","tags":["algorithm","C++","힙","Level 2"],"title":"[프로그래머스]라면공장","uri":"/2020-01-27-ramenfactory/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 라면 공장에서는 하루에 밀가루를 1톤씩 사용합니다. 원래 밀가루를 공급받던 공장의 고장으로 앞으로 k일 이후에야 밀가루를 공급받을 수 있기 때문에 해외 공장에서 밀가루를 수입해야 합니다. 해외 공장에서는 향후 밀가루를 공급할 수 있는 날짜와 수량을 알려주었고, 라면 공장에서는 운송비를 줄이기 위해 최소한의 횟수로 밀가루를 공급받고 싶습니다. 현재 공장에 남아있는 밀가루 수량 stock, 밀가루 공급 일정(dates)과 해당 시점에 공급 가능한 밀가루 수량(supplies), 원래 공장으로부터 공급받을 수 있는 시점 k가 주어질 때, 밀가루가 떨어지지 않고 공장을 운영하기 위해서 최소한 몇 번 해외 공장으로부터 밀가루를 공급받아야 하는지를 return 하도록 solution 함수를 완성하세요. dates[i]에는 i번째 공급 가능일이 들어있으며, supplies[i]에는 dates[i] 날짜에 공급 가능한 밀가루 수량이 들어 있습니다. 풀이: dates가 현재 stock 보다 작을 때, supplies 값이 가장 큰 값을 stock에 더해주고, answer 값을 +1 해준다. 밀가루를 사용할 수 있는 만큼 최대한 사용한다고 가정하고, 그렇게 사용했을 때, 가장 많이 공급 받을 수 있는 양을 받아야 공급 횟수가 가장 적어진다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int solution(int stock, vector\u003cint\u003e dates, vector\u003cint\u003e supplies, int k) { int answer = 0, c = 0; priority_queue\u003cint\u003ea; while (stock \u003c= k - 1) { while(c \u003c dates.size() \u0026\u0026 dates[c] \u003c= stock){ a.push(supplies[c]); c++; } stock += a.top(); a.pop(); answer++; } return answer; } ","date":"2020-01-27","objectID":"/2020-01-27-ramenfactory/:0:0","tags":["algorithm","C++","힙","Level 2"],"title":"[프로그래머스]라면공장","uri":"/2020-01-27-ramenfactory/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-26","objectID":"/2020-01-26-removeminnum/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]제일 작은 수 제거하기","uri":"/2020-01-26-removeminnum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다. 풀이: arr에서 제일 작은 수를 찾아 삭제한다. 만약 arr이 비었다면 -1을 넣는다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003eusing namespace std; vector\u003cint\u003e solution(vector\u003cint\u003e arr) { int min = arr[0], c = 0; for(int i = 1; i \u003c arr.size(); i++){ if(min \u003e arr[i]){ min = arr[i]; c = i; } } arr.erase(arr.begin() + c); if(arr.empty()) arr.push_back(-1); return arr; } ","date":"2020-01-26","objectID":"/2020-01-26-removeminnum/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]제일 작은 수 제거하기","uri":"/2020-01-26-removeminnum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-25","objectID":"/2020-01-25-ractanglestar/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]직사각형 별찍기","uri":"/2020-01-25-ractanglestar/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 이 문제에는 표준 입력으로 두 개의 정수 n과 m이 주어집니다. 별(*) 문자를 이용해 가로의 길이가 n, 세로의 길이가 m인 직사각형 형태를 출력해보세요. 풀이: n번 별을 찍는다. 개행한다. 그것을 m번 반복한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e using namespace std; int main(void) { int a, b; cin \u003e\u003e a \u003e\u003e b; for (int i = 0; i \u003c b; i++){ for (int t = 0; t \u003c a; t++){ cout \u003c\u003c '*'; } cout \u003c\u003c endl; } return 0; } ","date":"2020-01-25","objectID":"/2020-01-25-ractanglestar/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]직사각형 별찍기","uri":"/2020-01-25-ractanglestar/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-24","objectID":"/2020-01-24-integersort/","tags":["algorithm","C++","정렬","Level 1"],"title":"[프로그래머스]정수 내림차순으로 배치하기","uri":"/2020-01-24-integersort/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다. 풀이: 정수 n을 string 에 담는다. 담아진 string 을 내림차순으로 정렬한다. string을 long long 값으로 변환 후 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; long long solution(long long n) { string a = to_string(n); sort(a.begin(), a.end(), greater\u003cchar\u003e()); return stoull(a); } ","date":"2020-01-24","objectID":"/2020-01-24-integersort/:0:0","tags":["algorithm","C++","정렬","Level 1"],"title":"[프로그래머스]정수 내림차순으로 배치하기","uri":"/2020-01-24-integersort/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-23","objectID":"/2020-01-23-h-index/","tags":["algorithm","C++","정렬","Level 2"],"title":"[프로그래머스]H-index","uri":"/2020-01-23-h-index/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h가 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 풀이: 논문 n편을 정렬한다. 1번째 논문이 1보다 크다면 H-index는 1이 된다. 2번째 논문이 2보다 크다면 H-index는 2가 된다. ​ . ​ . (n - 1) / 2 번째 논문이 (n - 1) / 2 보다 크다면 H-index는 (n - 1) / 2가 된다. 이렇게 반복했을 때, 가장 큰 H-index값을 return한다. 논문의 인용횟수가 100이든 1000이든 H-index는 n값을 넘을 수 없다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(vector\u003cint\u003e citations) { int answer = 0; int s = citations.size(); sort(citations.begin(), citations.end()); for (int i = 0; i \u003c= (s - 1) / 2; i++) answer = max(answer, min(citations[i], s - i)); return answer; } ","date":"2020-01-23","objectID":"/2020-01-23-h-index/:0:0","tags":["algorithm","C++","정렬","Level 2"],"title":"[프로그래머스]H-index","uri":"/2020-01-23-h-index/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-22","objectID":"/2020-01-22-matrixsum/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]행렬의 덧셈","uri":"/2020-01-22-matrixsum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요. 풀이: 각 행렬의 같은 행 같은 열을 더한 행렬을 출력한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cvector\u003cint\u003e\u003e solution(vector\u003cvector\u003cint\u003e\u003e arr1, vector\u003cvector\u003cint\u003e\u003e arr2) { for (int i = 0; i \u003c arr1.size(); i++) for(int t = 0; t \u003c arr1[i].size(); t++) arr1[i][t] += arr2[i][t]; return arr1; } ","date":"2020-01-22","objectID":"/2020-01-22-matrixsum/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]행렬의 덧셈","uri":"/2020-01-22-matrixsum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-21","objectID":"/2020-01-21-phoneketmon/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]폰켓몬","uri":"/2020-01-21-phoneketmon/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다. 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택 두 번째(1번), 세 번째(2번) 폰켓몬을 선택 두 번째(1번), 네 번째(3번) 폰켓몬을 선택 세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다. 당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요. 풀이: nums 배열에 있는 폰켓몬의 종류 번호 중 중복된 것을 거른 배열을 a라고 한다. nums 배열의 길이(N) / 2 보다 a의 크기가 더 크다면 N / 2 를 리턴한다. 만약 더 작다면 a의 크기를 출력한다. 코드: 사용언어 : c++ #include \u003cvector\u003e#include \u003cset\u003eusing namespace std; int solution(vector\u003cint\u003e nums) { set\u003cint\u003ea(nums.begin(),nums.end()); return a.size() \u003e nums.size() / 2 ? nums.size() / 2 : a.size(); } ","date":"2020-01-21","objectID":"/2020-01-21-phoneketmon/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]폰켓몬","uri":"/2020-01-21-phoneketmon/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-20","objectID":"/2020-01-20-jumpandteleport/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]점프와 순간 이동","uri":"/2020-01-20-jumpandteleport/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요. 예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다. 아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다. 처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다. 처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다. 처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다. 위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다. 풀이: n이 홀수라면 -1 해주고 ans 값을 +1 해준다. n이 짝수라면 2로 나눠준다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int solution(int n) { int ans = 0; while (n) { if (n % 2) { n--; ans++; } else { n /= 2; } } return ans; } ","date":"2020-01-20","objectID":"/2020-01-20-jumpandteleport/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]점프와 순간 이동","uri":"/2020-01-20-jumpandteleport/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-19","objectID":"/2020-01-19-morespicy/","tags":["algorithm","C++","힙","Level 2"],"title":"[프로그래머스]더 맵게","uri":"/2020-01-19-morespicy/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다. 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다. Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요. 풀이: 우선순위 큐에 스코빌 지수들을 넣는다. 큐 top()이 가장 맵지않은 음식의 스코빌 지수이므로 저장해 놓는다. 큐의 top을 pop한다. 이번에 큐의 top은 두번째로 맵지않은 음식의 스코빌 지수이므로 *2해서 저장해 놓은 값에 더한다. 큐의 top을 pop한다. 저장해 놓은 값을 큐에 push한다. answer값을 +1 해준다. 큐의 top이 K값보다 크거나 같다면 모든 음식의 스코빌 지수가 K이상이므로 answer을 return 해준다. 큐의 사이즈가 1이라면 모든 음식의 스코빌 지수를 K이상으로 만들 수 없으므로 -1을 return 해준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int solution(vector\u003cint\u003e scoville, int K) { priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e a(scoville.begin(), scoville.end()); int answer = 0; int c; while (a.top() \u003c K) { if (a.size() == 1) return -1; c = a.top(); a.pop(); c += a.top() * 2; a.pop(); a.push(c); answer++; } return answer; } ","date":"2020-01-19","objectID":"/2020-01-19-morespicy/:0:0","tags":["algorithm","C++","힙","Level 2"],"title":"[프로그래머스]더 맵게","uri":"/2020-01-19-morespicy/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-18","objectID":"/2020-01-18-numbersof124countries/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]124 나라의 숫자","uri":"/2020-01-18-numbersof124countries/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124 나라 10진법 124 나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 풀이: 2진법을 표현하는 방법과 비슷하게 한다. m을 3으로 나눈 나머지를 맨 뒤에 넣는다. m을 3으로 나눈다. 반복한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; string a = \"412\"; string answer; void c(int m) { if (m \u003c= 0) return; if (!(m % 3)) c((m / 3) - 1); else c(m / 3); answer += a[m % 3]; } string solution(int n) { c(n); return answer; } ","date":"2020-01-18","objectID":"/2020-01-18-numbersof124countries/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]124 나라의 숫자","uri":"/2020-01-18-numbersof124countries/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-17","objectID":"/2020-01-17-ironbar/","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]쇠막대기","uri":"/2020-01-17-ironbar/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다. - 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다. - 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다. - 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다. 아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다. 이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다. (a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 '()'으로 표현합니다. 또한 모든 '()'는 반드시 레이저를 표현합니다. (b) 쇠막대기의 왼쪽 끝은 여는 괄호 '('로, 오른쪽 끝은 닫힌 괄호 ')'로 표현됩니다. 위 예의 괄호 표현은 그림 위에 주어져 있습니다. 쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다. 쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요. 풀이: 괄호가 ‘(’ 라면, ​ 다음 괄호가 ‘)’ 일때, answer += 현재 스택에 있는 ‘(’ 의 갯수 ​ 아니라면, 스택에 ‘(’ 를 푸쉬 괄호가 ‘)’ 라면 ​ 스택 맨 위에 ‘(’ 를 팝 ​ answer 에 값을 +1 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cstack\u003eusing namespace std; int solution(string arrangement) { int answer = 0; stack\u003cchar\u003e a; for (int i = 0; i \u003c arrangement.size(); i++) if (arrangement[i] == '(') { if (i + 1 \u003c arrangement.size() \u0026\u0026 arrangement[i + 1] == ')') { answer += a.size(); i++; } else a.push(arrangement[i]); } else { a.pop(); answer++; } return answer; } ","date":"2020-01-17","objectID":"/2020-01-17-ironbar/:0:0","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]쇠막대기","uri":"/2020-01-17-ironbar/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-16","objectID":"/2020-01-16-tower/","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]탑","uri":"/2020-01-16-tower/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다. 예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다. 송신 탑(높이) 수신 탑(높이) 5(4) 4(7) 4(7) 2(9) 3(5) 2(9) 2(9) - 1(6) - 맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return 하도록 solution 함수를 작성해주세요. 풀이: 처음 스택에 0값을 집어넣는다. 스택에 탑부터 차례대로 확인해 나간다. 만약 탑의 값이 높이 값보다 크다면 높이값에 위치를 answer과 스택에 푸쉬한다. 만약 탑의 값이 높이값보다 작거나 같다면, pop한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cstack\u003eusing namespace std; vector\u003cint\u003e solution(vector\u003cint\u003e heights) { vector\u003cint\u003e answer; stack\u003cpair\u003cint, int\u003e\u003e a; a.push(pair\u003cint, int\u003e(0, 0)); for (int i = 0; i \u003c heights.size(); i++) { while (1) if (a.top().first \u003e heights[i] || a.top().second == 0) break; else a.pop(); answer.push_back(a.top().second); a.push(pair\u003cint, int\u003e(heights[i], i + 1)); } return answer; } ","date":"2020-01-16","objectID":"/2020-01-16-tower/:0:0","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]탑","uri":"/2020-01-16-tower/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-15","objectID":"/2020-01-15-scale/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]저울","uri":"/2020-01-15-scale/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 합니다. 이 저울의 양팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같습니다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있습니다. 저울추가 담긴 배열 weight가 매개변수로 주어질 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 return 하도록 solution 함수를 작성해주세요. 예를 들어, 무게가 각각 [3, 1, 6, 2, 7, 30, 1]인 7개의 저울추를 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21입니다. 풀이: 추의 무게가 들어있는 배열을 정렬한다. 0 ~ i 까지의 추의 합 + 1이 i + 1보다 작다면, 0 ~ i 까지의 추의 합 + 1 을 리턴한다. (+ 1 을 해준 이유는 0 ~ i 까지의 합이 (i + 1) - 1 일 경우 최솟값이 i + 1이 될 수는 없기 때문에) 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(vector\u003cint\u003e weight) { sort(weight.begin(), weight.end()); int c = 0; for (int i = 0; i \u003c weight.size(); i++) { c += weight[i]; if (c + 1 \u003c weight[i + 1]) break; } return c + 1; } ","date":"2020-01-15","objectID":"/2020-01-15-scale/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]저울","uri":"/2020-01-15-scale/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-14","objectID":"/2020-01-14-stringdescendingsort/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]문자열 내림차순으로 배치하기","uri":"/2020-01-14-stringdescendingsort/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요. s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다. 풀이: 주어진 문자열을 내림차순으로 정렬한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; string solution(string s) { sort(s.begin(), s.end(), greater\u003cchar\u003e()); return s; } ","date":"2020-01-14","objectID":"/2020-01-14-stringdescendingsort/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]문자열 내림차순으로 배치하기","uri":"/2020-01-14-stringdescendingsort/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-13","objectID":"/2020-01-13-mocktest/","tags":["algorithm","C++","완전탐색","Level 1"],"title":"[프로그래머스]모의고사","uri":"/2020-01-13-mocktest/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, … 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, … 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 풀이: 각각의 수포자들이 찍는 방식대로 모두 탐색한다. 맞춘 갯수의 최댓값을 저장해 놓는다. 최댓값과 맞춘 갯수가 같은 수포자를 answer에 푸쉬한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003eusing namespace std; vector\u003cint\u003e solution(vector\u003cint\u003e answers) { vector\u003cvector\u003cint\u003e\u003e a = { { 1,2,3,4,5 }, { 2,1,2,3,2,4,2,5 }, { 3,3,1,1,2,2,4,4,5,5 } }; vector\u003cint\u003e d(3, 0); vector\u003cint\u003e answer; int m = 0; for (int i = 0; i \u003c answers.size(); i++) { for (int t = 0; t \u003c 3; t++) { if (answers[i] == a[t][i % a[t].size()]) { d[t]++; m = max(m, d[t]); } } } for (int i = 0; i \u003c 3; i++) if (d[i] == m) answer.push_back(i + 1); return answer; } ","date":"2020-01-13","objectID":"/2020-01-13-mocktest/:0:0","tags":["algorithm","C++","완전탐색","Level 1"],"title":"[프로그래머스]모의고사","uri":"/2020-01-13-mocktest/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-12","objectID":"/2020-01-12-inttriangle/","tags":["algorithm","C++","DP","Level 3"],"title":"[프로그래머스]정수 삼각형","uri":"/2020-01-12-inttriangle/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다. 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요. 풀이: DP[i][t] : i 줄 t 위치에서의 최댓값 DP[i][t] = max(DP[i - 1][t - 1], DP[i - 1][t]) answer값과 현재 최댓값중 큰 값을 answer에 저장하며, 최댓값을 찾아간다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(vector\u003cvector\u003cint\u003e\u003e triangle) { int answer = triangle[0][0]; for (int i = 1; i \u003c triangle.size();i++) { for (int t = 0; t \u003c triangle[i].size(); t++) { triangle[i][t] += max(triangle[i - 1][t - 1], triangle[i - 1][t]); answer = max(answer, triangle[i][t]); } } return answer; } ","date":"2020-01-12","objectID":"/2020-01-12-inttriangle/:0:0","tags":["algorithm","C++","DP","Level 3"],"title":"[프로그래머스]정수 삼각형","uri":"/2020-01-12-inttriangle/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-11","objectID":"/2020-01-11-tiledecoration/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]타일 장식물","uri":"/2020-01-11-tiledecoration/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 대구 달성공원에 놀러 온 지수는 최근에 새로 만든 타일 장식물을 보게 되었다. 타일 장식물은 정사각형 타일을 붙여 만든 형태였는데, 한 변이 1인 정사각형 타일부터 시작하여 마치 앵무조개의 나선 모양처럼 점점 큰 타일을 붙인 형태였다. 타일 장식물의 일부를 그리면 다음과 같다. 그림에서 타일에 적힌 수는 각 타일의 한 변의 길이를 나타낸다. 타일 장식물을 구성하는 정사각형 타일 한 변의 길이를 안쪽 타일부터 시작하여 차례로 적으면 다음과 같다. [1, 1, 2, 3, 5, 8, .] 지수는 문득 이러한 타일들로 구성되는 큰 직사각형의 둘레가 궁금해졌다. 예를 들어, 처음 다섯 개의 타일이 구성하는 직사각형(위에서 빨간색으로 표시한 직사각형)의 둘레는 26이다. 타일의 개수 N이 주어질 때, N개의 타일로 구성된 직사각형의 둘레를 return 하도록 solution 함수를 작성하시오. 풀이: 피보나치와 같다. a[n] = a[n - 1] + a[n - 2] 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; long long solution(int N) { vector\u003clong long\u003e a = { 0,4,6 }; for (int i = 3; i \u003c= N; i++) a.push_back(a[i - 1] + a[i - 2]); return a[N]; } ","date":"2020-01-11","objectID":"/2020-01-11-tiledecoration/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]타일 장식물","uri":"/2020-01-11-tiledecoration/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-10","objectID":"/2020-01-10-change/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]거스름돈","uri":"/2020-01-10-change/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다. 예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다. 1원을 5개 사용해서 거슬러 준다. 1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다. 1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다. 5원을 1개 사용해서 거슬러 준다. 거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요. 풀이: 현재 가격 : num 거스름돈 : a num 에서의 경우의 수 = 원래 num에서의 경우의 수 + num - a 에서의 경우의 수 단, 0원일 때, 경우의 수를 1로 만들어 주는 것을 잊지말자. [백준]2293 동전1 같은 문제이므로 참고하자. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cint\u003e a(100001, 0); int solution(int n, vector\u003cint\u003e money) { a[0] = 1; for (int i : money) for (int t = i; t \u003c= n; t++) a[t] += a[t - i]; return a[n]; } ","date":"2020-01-10","objectID":"/2020-01-10-change/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]거스름돈","uri":"/2020-01-10-change/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-09","objectID":"/2020-01-09-setupstations/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]기지국 설치","uri":"/2020-01-09-setupstations/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: N개의 아파트가 일렬로 쭉 늘어서 있습니다. 이 중에서 일부 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 기술이 발전해 5g 수요가 높아져 4g 기지국을 5g 기지국으로 바꾸려 합니다. 그런데 5g 기지국은 4g 기지국보다 전달 범위가 좁아, 4g 기지국을 5g 기지국으로 바꾸면 어떤 아파트에는 전파가 도달하지 않습니다. 예를 들어 11개의 아파트가 쭉 늘어서 있고, [4, 11] 번째 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 만약 이 4g 기지국이 전파 도달 거리가 1인 5g 기지국으로 바뀔 경우 모든 아파트에 전파를 전달할 수 없습니다. (전파의 도달 거리가 W일 땐, 기지국이 설치된 아파트를 기준으로 전파를 양쪽으로 W만큼 전달할 수 있습니다.) 초기에, 1, 2, 6, 7, 8, 9번째 아파트에는 전파가 전달되지 않습니다. 1, 7, 9번째 아파트 옥상에 기지국을 설치할 경우, 모든 아파트에 전파를 전달할 수 있습니다. 3개의 아파트보다 더 많은 아파트 옥상에 기지국을 설치할 경우에도 모든 아파트에 전파를 전달할 수 있습니다. 이때, 우리는 기지국을 최소로 설치하면서 모든 아파트에 전파를 전달하려고 합니다. 위의 예시에선 최소 3개의 아파트 옥상에 기지국을 설치해야 모든 아파트에 전파를 전달할 수 있습니다. 아파트의 개수 N, 현재 기지국이 설치된 아파트의 번호가 담긴 1차원 배열 stations, 전파의 도달 거리 W가 매개변수로 주어질 때, 모든 아파트에 전파를 전달하기 위해 증설해야 할 기지국 개수의 최솟값을 리턴하는 solution 함수를 완성해주세요 풀이: 1번 아파트부터 기지국을 설치해 나간다. 만약 현재 설치하는 아파트에 이미 설치되 있던 기지국 전파가 들어온다면, 기지국 전파가 들어오는 범위에 아파트는 건너뛰고 다시 설치해 나간다. 총 기지국을 몇개 설치 했는지 리턴한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int solution(int n, vector\u003cint\u003e stations, int w) { int answer = 0, c = 0, i = 1; while(i \u003c= n){ if (i \u003e= stations[c] - w \u0026\u0026 i \u003c= stations[c] + w) { i = stations[c] + w; c++; } else { i += 2 * w; answer++; } i++; } return answer; } ","date":"2020-01-09","objectID":"/2020-01-09-setupstations/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]기지국 설치","uri":"/2020-01-09-setupstations/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-08","objectID":"/2020-01-08-bestset/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]최고의 집합","uri":"/2020-01-08-bestset/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 집합으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다. 각 원소의 합이 S가 되는 수의 집합 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합 예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다. { 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 } 그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다. 집합의 원소의 개수 n과 모든 원소들의 합 s가 매개변수로 주어질 때, 최고의 집합을 return 하는 solution 함수를 완성해주세요. 풀이: s 가 n 보다 작다면 자연수의 합으로 나타낼 수 없으므로 -1을 리턴한다. 아니라면, answer 배열에 s / n을 넣는다. (각 원소의 곱이 최대가 되려면 각 원소의 차이가 최소이어야하므로) 넣은 수만큼 s를 빼주고 n 또한 -1 해준다. n이 0이될때까지 반복한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cint\u003e solution(int n, int s) { vector\u003cint\u003e answer; int a; int c = 0; if (s \u003c n) answer.push_back(-1); else{ answer.resize(n); while (n) { a = s / n; answer[c] = a; s -= a; n--; c++; } } return answer; } ","date":"2020-01-08","objectID":"/2020-01-08-bestset/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]최고의 집합","uri":"/2020-01-08-bestset/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-07","objectID":"/2020-01-07-numgame/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]숫자 게임","uri":"/2020-01-07-numgame/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: xx 회사의 2xN명의 사원들은 N명씩 두 팀으로 나눠 숫자 게임을 하려고 합니다. 두 개의 팀을 각각 A팀과 B팀이라고 하겠습니다. 숫자 게임의 규칙은 다음과 같습니다. 먼저 모든 사원이 무작위로 자연수를 하나씩 부여받습니다. 각 사원은 딱 한 번씩 경기를 합니다. 각 경기당 A팀에서 한 사원이, B팀에서 한 사원이 나와 서로의 수를 공개합니다. 그때 숫자가 큰 쪽이 승리하게 되고, 승리한 사원이 속한 팀은 승점을 1점 얻게 됩니다. 만약 숫자가 같다면 누구도 승점을 얻지 않습니다. 전체 사원들은 우선 무작위로 자연수를 하나씩 부여받았습니다. 그다음 A팀은 빠르게 출전순서를 정했고 자신들의 출전 순서를 B팀에게 공개해버렸습니다. B팀은 그것을 보고 자신들의 최종 승점을 가장 높이는 방법으로 팀원들의 출전 순서를 정했습니다. 이때의 B팀이 얻는 승점을 구해주세요. A 팀원들이 부여받은 수가 출전 순서대로 나열되어있는 배열 A와 i번째 원소가 B팀의 i번 팀원이 부여받은 수를 의미하는 배열 B가 주어질 때, B 팀원들이 얻을 수 있는 최대 승점을 return 하도록 solution 함수를 완성해주세요. 풀이: 배열 A와 B를 정렬한다. 배열 B를 순회하며, 배열 A의 값보다 크다면 배열 A의 위치와 승점을 +1 해준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(vector\u003cint\u003e A, vector\u003cint\u003e B) { sort(A.begin(), A.end()); sort(B.begin(), B.end()); int c = 0, answer = 0; for (int i = 0; i \u003c B.size(); i++) { if (B[i] \u003e A[c]) { answer++; c++; } } return answer; } ","date":"2020-01-07","objectID":"/2020-01-07-numgame/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]숫자 게임","uri":"/2020-01-07-numgame/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-06","objectID":"/2020-01-06-longestpalindrome/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]가장 긴 팰린드롬","uri":"/2020-01-06-longestpalindrome/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다. 문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요. 예를들면, 문자열 s가 abcdcba이면 7을 return하고 abacde이면 3을 return합니다. 풀이: Manacher’s algorithm 을 이용한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003calgorithm\u003eusing namespace std; int p[5002]; int solution(string s) { string a = \"#\"; for (char i : s) { a += i; a += \"#\"; } int m = 0, ed = 0, answer = 0; for (int i = 1; i \u003c a.size(); i++) { if (i \u003c= ed) p[i] = min(p[m * 2 - i], ed - i); while (i - p[i] \u003e= 1 \u0026\u0026 i + p[i] + 1 \u003c a.size() \u0026\u0026 a[i - p[i] - 1] == a[i + p[i] + 1]) p[i]++; if (p[i] + i \u003e ed) { ed = p[i] + i; m = i; } answer = max(answer, p[i]); } return answer; } ","date":"2020-01-06","objectID":"/2020-01-06-longestpalindrome/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]가장 긴 팰린드롬","uri":"/2020-01-06-longestpalindrome/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-05","objectID":"/2020-01-05-waytoschool/","tags":["algorithm","C++","DP","Level 3"],"title":"[프로그래머스]등굣길","uri":"/2020-01-05-waytoschool/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다. 아래 그림은 m = 4, n = 3 인 경우입니다. 가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다. 격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요. 풀이: a[m][n] : (1, 1) 부터 (m, n) 으로 갈 수 있는 최단경로의 수 a에 있는 모든 원소를 -1로 채워넣고 시작한다. 단, 물웅덩이 있는 곳은 0으로 채워넣는다. m, n 부터 시작한다. 최단길을 기준으로 생각하므로 왼쪽, 위만 생각하기로 한다. 즉, (m - 1, n), (m, n - 1) 만 생각하기로 한다. a[m][n] = (a[m - 1][n] + a[m][n - 1]) % 1,000,000,007 반복적인 계산을 피하기위해 a[m][n]이 -1이 아니라면 그 값을 리턴하기로 한다. 좌표에 0은 없으므로 0을 만나면 0을 리턴한다. (1, 1) 이 집의 좌표이므로 집을 만나면 1을 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cvector\u003cint\u003e\u003e a(101, vector\u003cint\u003e(101, -1)); int r(int m, int n) { if (!m || !n) return 0; if (a[m][n] != -1) return a[m][n]; a[m][n] = (r(m - 1, n) + r(m , n - 1)) % 1000000007; return a[m][n]; } int solution(int m, int n, vector\u003cvector\u003cint\u003e\u003e puddles) { for (auto i : puddles) a[i[0]][i[1]] = 0; a[1][1] = 1; return r(m, n); } ","date":"2020-01-05","objectID":"/2020-01-05-waytoschool/:0:0","tags":["algorithm","C++","DP","Level 3"],"title":"[프로그래머스]등굣길","uri":"/2020-01-05-waytoschool/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-04","objectID":"/2020-01-04-priorityqueue/","tags":["algorithm","C++","힙","Level 3"],"title":"[프로그래머스]이중우선순위큐","uri":"/2020-01-04-priorityqueue/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다. 명령어 수신 탑(높이) I 숫자 큐에 주어진 숫자를 삽입합니다. D 1 큐에서 최댓값을 삭제합니다. D -1 큐에서 최솟값을 삭제합니다. 이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요. 풀이: 첫 영어가 I 라면 뒤에 숫자를 삽입한다. 첫 영어가 D이고, 뒤 문자가 1이라면 최댓값을 삭제한다. 첫 영어가 D이고, 뒤 문자가 -1이라면 최솟값을 삭제한다. 삽입된 숫자가 없다면 {0, 0}을 리턴한다. 삽입된 숫자가 있다면 그 중 {최댓값, 최솟값} 을 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cmap\u003eusing namespace std; vector\u003cint\u003e solution(vector\u003cstring\u003e operations) { multimap\u003cint, int\u003e a; for (int i = 0;i \u003c operations.size();i++) if (operations[i][0] == 'I') a.insert(pair\u003cint,int\u003e(stoi(operations[i].substr(2, operations[i].size() - 1)) , 1)); else if(a.size() \u0026\u0026 operations[i] == \"D 1\") a.erase(a.rbegin()-\u003efirst); else if (a.size() \u0026\u0026 operations[i] == \"D -1\") a.erase(a.begin()-\u003efirst); if (!a.size()) return {0, 0}; else return {a.rbegin()-\u003efirst, a.begin()-\u003efirst}; } ","date":"2020-01-04","objectID":"/2020-01-04-priorityqueue/:0:0","tags":["algorithm","C++","힙","Level 3"],"title":"[프로그래머스]이중우선순위큐","uri":"/2020-01-04-priorityqueue/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-03","objectID":"/2020-01-03-2xntiling/","tags":["algorithm","C++","DP","Level 3"],"title":"[프로그래머스]2 X n 타일링","uri":"/2020-01-03-2xntiling/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 가로 길이가 2이고 세로의 길이가 1인 직사각형모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 2이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다. 타일을 가로로 배치 하는 경우 타일을 세로로 배치 하는 경우 예를들어서 n이 7인 직사각형은 다음과 같이 채울 수 있습니다. 직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요. 풀이: a[i] : 2 x i 직사각형을 채우는 방법의 수 a[i] = a[i - 2] + a[i - 1] 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int n) { vector\u003clong long\u003e a = { 1, 2 }; for (int i = 2; i \u003c n; i++) a.push_back((a[i - 2] + a[i - 1])%1000000007); return a[n - 1]; } ","date":"2020-01-03","objectID":"/2020-01-03-2xntiling/:0:0","tags":["algorithm","C++","DP","Level 3"],"title":"[프로그래머스]2 X n 타일링","uri":"/2020-01-03-2xntiling/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-03","objectID":"/2020-01-03-xgapnnum/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]x만큼 간격이 있는 n개의 숫자","uri":"/2020-01-03-xgapnnum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요. 풀이: x * 1, x *2…., x * n 을 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003clong long\u003e solution(int x, int n) { vector\u003clong long\u003e answer; for (int i = 1;i \u003c= n;i++) answer.push_back(x * i); return answer; } ","date":"2020-01-03","objectID":"/2020-01-03-xgapnnum/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]x만큼 간격이 있는 n개의 숫자","uri":"/2020-01-03-xgapnnum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-03","objectID":"/2020-01-03-network/","tags":["algorithm","DFS","BFS","Level 3"],"title":"[프로그래머스]네트워크","uri":"/2020-01-03-network/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오. 풀이: A 컴퓨터부터 확인한다. 확인했다면 visit[A]를 1로 바꾼다. A 컴퓨터가 B컴퓨터와 이어져있다면 B로 간다 …. 반복한다. 더이상 이어져있는 컴퓨터가 없다면 네트워크의 갯수를 1더해준다. 모든 컴퓨터를 확인한 후 네트워크의 갯수를 리턶나다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int d(int x, vector\u003cvector\u003cint\u003e\u003e c, vector\u003cint\u003e\u0026 a) { if (a[x]) return 0; a[x] = 1; for (int i = 0;i \u003c a.size();i++) if (c[x][i] \u0026\u0026 i != x) d(i, c, a); return 1; } int solution(int n, vector\u003cvector\u003cint\u003e\u003e computers) { vector\u003cint\u003e a(n, 0); int answer = 0; for (int i = 0;i \u003c n;i++) { answer += d(i, computers, a); } return answer; } ","date":"2020-01-03","objectID":"/2020-01-03-network/:0:0","tags":["algorithm","DFS","BFS","Level 3"],"title":"[프로그래머스]네트워크","uri":"/2020-01-03-network/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-03","objectID":"/2020-01-03-secretmap/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]비밀지도","uri":"/2020-01-03-secretmap/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: ","date":"2020-01-03","objectID":"/2020-01-03-secretmap/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]비밀지도","uri":"/2020-01-03-secretmap/"},{"categories":["프로그래머스"],"content":"비밀지도 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 공백(\" ) 또는벽(#\") 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. 지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다. 네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라. 풀이: 암호가 2진법 이므로, 1, 2, 4, 8…. 등 2의 배수와 and 작업을 했을 때, true값이 나왔을 경우 그 위치에 answer 값을 ‘#’ 으로 바꿔준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cstring\u003e solution(int n, vector\u003cint\u003e arr1, vector\u003cint\u003e arr2) { vector\u003cstring\u003e answer(n); for (int i = 0;i \u003c n;i++) { int a = 1; answer[i].resize(n); for (int t = n - 1;t \u003e= 0;t--) { if (arr1[i] \u0026 a || arr2[i] \u0026 a) answer[i][t] = '#'; else answer[i][t] = ' '; a *= 2; } } return answer; } ","date":"2020-01-03","objectID":"/2020-01-03-secretmap/:1:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]비밀지도","uri":"/2020-01-03-secretmap/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-03","objectID":"/2020-01-03-failurelate/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]실패율","uri":"/2020-01-03-failurelate/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: ","date":"2020-01-03","objectID":"/2020-01-03-failurelate/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]실패율","uri":"/2020-01-03-failurelate/"},{"categories":["프로그래머스"],"content":"실패율 슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다. 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라. 실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라. 풀이: 각 스테이지에 몇명이 머물러 있는지 구한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 를 구하여 넣어놓는다. 실패율이 높은것부터 내림차순으로 정렬하여 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cmap\u003eusing namespace std; vector\u003cint\u003e solution(int N, vector\u003cint\u003e stages) { vector\u003cdouble\u003e a(N + 2, 0); vector\u003cint\u003e answer; multimap\u003cdouble, int, greater\u003cdouble\u003e\u003e m; int c = stages.size(); for (int i : stages) a[i]++; for (int i = 1;i \u003c= N;i++) { m.insert(pair\u003cdouble, int\u003e(a[i]/c, i)); c -= a[i]; } for (auto i : m) answer.push_back(i.second); return answer; } ","date":"2020-01-03","objectID":"/2020-01-03-failurelate/:1:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]실패율","uri":"/2020-01-03-failurelate/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-03","objectID":"/2020-01-03-budget/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]예산","uri":"/2020-01-03-budget/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다. 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다. 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요. 풀이: 금액이 들어있는 배열 d를 정렬한다. 예산에서 예산이 0보다 작아질 때까지 배열 d에 들어있는 값을 하나씩 뺀다. 뺄때마다 count를 1더해준다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(vector\u003cint\u003e d, int budget) { int answer = 0; sort(d.begin(),d.end()); for(int i : d){ if(budget \u003c i) break; budget -= i; answer++; } return answer; } ","date":"2020-01-03","objectID":"/2020-01-03-budget/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]예산","uri":"/2020-01-03-budget/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-03","objectID":"/2020-01-03-budget_level3/","tags":["algorithm","C++","이분탐색","Level 3"],"title":"[프로그래머스]예산","uri":"/2020-01-03-budget_level3/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것입니다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있습니다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정합니다. 1. 모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정합니다. 2. 모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정합니다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정합니다. 예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150일 때, 상한액을 127로 잡으면 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 됩니다. 각 지방에서 요청하는 예산이 담긴 배열 budgets과 총 예산 M이 매개변수로 주어질 때, 위의 조건을 모두 만족하는 상한액을 return 하도록 solution 함수를 작성해주세요. 풀이: 국가 예산 / 지방의 개수 가 최소 상한액이 된다. 만약 전체 지방의 최저값이 최소 상한액보다 크다면, 답은 최소상한액이 된다. 작다면, 국가예산에서 최저값만큼 뺀 후, 지방의 개수를 1 줄인다. 전체 지방을 탐색할 때까지 반복한다. 전체 지방을 탐색했음에도 전부 최소 상한액보다 작다면, 이미 지방 예산의 합이 국가예산보다 적은 것이므로, 지방예산의 최댓값을 출력한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(vector\u003cint\u003e budgets, int M) { int answer = M / budgets.size(); sort(budgets.begin(), budgets.end()); int c = 0; for (int i = 0;i \u003c budgets.size();i++) { if (budgets[i] \u003e answer) { c = i; break; } M -= budgets[i]; } int sum = M; while (M \u003e 0 \u0026\u0026 answer \u003c= budgets.back()) { answer++; while (c \u003c budgets.size() \u0026\u0026 budgets[c] \u003c answer) { sum -= budgets[c]; c++; } if (c == budgets.size()) break; M = sum; M -= (answer * (budgets.size() - c)); } return answer \u003c= budgets.back() ? answer - 1 : budgets.back(); } 좋은 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(vector\u003cint\u003e budgets, int M) { int s = budgets.size(); sort(budgets.begin(), budgets.end()); for (int i : budgets) { if (i \u003e M / s) return M / s; else { M -= i; s--; } } return budgets.back(); } ","date":"2020-01-03","objectID":"/2020-01-03-budget_level3/:0:0","tags":["algorithm","C++","이분탐색","Level 3"],"title":"[프로그래머스]예산","uri":"/2020-01-03-budget_level3/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-03","objectID":"/2020-01-03-origami/","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]종이접기","uri":"/2020-01-03-origami/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 직사각형 종이를 n번 접으려고 합니다. 이때, 항상 오른쪽 절반을 왼쪽으로 접어 나갑니다. 다음은 n = 2인 경우의 예시입니다. 먼저 오른쪽 절반을 왼쪽으로 접습니다. 다시 오른쪽 절반을 왼쪽으로 접습니다. 종이를 모두 접은 후에는 종이를 전부 펼칩니다. 종이를 펼칠 때는 종이를 접은 방법의 역순으로 펼쳐서 처음 놓여있던 때와 같은 상태가 되도록 합니다. 위와 같이 두 번 접은 후 종이를 펼치면 아래 그림과 같이 종이에 접은 흔적이 생기게 됩니다. 위 그림에서 ∨ 모양이 생긴 부분은 점선(0)으로, ∧ 모양이 생긴 부분은 실선(1)으로 표시했습니다. 종이를 접은 횟수 n이 매개변수로 주어질 때, 종이를 절반씩 n번 접은 후 모두 펼쳤을 때 생기는 접힌 부분의 모양을 배열에 담아 return 하도록 solution 함수를 완성해주세요. 풀이: 맨 뒤에 0을 추가한다. 0을 기준으로 대칭이나 0과 1은 반대되게 (ex. 0\u003c0\u003e1) 값을 추가한다. n만큼 반복한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cint\u003e solution(int n) { vector\u003cint\u003e answer = { 0 }; while (n != 1) { answer.push_back(0); for (int i = answer.size() - 2;i \u003e= 0; i--) answer.push_back(1 - answer[i]); n--; } return answer; } 시간초과 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cint\u003e solution(int n) { vector\u003cint\u003e answer = { 0 }; int a[2] = { 0,1 }; while (n != 1) { for (int i = 0;i * 2 \u003c answer.size();i++) { answer.insert(answer.begin() + (i * 2), 1, a[i % 2]); } answer.push_back(1); n--; } return answer; } ","date":"2020-01-03","objectID":"/2020-01-03-origami/:0:0","tags":["algorithm","C++","Level 3"],"title":"[프로그래머스]종이접기","uri":"/2020-01-03-origami/"},{"categories":["Learn"],"content":"learn","date":"2020-01-02","objectID":"/2020-01-02-distinguishstring/","tags":["Learn","C++"],"title":"[C++]대소문자, 숫자 구분함수 ","uri":"/2020-01-02-distinguishstring/"},{"categories":["Learn"],"content":"숫자판단, 문자판단, 대소문자 판단 ( isalpha, isupper, islower, isdigit, toupper, tolower ) isalpha - 알파벳 문자 판별 int isalpha(int c); c가 알파벳 문자인지 아닌지 판별해준다. int형인 이유는 아스키코드를 판별하기 떄문!! 단, 사용 할 때 알파벳을 직접 넣어줘도 된다. int isalpha(97); int isalpha('a'); 밑에 ‘a’ 가 아스키코드로 97이므로 결국 두 문장은 같은 문장이다. return은 타입이 int형 이기에 알파벳이 아니라면 0 을 알파벳이라면 0이아닌 정수를 리턴한다. 비쥬얼 스튜디오 기준 ​ 알파벳이 아닐경우 - 0 ​ 대문자일 경우 - 1 ​ 소문자일 경우 - 2 isupper - 대문자 판별 int isupper(int c); c가 대문자인지 아닌지 판별해준다. 대문자가 아니라면 0을 (알파벳이 아닌 다른 어떤 문자여도 대문자가 아니기 때문에 0을 리턴한다.) 대문자라면 0이아닌 정수를 리턴한다. islower - 소문자 판별 int islower(int c); c가 소문자인지 아닌지를 판별해준다. isdigit - 숫자 판별 int isdigit(int c); c가 숫자인지 아닌지를 판별해준다. 단, 주의할 점이 있다. isdigit(5); 이것은 숫자일까? 아닐까? 답은 0을 리턴한다. 왜그럴까? isdigit또한 위에 함수들처럼 아스키코드값을 확인하기 때문이다. 즉 ‘0’ ~ ‘9’ (아스키 코드로 : 48 ~ 57) 에 해당하는지를 확인한다. isdigit('5'); isdigit(53); 이와 같이 사용하도록 하자. toupper - 소문자를 대문자로 int toupper(int c); c가 소문자라면 대문자로 바꾸어서 리턴해준다. 소문자가 아니라면 원래상태 그대로 리턴해준다. tolower - 대문자를 소문자로 int tolower(int c); c가 대문자라면 소문자로 바꾸어서 리턴해준다. 기타 isalnum(); // 알파벳 또는 숫자인가? (a ~ z, A ~ Z, 0 ~ 9) isxdigit(); // 16진수 숫자인가? (0 ~ 9, A ~ F, a ~ f) isspace(); // 공백 문자인가? (' ', '\\n', '\\t', '\\v', '\\r') ispunct(); // 구두점 문자인가? isprint(); // 출력가능한 문자인가? iscntrl(); // 제어문자인가? isascii(); // 아스키코드인가? toascii(); // 아스키코드로 변환 ","date":"2020-01-02","objectID":"/2020-01-02-distinguishstring/:0:0","tags":["Learn","C++"],"title":"[C++]대소문자, 숫자 구분함수 ","uri":"/2020-01-02-distinguishstring/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-jadencasestring/","tags":["algorithm","C++","문자열","Level 2"],"title":"[프로그래머스]JadenCase 문자열 만들기","uri":"/2020-01-02-jadencasestring/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요. 풀이: [C++]대소문자, 숫자 구분함수 참고 모든 단어의 첫 문자가 대문자가 아니라면 대문자로 바꾼다. 첫 문자가 아니라면 소문자로 바꾼다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; string solution(string s) { int c = 0; for (int i = 0;i \u003c s.size();i++) { if (!c) { s[i] = toupper(s[i]); c++; } else s[i] = tolower(s[i]); if (s[i] == ' ') c = 0; } return s; } ","date":"2020-01-02","objectID":"/2020-01-02-jadencasestring/:0:0","tags":["algorithm","C++","문자열","Level 2"],"title":"[프로그래머스]JadenCase 문자열 만들기","uri":"/2020-01-02-jadencasestring/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-newsclustering/","tags":["algorithm","C++","문자열","Level 2"],"title":"[프로그래머스]뉴스 클러스터링","uri":"/2020-01-02-newsclustering/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: ","date":"2020-01-02","objectID":"/2020-01-02-newsclustering/:0:0","tags":["algorithm","C++","문자열","Level 2"],"title":"[프로그래머스]뉴스 클러스터링","uri":"/2020-01-02-newsclustering/"},{"categories":["프로그래머스"],"content":"뉴스 클러스터링 여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다. 개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 카카오 신입 개발자 공채 관련 기사를 검색해보았다. 카카오 첫 공채..‘블라인드’ 방식 채용 카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용 카카오, 블라인드 전형으로 신입 개발자 공채 카카오 공채, 신입 개발자 코딩 능력만 본다 카카오, 신입 공채.. 코딩 실력만 본다 카카오 코딩 능력만으로 2018 신입 개발자 뽑는다 기사의 제목을 기준으로 블라인드 전형에 주목하는 기사와 코딩 테스트에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다. 유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 자카드 유사도라는 방법을 찾아냈다. 자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다. 예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때, 교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로, 집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다. 자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 1을 3개 가지고 있고, 다중집합 B는 원소 1을 5개 가지고 있다고 하자. 이 다중집합의 교집합 A ∩ B는 원소 1을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 1을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다. 이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 FRANCE와 FRENCH가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(\"FRANCE\", \"FRENCH\") = 2/8 = 0.25가 된다. 풀이: 배열 a와 배열 b에 str1, str2의 문자열을 각각 2글자씩 끊어서 정리해놓는다. a와 b를 순환하면서 a와 b에 문자열이 같을 경우 문자열을 삭제하고, count를 1 올려준다. 순환이 끝나면 교집합의 갯수는 count의 값이 되고, 합집합의 수는 a의 사이즈 + b의 사이즈 + count값이 된다. 만약 합집합이 0이라면 나눌 수 없으므로 65536을 출력한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003eusing namespace std; int solution(string str1, string str2) { vector\u003cstring\u003e a; vector\u003cstring\u003e b; int i = 0; while (i \u003c str1.size() - 1 || i \u003c str2.size() - 1) { if (i \u003c str1.size() - 1 \u0026\u0026 isalpha(str1[i]) \u0026\u0026 isalpha(str1[i + 1])) a.push_back(str1.substr(i,2)); if (i \u003c str2.size() - 1 \u0026\u0026 isalpha(str2[i]) \u0026\u0026 isalpha(str2[i + 1])) b.push_back(str2.substr(i,2)); i++; } i = 0; for (int t = 0; t \u003c a.size();t++) { for (int y = 0; y \u003c b.size();y++) { if (toupper(a[t][0]) == toupper(b[y][0]) \u0026\u0026 toupper(a[t][1]) == toupper(b[y][1])) { a.erase(a.begin() + t, a.begin() + t + 1); t--; b.erase(b.begin() + y, b.begin() + y + 1); i++; break; } } } return (a.size() + b.size() + i) ? ((double)i /(double)(a.size() + b.size() + i)) * 65536 : 65536; } ","date":"2020-01-02","objectID":"/2020-01-02-newsclustering/:1:0","tags":["algorithm","C++","문자열","Level 2"],"title":"[프로그래머스]뉴스 클러스터링","uri":"/2020-01-02-newsclustering/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-engwordchain/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]영어 끝말잇기","uri":"/2020-01-02-engwordchain/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다. 다음은 3명이 끝말잇기를 하는 상황을 나타냅니다. tank → kick → know → wheel → land → dream → mother → robot → tank 위 끝말잇기는 다음과 같이 진행됩니다. 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다. 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다. 3번 사람이 자신의 첫 번째 차례에 know를 말합니다. 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다. (계속 진행) 끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다. 사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요. 풀이: 배열 words의 첫번째부터 차례대로 확인한다. 만약 현재 단어가 이전에 나온 단어이거나, 바로 전 단어의 마지막 문자와 현재단어의 첫번째 단어가 다르다면 현재 차례의 말한 사람과 이 사람이 몇번째로 말한 단어인지 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003ciostream\u003e#include \u003cmap\u003eusing namespace std; vector\u003cint\u003e solution(int n, vector\u003cstring\u003e words) { map\u003cstring, int\u003e a = { {words[0],1} }; vector\u003cint\u003e answer = { 0,0 }; for (int i = 1;i \u003c words.size();i++) { if (a[words[i]] || words[i].front() != words[i - 1].back()) { answer[0] = (i % n) + 1; answer[1] = (i / n) + 1; break; } a[words[i]] = 1; } return answer; } ","date":"2020-01-02","objectID":"/2020-01-02-engwordchain/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]영어 끝말잇기","uri":"/2020-01-02-engwordchain/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-distinguishsqrt/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]정수 제곱근 판별","uri":"/2020-01-02-distinguishsqrt/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다. n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요. 풀이: 정수 n의 제곱근의 소수점을 버린 수를 a라 할때, a * a 이 n 과 다르다면 n은 제곱근이 아니므로 -1 을 리턴, 같다면 (a + 1) * (a + 1) 을 리턴해준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; long long solution(long long n) { long long a = sqrt(n); return a * a != n ? -1 : (a + 1) * (a + 1); } ","date":"2020-01-02","objectID":"/2020-01-02-distinguishsqrt/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]정수 제곱근 판별","uri":"/2020-01-02-distinguishsqrt/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-oddandeven/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]짝수와 홀수","uri":"/2020-01-02-oddandeven/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 정수 num이 짝수일 경우 Even을 반환하고 홀수인 경우 Odd를 반환하는 함수, solution을 완성해주세요. 풀이: 정수 num이 짝수면 “Even” 을 홀수라면 “Odd” 를 반환한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; string solution(int num) { return num % 2 ? \"Odd\" : \"Even\"; } ","date":"2020-01-02","objectID":"/2020-01-02-oddandeven/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]짝수와 홀수","uri":"/2020-01-02-oddandeven/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-collatzconjecture/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]콜라츠 추측","uri":"/2020-01-02-collatzconjecture/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다. 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요. 풀이: num이 작업도중 int값을 넘어갈 수 있으므로 long long a 로 옮겨준다. a가 짝수라면 2로 나눈다. 홀수라면 3을 곱하고 1을 더해준다. 반복한다. a가 1이거나 count값이 500을 넘어간다면 반복을 중단한다. count값이 500을 넘어간다면 -1을 안넘어간다면 count값을 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int num) { long long a = num; int answer = 0; while(a != 1 \u0026\u0026 answer \u003c= 500){ a = a % 2 ? (a * 3) + 1 : a / 2; answer++; } return answer \u003e 500 ? -1 : answer; } ","date":"2020-01-02","objectID":"/2020-01-02-collatzconjecture/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]콜라츠 추측","uri":"/2020-01-02-collatzconjecture/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-average/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]평균 구하기","uri":"/2020-01-02-average/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요. 풀이: 배열 arr의 평균값을 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; double solution(vector\u003cint\u003e arr) { double answer = 0; for(int i : arr) answer += i; return answer / arr.size(); } ","date":"2020-01-02","objectID":"/2020-01-02-average/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]평균 구하기","uri":"/2020-01-02-average/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-friends4block/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]프렌즈4블록","uri":"/2020-01-02-friends4block/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: ","date":"2020-01-02","objectID":"/2020-01-02-friends4block/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]프렌즈4블록","uri":"/2020-01-02-friends4block/"},{"categories":["프로그래머스"],"content":"프렌즈4블록 블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 프렌즈4블록. 같은 모양의 카카오프렌즈 블록이 2\u0014×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다. 만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다. 블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다. 만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다. 위 초기 배치를 문자로 표시하면 아래와 같다. TTTANT RRFACC RRRFCC TRRRAA TTMMMF TMMTTJ 각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다 입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라. 풀이: 배열에 (0, 0) 부터 순회한다. 만약, (i, t) 일 때, ( i, t ), ( i + 1 , t ), ( i , t + 1 ), ( i + 1, t + 1 ) 의 값들이 모두 같다면 이 값들을 ‘0’으로 바꾸고 count를 바꾼만큼 올려준다. ( 4개의 값이 모두 ‘0’일 수도 있으므로 ‘0’은 예외를 두도록 한다.) 순회가 끝난 후 카운트 값이 이전과 같다면 사라질 블록이 없다는 뜻이므로 반복문을 나간다. 다르다면, 밑에서 부터 다시 순회하며 ‘0’값이 보일때마다 위에서 블록을 내려준다. 다시 다 내린 후 처음으로 돌아가 반복한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int m, int n, vector\u003cstring\u003e board) { int answer = 0; while (1) { vector\u003cstring\u003e a = board; int c = answer; for (int i = 0;i \u003c m - 1;i++) { for (int t = 0;t \u003c n - 1;t++) { if (board[i][t] != '0' \u0026\u0026 board[i][t] == board[i + 1][t] \u0026\u0026 board[i + 1][t] == board[i][t + 1] \u0026\u0026 board[i][t + 1] == board[i + 1][t + 1] ) { if (a[i][t] != '0') answer++; if (a[i + 1][t] != '0') answer++; if (a[i][t + 1] != '0') answer++; if (a[i + 1][t + 1] != '0') answer++; a[i][t] = '0'; a[i + 1][t] = '0'; a[i][t + 1] = '0'; a[i + 1][t + 1] = '0'; } } } if (c == answer) break; board = a; for (int i = m - 1;i \u003e= 0;i--) { for (int t = n - 1;t \u003e= 0;t--) { if (board[i][t] == '0') { for (int y = i - 1;y \u003e= 0;y--) { if (board[y][t] != '0') { swap(board[i][t], board[y][t]); break; } } } } } } return answer; } ","date":"2020-01-02","objectID":"/2020-01-02-friends4block/:1:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]프렌즈4블록","uri":"/2020-01-02-friends4block/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-harshadnum/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]하샤드 수","uri":"/2020-01-02-harshadnum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요. 풀이: 정수 x의 각 자릿수의 합을 구한다. 정수 x를 구한 값으로 나누어 나머지가 0이라면 true를 0이 아니라면 false를 출력한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; bool solution(int x) { int c = 0; string a = to_string(x); for(char i : a) c += i - '0'; return !(x % c); } ","date":"2020-01-02","objectID":"/2020-01-02-harshadnum/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]하샤드 수","uri":"/2020-01-02-harshadnum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-02","objectID":"/2020-01-02-maskingphonenum/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]핸드폰 번호 가리기","uri":"/2020-01-02-maskingphonenum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다. 전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요. 풀이: 문자열 phone_number 의 뒤에 4자리를 제외한 나머지 숫자를 전부 ‘*’ 로 바꾼 후 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; string solution(string phone_number) { for (int i = 0;i \u003c phone_number.size()-4;i++) phone_number[i] = '*'; return phone_number; } ","date":"2020-01-02","objectID":"/2020-01-02-maskingphonenum/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]핸드폰 번호 가리기","uri":"/2020-01-02-maskingphonenum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-01","objectID":"/2020-01-01-ttangttameokgi/","tags":["algorithm","C++","DP","Level 2"],"title":"[프로그래머스]땅따먹기","uri":"/2020-01-01-ttangttameokgi/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다. 예를 들면, | 1 | 2 | 3 | 5 | | 5 | 6 | 7 | 8 | | 4 | 3 | 2 | 1 | 로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다. 마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다. 풀이: DP[i][t] : i 행 t 열에서 얻을 수 있는 점수의 최댓값 DP[i][t] = land[i][t] + DP(i - 1 행에 t를 제외한 모든 숫자 중 최댓값) 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int solution(vector\u003cvector\u003cint\u003e \u003e land) { int answer = 0; int a[2][4] = {}; for (int i = 0;i \u003c land.size();i++) { for (int t = 0;t \u003c 4;t++) { int max = 0; for (int y = 0;y \u003c 4;y++) { if (t != y) max = max \u003e a[(i + 1) % 2][y] ? max : a[(i + 1) % 2][y]; } a[i % 2][t] = land[i][t] + max; answer = answer \u003e a[i % 2][t] ? answer : a[i % 2][t]; } } return answer; } 비슷한 문제: [백준]1149 RGB거리 ","date":"2020-01-01","objectID":"/2020-01-01-ttangttameokgi/:0:0","tags":["algorithm","C++","DP","Level 2"],"title":"[프로그래머스]땅따먹기","uri":"/2020-01-01-ttangttameokgi/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-01","objectID":"/2020-01-01-numexpression/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]숫자의 표현","uri":"/2020-01-01-numexpression/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다. 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15 자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요. 풀이: 1 ~ n 까지 연속된 자연수의 합을 모두 탐색하여, n과 같아지면 answer 을 1 더해준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int n) { int answer = 0; for (int i = 1;i \u003c= n;i++) { int a = n; int t = i; while (a \u003e 0) { a -= t; t++; if (!a) answer++; } } return answer; } ","date":"2020-01-01","objectID":"/2020-01-01-numexpression/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]숫자의 표현","uri":"/2020-01-01-numexpression/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2020-01-01","objectID":"/2020-01-01-removemating/","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]짝지어 제거하기","uri":"/2020-01-01-removemating/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다. 예를 들어, 문자열 S = baabaa 라면 b aa baa → bb aa → aa → 의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다. 풀이: 스택에 단어 하나씩 푸쉬한다. 만약 스택에 젤 위에 단어가 푸쉬할 단어와 같다면 스택에 젤 위에 단어를 팝한다. 반복이 끝났는데 스택이 비어있다면, 문자열을 모두 제거할 수 있는 단어이다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cstack\u003eusing namespace std; int solution(string s) { stack\u003cchar\u003e a; for (char i : s) if (a.empty() || a.top() != i) a.push(i); else a.pop(); return a.empty(); } ","date":"2020-01-01","objectID":"/2020-01-01-removemating/:0:0","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]짝지어 제거하기","uri":"/2020-01-01-removemating/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-31","objectID":"/2019-12-31-nlcm/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]N개의 최소공배수","uri":"/2019-12-31-nlcm/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요. 풀이: 최소공배수를 answer이라 할때, answer과 arr를 차례대로 최소공배수를 구해 anwer에 값에 넣는다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(vector\u003cint\u003e arr) { int answer = 1; for (int i : arr) { int n = answer; int m = i; if (m \u003e n) swap(n, m); while (m) { n %= m; swap(m, n); } answer = (answer * i) / n; } return answer; } ","date":"2019-12-31","objectID":"/2019-12-31-nlcm/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]N개의 최소공배수","uri":"/2019-12-31-nlcm/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-31","objectID":"/2019-12-31-gcdandlcm/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]최대공약수와 최소공배수","uri":"/2019-12-31-gcdandlcm/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다. 풀이: 최대공약수를 구한다. 최소공배수는 두 수에 곱에서 최대공약수를 나눈 값이 된다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cint\u003e solution(int n, int m) { vector\u003cint\u003e answer; int a = n \u003e m ? m : n; int b = n \u003e m ? n : m; while (a) { b %= a; swap(a, b); } answer.push_back(b); answer.push_back((n * m) / b); return answer; } ","date":"2019-12-31","objectID":"/2019-12-31-gcdandlcm/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]최대공약수와 최소공배수","uri":"/2019-12-31-gcdandlcm/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-31","objectID":"/2019-12-31-maximumandminimum/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]최댓값과 최솟값","uri":"/2019-12-31-maximumandminimum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 (최소값) (최대값)형태의 문자열을 반환하는 함수, solution을 완성하세요. 예를들어 s가 1 2 3 4라면 1 4를 리턴하고, -1 -2 -3 -4라면 -4 -1을 리턴하면 됩니다. 풀이: 공백 문자로 구분된 문자열을 배열안에 구분해서 넣는다. 나눠진 배열을 int 형으로 정렬한다. (string 형으로 정렬할 경우 사전순으로 정렬되기 때문에 안된다.) 배열에 맨 처음값과 마지막값을 리턴해준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; string solution(string s) { vector\u003cint\u003e a; int c = 0; string answer = \"\"; for (int i = 0;i \u003c s.size();i++) { if (s[i] == ' ') { a.push_back(stoi(s.substr(c, i))); c = i + 1; } } a.push_back(stoi(s.substr(c, s.size()))); sort(a.begin(), a.end()); answer += to_string(a.front()); answer += \" \"; answer += to_string(a.back()); return answer; } ","date":"2019-12-31","objectID":"/2019-12-31-maximumandminimum/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]최댓값과 최솟값","uri":"/2019-12-31-maximumandminimum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-31","objectID":"/2019-12-31-makeminimum/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]최솟값 만들기","uri":"/2019-12-31-makeminimum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다. 배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.) 예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면 A에서 첫번째 숫자인 1, B에서 두번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5) A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21) A에서 세번째 숫자인 2, B에서 첫번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29) 즉, 이 경우가 최소가 되므로 29를 return 합니다. 배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요. 풀이: 배열 A와 배열B를 정렬한다. 정렬된 배열 A와 B의 처음값 * 마지막 값을 반복한다. (합이 최소가 되기 위해서는 A의 최솟값 * B의 최댓값을 해야하기 때문) 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int solution(vector\u003cint\u003e A, vector\u003cint\u003e B) { sort(A.begin(), A.end()); sort(B.begin(), B.end()); int answer = 0; for (int i = 0;i \u003c A.size();i++) { answer += A[i] * B[B.size() - i - 1]; } return answer; } ","date":"2019-12-31","objectID":"/2019-12-31-makeminimum/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]최솟값 만들기","uri":"/2019-12-31-makeminimum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-31","objectID":"/2019-12-31-fibonaccinum/","tags":["algorithm","C++","DP","Level 2"],"title":"[프로그래머스]피보나치 수","uri":"/2019-12-31-fibonaccinum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다. 예를들어 F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 와 같이 이어집니다. 2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요. 풀이: 2748 피보나치 수2 와 같은 문제 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int n) { int a[3] = { 0,1 }; for (int i = 2;i \u003c= n;i++) a[i % 3] = (a[(i + 1) % 3] + a[(i + 2) % 3]) % 1234567; return a[n % 3]; } ","date":"2019-12-31","objectID":"/2019-12-31-fibonaccinum/:0:0","tags":["algorithm","C++","DP","Level 2"],"title":"[프로그래머스]피보나치 수","uri":"/2019-12-31-fibonaccinum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-30","objectID":"/2019-12-30-findbigestractangle/","tags":["algorithm","C++","DP","Level 2"],"title":"[프로그래머스]가장 큰 정사각형 찾기","uri":"/2019-12-30-findbigestractangle/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.) 예를 들어 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 있다면 가장 큰 정사각형은 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다. 풀이: DP[i][t] : 오른쪽 끝점이 (i, t) 일 때, 최대로 만들 수 있는 정사각형의 크기 DP[i][t] = 인접한 DP 중 가장 작은 값에서 + 1을 해준 후 자기 자신을 곱해준 값과 같다. 자기 자신을 곱한 이유는 0을 표현하기 가장 쉽기때문 전체 DP값중 가장 큰 값이 답이된다. DP로 풀지않고 완전탐색했을 경우 시간초과가 나올 수 있기 때문에 주의 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int dp[1002][1002] = {}; int solution(vector\u003cvector\u003cint\u003e\u003e board) { int answer = 0; for (int i = 1;i \u003c= board.size();i++) { for (int t = 1;t \u003c= board[0].size();t++) { dp[i][t] = (min(min(dp[i - 1][t], dp[i][t - 1]), dp[i - 1][t - 1]) + 1) * board[i - 1][t - 1]; answer = max(answer, dp[i][t]); } } return answer * answer; } 시간초과 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int solution(vector\u003cvector\u003cint\u003e\u003e board) { int size = board.size() \u003e board[0].size() ? board[0].size() : board.size(); int x = 0; int y = 0; while (1) { bool f = true; for (int i = 0;i \u003c size;i++) { if (!f) break; for (int t = 0; t \u003c size;t++) { if (x + i \u003e= board.size() || y + i \u003e= board[0].size() || !board[x+i][y+t]) { f = false; break; } } } if (f) break; x++; if (x == board.size()) { x = 0; y++; } if (y == board[0].size()) { x = 0; y = 0; size--; } } return size * size; } ","date":"2019-12-30","objectID":"/2019-12-30-findbigestractangle/:0:0","tags":["algorithm","C++","DP","Level 2"],"title":"[프로그래머스]가장 큰 정사각형 찾기","uri":"/2019-12-30-findbigestractangle/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-30","objectID":"/2019-12-30-correctpare/","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]올바른 괄호","uri":"/2019-12-30-correctpare/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 괄호가 바르게 짝지어졌다는 것은 ‘(’ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어 ()() 또는 (())() 는 올바른 괄호입니다. )()( 또는 (()( 는 올바르지 않은 괄호입니다. ‘(’ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요. 풀이: 스택이 비었거나 ‘(’ 가 나온다면 스택에 push() 둘 다 아니면서 스택에 맨 위값이 ‘(’ 라면 pop() 스택이 비었으면 올바른 괄호 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003ciostream\u003e#include \u003cstack\u003eusing namespace std; bool solution(string s) { stack\u003cchar\u003e a; for (char c : s) { if (a.empty() || c == '(') a.push(c); else if (a.top() == '(') a.pop(); } return a.empty(); } ","date":"2019-12-30","objectID":"/2019-12-30-correctpare/:0:0","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]올바른 괄호","uri":"/2019-12-30-correctpare/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-30","objectID":"/2019-12-30-carpet/","tags":["algorithm","C++","완전탐색","Level 2"],"title":"[프로그래머스]카펫","uri":"/2019-12-30-carpet/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 빨간색으로 칠해져 있고 모서리는 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. Leo는 집으로 돌아와서 아까 본 카펫의 빨간색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다. Leo가 본 카펫에서 갈색 격자의 수 brown, 빨간색 격자의 수 red가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요. 풀이: 완전탐색 brown + red 인 사각형을 만족하는 모든 가로 * 세로 중에서 red를 만족하는 가로, 세로값을 찾는다. 코드: 완전탐색 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003eusing namespace std; vector\u003cint\u003e solution(int brown, int red) { vector\u003cint\u003e answer; for (int i = brown/2+1;i \u003e 0;i--) { if ((brown + red) % i != 0) continue; int c = (brown + red) / i; if ((i - 2) * (c - 2) == red) { answer.push_back(i); answer.push_back(c); break; } } return answer; } 풀이: 수학 2*(가로) + 2*(세로) - 4 = brown (가로) * (세로) = brown + red 를 만족하는 가로, 세로를 구한다. 코드: 수학 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; vector\u003cint\u003e solution(int brown, int red) { vector\u003cint\u003e answer; double a = 0.25 * brown + 1 + sqrt(0.25 * brown * brown - 2*brown - 4*red + 4) / 2; answer.push_back(a); answer.push_back((brown + red) / a); return answer; } ","date":"2019-12-30","objectID":"/2019-12-30-carpet/:0:0","tags":["algorithm","C++","완전탐색","Level 2"],"title":"[프로그래머스]카펫","uri":"/2019-12-30-carpet/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-30","objectID":"/2019-12-30-targetnum/","tags":["algorithm","C++","DFS","BFS","Level 2"],"title":"[프로그래머스]타겟 넘버","uri":"/2019-12-30-targetnum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다. -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요. 풀이: 숫자가 A,B,C,D…. 순서로 있을 때 +A+B+C+D…. -A+B+C+D… 처럼 + - 를 번갈아 가면서 모두 계산한다. 배열 numbers의 끝까지 갔을 때, 타겟 넘버와 같다면 answer을 1 올려준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int targetnum(vector\u003cint\u003e n, int c, int t) { int answer = 0; if (c == n.size()) { if (t == 0) answer++; return answer; } else { answer += targetnum(n, c + 1, t + n[c]); answer += targetnum(n, c + 1, t - n[c]); } return answer; } int solution(vector\u003cint\u003e numbers, int target) { int answer = targetnum(numbers, 0, target); return answer; } ","date":"2019-12-30","objectID":"/2019-12-30-targetnum/:0:0","tags":["algorithm","C++","DFS","BFS","Level 2"],"title":"[프로그래머스]타겟 넘버","uri":"/2019-12-30-targetnum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-29","objectID":"/2019-12-29-numbaseball/","tags":["algorithm","C++","완전탐색","Level 2"],"title":"[프로그래머스]숫자 야구","uri":"/2019-12-29-numbaseball/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 숫자 야구 게임이란 2명이 서로가 생각한 숫자를 맞추는 게임입니다. 게임해보기 각자 서로 다른 1~9까지 3자리 임의의 숫자를 정한 뒤 서로에게 3자리의 숫자를 불러서 결과를 확인합니다. 그리고 그 결과를 토대로 상대가 정한 숫자를 예상한 뒤 맞힙니다. * 숫자는 맞지만, 위치가 틀렸을 때는 볼 * 숫자와 위치가 모두 맞을 때는 스트라이크 * 숫자와 위치가 모두 틀렸을 때는 아웃 예를 들어, 아래의 경우가 있으면 A : 123 B : 1스트라이크 1볼. A : 356 B : 1스트라이크 0볼. A : 327 B : 2스트라이크 0볼. A : 489 B : 0스트라이크 1볼. 이때 가능한 답은 324와 328 두 가지입니다. 질문한 세 자리의 수, 스트라이크의 수, 볼의 수를 담은 2차원 배열 baseball이 매개변수로 주어질 때, 가능한 답의 개수를 return 하도록 solution 함수를 작성해주세요. 풀이: 123 부터 987 까지 모든 경우의 수를 완전 탐색한다. 이 때, 숫자에 0이 들어가거나 222처럼 중복되는 단어가 들어가면 안되므로 제외시켜준다. 현재 숫자와 주어진 숫자들을 3자리 모두 비교하여 숫자와 위치가 모두 같다면 스트라이크를 1 더하고, 숫자가 같으나 위치가 다르다면 볼을 1 더해준다. 만약, 스트라이크와 볼이 주어진 숫자와 같다면 true를 배정한다. 현재 숫자와 주어진 숫자들을 모두 비교했을 때, true값이 있다면 가능한 숫자이므로, answer값을 1 올려준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(vector\u003cvector\u003cint\u003e\u003e baseball) { int answer = 0; for (int i = 123;i \u003c= 987;i++) { string a = to_string(i); bool c = true; if (a[0] == a[1] || a[0] == a[2] || a[1] == a[2] || a[0] == '0' || a[1] == '0' || a[2] == '0') continue; for (int t = 0;t \u003c baseball.size();t++) { string b = to_string(baseball[t][0]); int strike = 0; int ball = 0; for (int y = 0; y \u003c 3; y++) { for (int u = 0;u \u003c 3;u++) { if (a[y] == b[u]) { if (y == u) strike++; else ball++; } } } if (strike != baseball[t][1] || ball != baseball[t][2]) { c = false; break; } } if (c) answer++; } return answer; } ","date":"2019-12-29","objectID":"/2019-12-29-numbaseball/:0:0","tags":["algorithm","C++","완전탐색","Level 2"],"title":"[프로그래머스]숫자 야구","uri":"/2019-12-29-numbaseball/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-29","objectID":"/2019-12-29-camouflage/","tags":["algorithm","C++","해시","Level 2"],"title":"[프로그래머스]위장","uri":"/2019-12-29-camouflage/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 풀이: 각 옷들의 종류에 + 1 한것을 곱한 후 1을 빼준다. 예를들어 옷이 3종류라면, (A + 1)(B + 1)(C + 1) - 1 이 답이 된다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cmap\u003eusing namespace std; int solution(vector\u003cvector\u003cstring\u003e\u003e clothes) { int answer = 1; map\u003cstring, int\u003e a; for (int i = 0;i \u003c clothes.size();i++) a[clothes[i][1]]++; for (auto i = a.begin();i != a.end();i++) answer *= i-\u003esecond + 1; return answer-1; } 시간초과 코드: 사용언어 : c++ #include \u003cvector\u003e#include \u003cstring\u003e#include \u003cmap\u003eusing namespace std; vector\u003cmap\u003cstring, string\u003e\u003e a; void cl(map\u003cstring,string\u003e m, int loc, vector\u003cvector\u003cstring\u003e\u003e c) { a.push_back(m); for (int i = loc + 1;i \u003c c.size();i++) { if (m.find(c[i][1]) == m.end()) { m.insert(pair\u003cstring,string\u003e(c[i][1], c[i][0])); cl(m, i, c); m.erase(c[i][1]); } } } int solution(vector\u003cvector\u003cstring\u003e\u003e clothes) { int l = 0; while (l!=clothes.size()) { map\u003cstring, string\u003e b; b.insert(pair\u003cstring,string\u003e(clothes[l][1], clothes[l][0])); cl(b, l, clothes); l++; } return a.size(); } ","date":"2019-12-29","objectID":"/2019-12-29-camouflage/:0:0","tags":["algorithm","C++","해시","Level 2"],"title":"[프로그래머스]위장","uri":"/2019-12-29-camouflage/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-28","objectID":"/2019-12-28-phonebooklist/","tags":["algorithm","C++","해시","Level 2"],"title":"[프로그래머스]전화번호 목록","uri":"/2019-12-28-phonebooklist/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다. 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다. 구조대 : 119 박준영 : 97 674 223 지영석 : 11 9552 4421 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요. 풀이: phone_book 에 있는 전화번호들을 사전순으로 정렬해 놓는다. 전화번호부에 모든 전화번호를 비교한다. 만약, 현재 보고있는 전화번호가 다음 전화번호의 접두어라면 답을 false로 바꾸고 반복문을 나간다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; bool solution(vector\u003cstring\u003e phone_book) { bool answer = true; sort(phone_book.begin(), phone_book.end()); for (int i = 0;i \u003c phone_book.size() - 1;i++) { if (phone_book[i] == phone_book[i+1].substr(0, phone_book[i].size())) { answer = false; break; } } return answer; } ","date":"2019-12-28","objectID":"/2019-12-28-phonebooklist/:0:0","tags":["algorithm","C++","해시","Level 2"],"title":"[프로그래머스]전화번호 목록","uri":"/2019-12-28-phonebooklist/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-28","objectID":"/2019-12-28-makebignum/","tags":["algorithm","C++","Greedy","Level 2"],"title":"[프로그래머스]큰 수 만들기","uri":"/2019-12-28-makebignum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 풀이: 맨 처음 숫자부터 k번째 숫자까지의 크기를 비교한다. 만약 더 큰 숫자가 있다면 맨 처음 숫자를 제거하는게 이득이므로 제거하고 k를 하나 줄인다. 만약 k번째 숫자까지 더 큰 숫자가 없다면 그 숫자가 제일 큰 숫자이므로 남긴다. 문자열 전체로 반복하며 제거했을 때 k의 숫자가 아직 남아있다면, 마지막부터 k개만큼 제거한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; string solution(string number, int k) { for (int i = 0;i \u003c number.size() - k;i++) { for (int t = i + 1;t \u003c= i + k;t++) { if (number[i] \u003c number[t]) { number.erase(i, 1); k--; i--; break; } } } number.erase(number.size() - k, k); return number; } ","date":"2019-12-28","objectID":"/2019-12-28-makebignum/:0:0","tags":["algorithm","C++","Greedy","Level 2"],"title":"[프로그래머스]큰 수 만들기","uri":"/2019-12-28-makebignum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-27","objectID":"/2019-12-27-intactractangle/","tags":["algorithm","C++","큰 수","Level 2"],"title":"[프로그래머스]멀쩡한 사각형","uri":"/2019-12-27-intactractangle/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다. 가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요. 풀이: 사용할 수 없는 사각형의 갯수는 (가로의 길이 + 세로의 길이 - (가로의 길이와 세로의 길이의 최대공약수)) 로 계산 할 수 있다. 그러므로 답은 (가로의 길이 * 세로의 길이) - 사용할 수 없는 사각형의 갯수 로 구할 수 있다. 코드: 사용언어 : c++ using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } long long solution(int w,int h) { long long c = (long long)w * (long long)h - (w + h - gcd(w, h)); return c; } ","date":"2019-12-27","objectID":"/2019-12-27-intactractangle/:0:0","tags":["algorithm","C++","큰 수","Level 2"],"title":"[프로그래머스]멀쩡한 사각형","uri":"/2019-12-27-intactractangle/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-27","objectID":"/2019-12-27-stockprice/","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]주식가격","uri":"/2019-12-27-stockprice/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요. 풀이: 초 단위로 시간을 흘러가게 한 후 주식가격이 떨어지면 그 시간을 기록하여 answer에 저장한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; vector\u003cint\u003e solution(vector\u003cint\u003e prices) { vector\u003cint\u003e answer; for (int i = 0;i \u003c prices.size();i++) { answer.push_back(0); for (int t = i + 1;t \u003c prices.size();t++) { answer[i]++; if (prices[i] \u003e prices[t]) break; } } return answer; } ","date":"2019-12-27","objectID":"/2019-12-27-stockprice/:0:0","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]주식가격","uri":"/2019-12-27-stockprice/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-27","objectID":"/2019-12-27-printer/","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]프린터","uri":"/2019-12-27-printer/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다. 1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다. 2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다. 3. 그렇지 않으면 J를 인쇄합니다. 예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다. 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다. 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요. 풀이: 현재 대기 목록의 있는 문서 중 맨 앞에 문서가 전체 문서 중 중요도가 제일 높다면 인쇄한다. 만약 전체 문서 중 중요도가 더 큰 문서가 있다면 대기목록 가장 맨 뒤로 이동시킨다. 이 작업을 반복하다가 location 값에있는 위치에 문서가 인쇄된다면 반복을 중지하고, 몇번째로 인쇄되었는지 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(vector\u003cint\u003e priorities, int location) { int first = 0; int c = 0; while (1) { for (int i = first + 1;i \u003c priorities.size();i++) { if (priorities[first] \u003c priorities[i]) { priorities.push_back(priorities[first]); if (location == first) { location = priorities.size() - 1; } c--; break; } } c++; if (location == first) break; first++; } return c; } ","date":"2019-12-27","objectID":"/2019-12-27-printer/:0:0","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]프린터","uri":"/2019-12-27-printer/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-26","objectID":"/2019-12-26-fdevelopment/","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]기능개발","uri":"/2019-12-26-fdevelopment/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 풀이: 맨 처음 기능의 개발이 완료되는 날짜를 구한다. 만약 다음 기능의 개발이 이전 기능 개발보다 빠르다면 배포 개수를 한개 올린다. 만약 이전 기능 개발보다 느리다면, 이전 기능들을 배포한 후 다시 다음 기능이 완료되는 날짜를 구한 후 반복한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; vector\u003cint\u003e solution(vector\u003cint\u003e progresses, vector\u003cint\u003e speeds) { int c = 0; vector\u003cint\u003e answer; for (int i = 0; i \u003c progresses.size(); i++) if (progresses[i] + speeds[i] * c \u003e= 100) answer.back()++; else { c = (int)ceil((double)(100 - progresses[i]) / (double)speeds[i]); answer.push_back(1); } return answer; } ","date":"2019-12-26","objectID":"/2019-12-26-fdevelopment/:0:0","tags":["algorithm","C++","스택/큐","Level 2"],"title":"[프로그래머스]기능개발","uri":"/2019-12-26-fdevelopment/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-26","objectID":"/2019-12-26-bridgetruck/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]다리를 지나는 트럭","uri":"/2019-12-26-bridgetruck/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다. ※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다. 예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리 길이 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 풀이: 큐에 값들을 다리의 길이만큼 0으로 초기화 시켜줌으로써 다리를 만들어 준다. 트럭의 무게가 다리의 무게보다 적을 경우 트럭을 다리에 올리고, 다리의 무게를 트럭의 무게만큼 뺸 후 다리에 끝에 있는 값을 뺀다. 만약 트럭의 무게가 다리의 무게보다 클 경우 아무것도 올릴 수 없으므로 0을 올린다. 이 과정을 1초라고 하고 answer의 값을 1 더해준다. 마지막 트럭이 다리위에 올라갔을 경우, 하나만 쭉 직진하면 됨으로 다리길이 + 1 초만큼 더해준다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int solution(int bridge_length, int weight, vector\u003cint\u003e truck_weights) { int answer = 0; queue\u003cint\u003e a; for (int i = 0;i \u003c bridge_length;i++) { a.push(0); } int c = 0; while (1) { weight += a.front(); a.pop(); if (weight - truck_weights[c] \u003e= 0) { if (c + 1 == truck_weights.size()) { answer += bridge_length + 1; break; } weight -= truck_weights[c]; a.push(truck_weights[c]); c++; } else a.push(0); answer++; } return answer; } ","date":"2019-12-26","objectID":"/2019-12-26-bridgetruck/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]다리를 지나는 트럭","uri":"/2019-12-26-bridgetruck/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-26","objectID":"/2019-12-26-skilltree/","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]스킬트리","uri":"/2019-12-26-skilltree/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다. 예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다. 위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다. 선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요. 풀이: 유저들이 만든 스킬트리를 처음 부터 살펴본다. 만약 스킬이 선행스킬에 처음에 있다면 선행스킬을 배웠음을 체크한다. 만약 스킬이 선행스킬에 없다면 그냥 배울 수 있으므로 패스한다. 만약 스킬이 선행스킬을 배우지 않은 채 다음 선행스킬에 있다면, 스킬을 배울수 없으므로 반복문을 나간다. 코드: 사용언어 : c++ #include \u003cstdio.h\u003e#include \u003cstdbool.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e// 파라미터로 주어지는 문자열은 const로 주어집니다. 변경하려면 문자열을 복사해서 사용하세요. // skill_trees_len은 배열 skill_trees의 길이입니다. int solution(const char* skill, const char* skill_trees[], size_t skill_trees_len) { int answer = 0; for (int i = 0;i \u003c skill_trees_len;i++) { bool b = true; int c = 0; for (int t = 0;t \u003c strlen(skill_trees[i]);t++) { if (skill_trees[i][t] == skill[c]) c++; else { for (int y = c + 1;y \u003c strlen(skill);y++) { if (skill_trees[i][t] == skill[y]) { b = false; break; } } } } if (b) answer++; } return answer; } ","date":"2019-12-26","objectID":"/2019-12-26-skilltree/:0:0","tags":["algorithm","C++","Level 2"],"title":"[프로그래머스]스킬트리","uri":"/2019-12-26-skilltree/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-25","objectID":"/2019-12-25-turnnnum/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]자연수 뒤집어 배열로 만들기","uri":"/2019-12-25-turnnnum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열을 리턴한다. 코드: 사용언어 : c++ #include \u003cstdio.h\u003e#include \u003cstdbool.h\u003e#include \u003cstdlib.h\u003e int* solution(long long n) { // 리턴할 값은 메모리를 동적 할당해주세요. int* answer = (int*)malloc(sizeof(int)*12 + 1); int c = 0; while (n) { answer[c] = n % 10; n /= 10; c++; } return answer; } ","date":"2019-12-25","objectID":"/2019-12-25-turnnnum/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]자연수 뒤집어 배열로 만들기","uri":"/2019-12-25-turnnnum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-24","objectID":"/2019-12-24-sumpnum/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]자릿수 더하기","uri":"/2019-12-24-sumpnum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 자연수 n의 각 자릿수의 합을 구해서 리턴한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e using namespace std; int solution(int n) { int answer = 0; while (n != 0) { answer += n % 10; n /= 10; } return answer; } ","date":"2019-12-24","objectID":"/2019-12-24-sumpnum/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]자릿수 더하기","uri":"/2019-12-24-sumpnum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-23","objectID":"/2019-12-23-strangestring/","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]이상한 문자 만들기","uri":"/2019-12-23-strangestring/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 문제: 문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요. 풀이: 문자열 전체의 짝/홀수 인덱스가 아니라 각 단어 기준이므로 주의한다. 공백문자가 하나가 아닐 수도 있으므로 주의한다. 공백문자를 기준으로 단어를 나누므로, 공백문자가 나왔을 경우 카운트를 초기화하는 식으로 문자열을 나눈다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; string solution(string s) { int c = 0; for (int i = 0;i \u003c s.size();i++) { if (s[i] == ' ') c = 0; else { if (c % 2 == 0) s[i] = toupper(s[i]); else if (c % 2 == 1) s[i] = tolower(s[i]); c++; } } return s; } ","date":"2019-12-23","objectID":"/2019-12-23-strangestring/:0:0","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]이상한 문자 만들기","uri":"/2019-12-23-strangestring/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-22","objectID":"/2019-12-22-sumnums/","tags":["algorithm","C++","큰 수","Level 1"],"title":"[프로그래머스]두 정수 사이의 합","uri":"/2019-12-22-sumnums/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 두 수 a, b 사이에 속한 모든 정수의 합을 리턴한다. a와 b는 -10,000,000 이상 10,000,000 이하인 정수 이므로 주의한다. a와 b의 대소관계가 정해져 있지 않으므로 절댓값을 이용한다. 코드: 사용언어 : c++ #include \u003cstdio.h\u003e#include \u003cstdbool.h\u003e#include \u003cstdlib.h\u003e long long solution(int a, int b) { long long answer = ((long)a + (long)b) * (abs((long)b - (long)a) + 1) / 2; return answer; } ","date":"2019-12-22","objectID":"/2019-12-22-sumnums/:0:0","tags":["algorithm","C++","큰 수","Level 1"],"title":"[프로그래머스]두 정수 사이의 합","uri":"/2019-12-22-sumnums/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-22","objectID":"/2019-12-22-sumdivisor/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]약수의 합","uri":"/2019-12-22-sumdivisor/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 정수 n의 모든 약수의 합을 리턴한다. 코드: 사용언어 : c++ #include \u003cstdio.h\u003e#include \u003cstdbool.h\u003e#include \u003cstdlib.h\u003e int solution(int n) { int answer = 0; for (int i = 1;i \u003c= n;i++) if (n % i == 0) answer += i; return answer; } ","date":"2019-12-22","objectID":"/2019-12-22-sumdivisor/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]약수의 합","uri":"/2019-12-22-sumdivisor/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-21","objectID":"/2019-12-21-middlenum/","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]가운데 글자 가져오기","uri":"/2019-12-21-middlenum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 문자열 s의 가운데 글자를 리턴한다. 만약 문자열 s의 길이가 짝수라면 가운데 두 글자를 반환한다 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; string solution(string s) { string answer; if (s.length() % 2 == 0) { answer = s[s.length() / 2 - 1]; answer += s[s.length() / 2]; } else { answer = s[s.length() / 2]; } return answer; } ","date":"2019-12-21","objectID":"/2019-12-21-middlenum/:0:0","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]가운데 글자 가져오기","uri":"/2019-12-21-middlenum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-21","objectID":"/2019-12-21-caesarcipher/","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]시저 암호","uri":"/2019-12-21-caesarcipher/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 문자열 s를 n만큼 밀어서 나온 다른 알파벳의 결과값을 리턴한다. 중간에 공백문자가 있을 수 있으니 주의한다. ‘z’를 밀 경우 ‘A’가 아니라 ‘a’가 나와야 하므로 주의한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; string solution(string s, int n) { for (int i = 0;i \u003c s.size();i++) { if (isalpha(s[i])) { if (s[i] + n \u003e 'z') { s[i] = 96 + (s[i] + n) % 'z'; } else if (s[i] \u003c= 'Z' \u0026\u0026 s[i] + n \u003e 'Z') { s[i] = 64 + (s[i] + n) % 'Z'; } else s[i] += n; } } return s; } ","date":"2019-12-21","objectID":"/2019-12-21-caesarcipher/:0:0","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]시저 암호","uri":"/2019-12-21-caesarcipher/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-20","objectID":"/2019-12-20-dividednum/","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]나누어 떨어지는 숫자 배열","uri":"/2019-12-20-dividednum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: arr의 각 원소 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 리턴한다. 만약 배열의 원소가 없다면 -1을 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; vector\u003cint\u003e solution(vector\u003cint\u003e arr, int divisor) { vector\u003cint\u003e answer; for (int i : arr) { if (i % divisor == 0) answer.push_back(i); } sort(answer.begin(), answer.end()); if(answer.size()==0) answer.push_back(-1); return answer; } ","date":"2019-12-20","objectID":"/2019-12-20-dividednum/:0:0","tags":["algorithm","C++","Level 1"],"title":"[프로그래머스]나누어 떨어지는 숫자 배열","uri":"/2019-12-20-dividednum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-20","objectID":"/2019-12-20-stoi/","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]문자열을 정수로 바꾸기","uri":"/2019-12-20-stoi/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 문자열 s를 숫자로 변환한 결과를 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(string s) { int answer = stoi(s); return answer; } ","date":"2019-12-20","objectID":"/2019-12-20-stoi/:0:0","tags":["algorithm","C++","문자열","Level 1"],"title":"[프로그래머스]문자열을 정수로 바꾸기","uri":"/2019-12-20-stoi/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-19","objectID":"/2019-12-19-samesum/","tags":["algorithm","C++"],"title":"[프로그래머스]같은 숫자는 싫어","uri":"/2019-12-19-samesum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 배열 arr에서 연속적인 숫자는 하나를 제외하고 모두 삭제한 배열을 리턴한다. 코드: 사용언어 : c++ #include \u003cvector\u003e#include \u003ciostream\u003e using namespace std; vector\u003cint\u003e solution(vector\u003cint\u003e arr) { vector\u003cint\u003e answer; for (int i : arr) { if (answer.size() \u003e 0) { if (answer.back() != i) { answer.push_back(i); } } else { answer.push_back(i); } } return answer; } ","date":"2019-12-19","objectID":"/2019-12-19-samesum/:0:0","tags":["algorithm","C++"],"title":"[프로그래머스]같은 숫자는 싫어","uri":"/2019-12-19-samesum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-19","objectID":"/2019-12-19-findpnum/","tags":["algorithm","C++","소수"],"title":"[프로그래머스]소수 찾기","uri":"/2019-12-19-findpnum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 2이상 n이하의 수들 중 소수의 갯수를 구하여 출력한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; int solution(int n) { vector\u003cint\u003e q = { 2 }; for (int i = 3;i \u003c= n;i++) { bool w = true; for (int t : q) { if (t \u003e sqrt(i)) { break; } if (i % t == 0) { w = false; break; } } if (w == true) { q.push_back(i); } } return q.size(); } 시간 초과 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; int solution(int n) { int a = 1; for (int i = 3;i \u003c= n;i++) { for (int t = 2;t \u003c= sqrt(i);t++) { if (i % t == 0) { a++; break; } } } return n - a; } 더 효율 적인 코드: 사용언어 : c++ 에라토스테네스의 체를 이용 https://ko.wikipedia.org/wiki/에라토스테네스의_체 #include \u003cstring\u003e#include \u003cvector\u003eusing namespace std; int solution(int n) { int answer = 0; vector\u003cbool\u003e q(n+1, true); for (int i = 2; i \u003c= n ; i++) { if (q[i]){ for (int j = i * i; j \u003c= n; j += i) q[j] = false; answer++; } } return answer; } ","date":"2019-12-19","objectID":"/2019-12-19-findpnum/:0:0","tags":["algorithm","C++","소수"],"title":"[프로그래머스]소수 찾기","uri":"/2019-12-19-findpnum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-19","objectID":"/2019-12-19-subaksubak/","tags":["algorithm","C++","문자열"],"title":"[프로그래머스]수박수박수박수박수박수?","uri":"/2019-12-19-subaksubak/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: “수박수박수…” 의 패턴을 유지하는 n만큼의 길이의 문자열을 리턴한다. 코드: 사용언어 : c++ #include \u003cstdio.h\u003e#include \u003cstdbool.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e char* solution(int n) { bool c = true; char a[] = \"수\"; char b[] = \"박\"; char* answer = (char*)malloc(sizeof(char)*3*n + 1); for (int i = 0;i \u003c 3*n;i+=3) { if (c) { strcpy(answer + i, a); c = false; } else { strcpy(answer + i, b); c = true; } } return answer; } ","date":"2019-12-19","objectID":"/2019-12-19-subaksubak/:0:0","tags":["algorithm","C++","문자열"],"title":"[프로그래머스]수박수박수박수박수박수?","uri":"/2019-12-19-subaksubak/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-18","objectID":"/2019-12-18-findkim/","tags":["algorithm","C++","문자열"],"title":"[프로그래머스]서울에서 김서방 찾기","uri":"/2019-12-18-findkim/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: string 배열 seoul의 원소 중 “Kim\"의 위치를 찾아 반환한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; string solution(vector\u003cstring\u003e seoul) { for (int i = 0;i \u003c seoul.size();i++) if (seoul[i] == \"Kim\") return \"김서방은 \" + to_string(i) + \"에 있다\"; } ","date":"2019-12-18","objectID":"/2019-12-18-findkim/:0:0","tags":["algorithm","C++","문자열"],"title":"[프로그래머스]서울에서 김서방 찾기","uri":"/2019-12-18-findkim/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-17","objectID":"/2019-12-17-stringbase/","tags":["algorithm","C++","문자열"],"title":"[프로그래머스]문자열 다루기 기본","uri":"/2019-12-17-stringbase/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 문자열 s의 길이가 4 또는 6 이고, 숫자로만 구성되어있는지 확인 후 아니라면 false를 리턴 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; bool solution(string s) { bool answer = true; if (s.length() != 4 \u0026\u0026 s.length() != 6) { answer = false; } else { for (int i = 0;i \u003c s.length();i++) { if (s[i] \u003e '9') { answer = false; break; } } } return answer; } ","date":"2019-12-17","objectID":"/2019-12-17-stringbase/:0:0","tags":["algorithm","C++","문자열"],"title":"[프로그래머스]문자열 다루기 기본","uri":"/2019-12-17-stringbase/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-16","objectID":"/2019-12-16-py/","tags":["algorithm","C++"],"title":"[프로그래머스]문자열 내 p와 y의 개수","uri":"/2019-12-16-py/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 문자열 s의 모든 원소를 보고 p,P 이면 p의 갯수를 올리고, y,Y이면 y의 갯수를 올린다. p의 갯수와 y의 갯수가 같다면 true 다르다면 false 를 리턴한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003ciostream\u003eusing namespace std; bool solution(string s) { bool answer = true; int p = 0; int y = 0; for (int i = 0;i \u003c s.length();i++) { if (s[i] == 'p' || s[i] == 'P') { p++; } if (s[i] == 'y' || s[i] == 'Y') { y++; } } if (p != y) answer = false; return answer; } ","date":"2019-12-16","objectID":"/2019-12-16-py/:0:0","tags":["algorithm","C++"],"title":"[프로그래머스]문자열 내 p와 y의 개수","uri":"/2019-12-16-py/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-15","objectID":"/2019-12-15-gymclothes/","tags":["algorithm","C++","greedy"],"title":"[프로그래머스]체육복","uri":"/2019-12-15-gymclothes/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 학생 전체 중 체육복을 잃어버린 학생과 체육복을 추가로 가져온 학생을 정리한다.(체육복을 추가로 가져온 학생들 중 체육복을 잃어버린 학생이 있을 수 있기 때문에) 체육복이 없는 학생 중 양 옆에 여벌의 체육복을 가져온 학생이 있는경우 빌려입는다. 전체 학생 중 체육복이 1개 이상 있는 학생들의 수를 리턴한다. 주의 사항: 체육복을 추가로 가져온 학생들 중 체육복을 잃어버린 학생이 있을 수 있다. 체육복을 추가로 가져오지 않았을 경우, 옆 사람에게 체육복을 추가로 얻어도 다른 사람에게 양도할 수 없다. 학생들의 순서는 항상 오름차순으로 정렬되어 있지 않다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int solution(int n, vector\u003cint\u003e lost, vector\u003cint\u003e reserve) { int answer = 0; int a[32]; fill(a, a + 32, 1); while (1) { if (lost.size() == 0 \u0026\u0026 reserve.size() == 0) break; if (lost.size() \u003e 0) { a[lost.back()]--; lost.pop_back(); } if (reserve.size() \u003e 0) { a[reserve.back()]++; reserve.pop_back(); } } for (int i = 1;i \u003c= n;i++) { if (a[i] == 0) { if (a[i + 1] == 2) { a[i]++; a[i + 1]--; } else if (a[i - 1] == 2) { a[i]++; a[i - 1]--; } } if (a[i] \u003e= 1) answer++; } return answer; } ","date":"2019-12-15","objectID":"/2019-12-15-gymclothes/:0:0","tags":["algorithm","C++","greedy"],"title":"[프로그래머스]체육복","uri":"/2019-12-15-gymclothes/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-14","objectID":"/2019-12-14-knum/","tags":["algorithm","C++","정렬"],"title":"[프로그래머스]k번째 수","uri":"/2019-12-14-knum/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: array 배열의 commands[0]번째부터 commands[1]번째 까지 자른 후 정렬한다. 자른 배열의 commands[2] 번째 숫자를 출력한다. commands 배열의 길이만큼 반복한다. 코드: 사용언어 : c++ #include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e using namespace std; vector\u003cint\u003e solution(vector\u003cint\u003e array, vector\u003cvector\u003cint\u003e\u003e commands) { vector\u003cint\u003e answer; for(int i=0;i\u003ccommands.size();i++){ vector\u003cint\u003e a = array; sort(a.begin()+commands[i][0]-1,a.begin()+commands[i][1]); answer.push_back(a[commands[i][0] + commands[i][2] - 2]); } return answer; } ","date":"2019-12-14","objectID":"/2019-12-14-knum/:0:0","tags":["algorithm","C++","정렬"],"title":"[프로그래머스]k번째 수","uri":"/2019-12-14-knum/"},{"categories":["프로그래머스"],"content":"algorithm","date":"2019-12-13","objectID":"/2019-12-13-2016%EB%85%84/","tags":["algorithm","C++","수학"],"title":"[프로그래머스]2016년","uri":"/2019-12-13-2016%EB%85%84/"},{"categories":["프로그래머스"],"content":"https://programmers.co.kr 풀이: 매 달 날짜를 계산하여 원하는 날짜의 요일을 구한다, 주의사항: 2016년은 윤년이다. 1월 1일은 금요일이다. 코드: 사용언어 : c++ #include \u003cstdio.h\u003e#include \u003cstdbool.h\u003e#include \u003cstdlib.h\u003e char* solution(int a, int b) { // 리턴할 값은 메모리를 동적 할당해주세요. int m[13] = { 0,31,29,31,30,31,30,31,31,30,31,30,31 }; const char *d[8]= { \"THU\",\"FRI\",\"SAT\",\"SUN\",\"MON\",\"TUE\",\"WED\" }; for(int i = 1;i \u003c a;i++) { b += m[i]; } b %= 7; return d[b]; } ","date":"2019-12-13","objectID":"/2019-12-13-2016%EB%85%84/:0:0","tags":["algorithm","C++","수학"],"title":"[프로그래머스]2016년","uri":"/2019-12-13-2016%EB%85%84/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-20","objectID":"/2019-06-20-11399/","tags":["algorithm","C++","greedy"],"title":"[백준]11399 ATM","uri":"/2019-06-20-11399/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11399 풀이: 돈을 인출하는데 필요한 시간을 입력받는다. 입력받은 시간을 정렬한다. 정렬한 값을 n-i를 곱해서 더해준다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main() { int n,r=0,a[1001]; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; sort(\u0026a[0], \u0026a[n]); for (int i = 0; i \u003c n; i++) r += a[i] * (n - i); cout \u003c\u003c r \u003c\u003c endl; } ","date":"2019-06-20","objectID":"/2019-06-20-11399/:0:0","tags":["algorithm","C++","greedy"],"title":"[백준]11399 ATM","uri":"/2019-06-20-11399/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-19","objectID":"/2019-06-19-2609/","tags":["algorithm"],"title":"[백준]2609 최대공약수와 최소공배수","uri":"/2019-06-19-2609/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2609 풀이: 두 수를 입력받는다. 두 수의 최대공약수와 최소공배수를 출력한다. 코드: 사용언어 : Python 3 import math a,b=map(int,input().split()) c=math.gcd(a,b) print(c,a//c*b) ","date":"2019-06-19","objectID":"/2019-06-19-2609/:0:0","tags":["algorithm"],"title":"[백준]2609 최대공약수와 최소공배수","uri":"/2019-06-19-2609/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-18","objectID":"/2019-06-18-14490/","tags":["algorithm"],"title":"[백준]14490 백대열","uri":"/2019-06-18-14490/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/14490 풀이: 두 수를 입력받는다(:을 사이에 두고 주어지므로 주의) 두 수의 최대공약수를 구한다. 두 수를 최대공약수로 나눠서 출력한다(최대한으로 약분은 최대공약수로 나누어주면 가능하다)(이때 :을 사이에 두고 출력한다.) 코드: 사용언어 : Python 3 import math a,b=map(int,input().split(':')) c=math.gcd(a,b) print(a//c,b//c,sep=':') ","date":"2019-06-18","objectID":"/2019-06-18-14490/:0:0","tags":["algorithm"],"title":"[백준]14490 백대열","uri":"/2019-06-18-14490/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-17","objectID":"/2019-06-17-1850/","tags":["algorithm"],"title":"[백준]1850 최대공약수","uri":"/2019-06-17-1850/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1850 풀이: 두 수를 입력받는다 두 수의 최대공약수를 구한다. 최대공약수만큼 1을 반복해서 출력한다. 코드: 사용언어 : Python 3 a,b=map(int,input().split()) while b: a,b=b,a%b print('1'*a) ","date":"2019-06-17","objectID":"/2019-06-17-1850/:0:0","tags":["algorithm"],"title":"[백준]1850 최대공약수","uri":"/2019-06-17-1850/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-16","objectID":"/2019-06-16-10757/","tags":["algorithm","Python","수학"],"title":"[백준]10757 큰 수 A+B","uri":"/2019-06-16-10757/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10757 풀이: 두 수를 입력받은 후 더해서 출력한다. 코드: 사용언어 : Python 3 print(sum(map(int,input().split()))) ","date":"2019-06-16","objectID":"/2019-06-16-10757/:0:0","tags":["algorithm","Python","수학"],"title":"[백준]10757 큰 수 A+B","uri":"/2019-06-16-10757/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-15","objectID":"/2019-06-15-10826/","tags":["algorithm","Python","수학"],"title":"[백준]10826 피보나치 수 4","uri":"/2019-06-15-10826/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10826 풀이: n을 입력받는다 n번째 피보나치 수를 출력한다 코드: 사용언어 : Python 3 s,t=0,1 for i in range(int(input())): t,s=s,s+t print(s) ","date":"2019-06-15","objectID":"/2019-06-15-10826/:0:0","tags":["algorithm","Python","수학"],"title":"[백준]10826 피보나치 수 4","uri":"/2019-06-15-10826/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-14","objectID":"/2019-06-14-11050/","tags":["algorithm","Python","수학"],"title":"[백준]11050 이항 계수 1","uri":"/2019-06-14-11050/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11050 풀이: n, k 를 입력받고, nCk를 출력한다 코드: 사용언어 : Python 3 n,k=map(int,input().split()) r=1 for i in range(k): r*=(n-i)/(i+1) print((int)(r)) ","date":"2019-06-14","objectID":"/2019-06-14-11050/:0:0","tags":["algorithm","Python","수학"],"title":"[백준]11050 이항 계수 1","uri":"/2019-06-14-11050/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-13","objectID":"/2019-06-13-11365/","tags":["algorithm","Python","문자열"],"title":"[백준]11365 !밀비 급일","uri":"/2019-06-13-11365/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11365 풀이: 문자열을 입력받고, 그 문자열을 뒤집어서 출력한다. 문자열이 END라면 반복을 중지한다. 코드: 사용언어 : Python 3 while 1: a=input() if a=='END':break print(a[::-1]) ","date":"2019-06-13","objectID":"/2019-06-13-11365/:0:0","tags":["algorithm","Python","문자열"],"title":"[백준]11365 !밀비 급일","uri":"/2019-06-13-11365/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-12","objectID":"/2019-06-12-10952/","tags":["algorithm","Python","수학"],"title":"[백준]10952 A+B - 5","uri":"/2019-06-12-10952/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10952 풀이: 반복 횟수를 무한히 한 후 입력받은 두 수의 합을 출력 입력받은 두 수가 0 0 이라면 반복문을 빠져나간다. 코드: 사용언어 : Python 3 while 1: a,b=map(int,input().split()) if a==0:break print(a+b) ","date":"2019-06-12","objectID":"/2019-06-12-10952/:0:0","tags":["algorithm","Python","수학"],"title":"[백준]10952 A+B - 5","uri":"/2019-06-12-10952/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-11","objectID":"/2019-06-11-15552/","tags":["algorithm","Python","수학"],"title":"[백준]15552 빠른 A+B","uri":"/2019-06-11-15552/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/15552 풀이: 반복 횟수를 입력받은 후 입력받은 두 수의 합을 출력 간단한 문제이지만 매우 많은 테스트케이스의 수가 있으므로 input() 대신 sys.stdin().readline()을 사용한다. 코드: 사용언어 : Python 3 import sys for i in range(int(input())): print(sum(map(int,sys.stdin.readline().split()))) ","date":"2019-06-11","objectID":"/2019-06-11-15552/:0:0","tags":["algorithm","Python","수학"],"title":"[백준]15552 빠른 A+B","uri":"/2019-06-11-15552/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-10","objectID":"/2019-06-10-10950/","tags":["algorithm","Python","수학"],"title":"[백준]10950 A+B - 3","uri":"/2019-06-10-10950/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10950 풀이: 반복 횟수를 입력받은 후 입력받은 두 수의 합을 출력 코드: 사용언어 : Python 3 for i in range(int(input())): print(sum(map(int,input().split()))) ","date":"2019-06-10","objectID":"/2019-06-10-10950/:0:0","tags":["algorithm","Python","수학"],"title":"[백준]10950 A+B - 3","uri":"/2019-06-10-10950/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-09","objectID":"/2019-06-09-10971/","tags":["algorithm","C++","외판원 순회"],"title":"[백준]10971 외판원 순회 2","uri":"/2019-06-09-10971/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10971 풀이: [백준]2098 외판원순회 와 같으므로 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int w[17][17],d[17][100000], n; int T(int a, int b) { if ((1 \u003c\u003c n) - 1 == b \u0026\u0026 w[a][0] != 0) return w[a][0]; int \u0026r = d[a][b]; if (r \u003e 0) return r; r = 100000000; for (int i = 0; i \u003c n; i++) if (w[a][i] != 0 \u0026\u0026 (b \u0026 (1 \u003c\u003c i)) == 0) r = min(r, w[a][i] + T(i, b | (1 \u003c\u003c i))); return r; } int main(void) { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c n; t++) cin \u003e\u003e w[i][t]; cout \u003c\u003c T(0, 1) \u003c\u003c endl; return 0; } ","date":"2019-06-09","objectID":"/2019-06-09-10971/:0:0","tags":["algorithm","C++","외판원 순회"],"title":"[백준]10971 외판원 순회 2","uri":"/2019-06-09-10971/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-08","objectID":"/2019-06-08-11047/","tags":["algorithm","C++","greedy"],"title":"[백준]11047 동전 0","uri":"/2019-06-08-11047/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11047 풀이: 동전에 가격이 높은 것 부터 내가 필요한 가격에서 빼준다. 빼준 횟수만큼 카운트를 높여준다. 카운트를 출력한다. ( i ≥ 2인 경우에 Ai는 Ai-1의 배수) 조건으로 인해 그냥 높은 것 부터 빼줘도 문제가 생기지않는다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int main() { int n, k, s[12], c = 0; cin \u003e\u003e n \u003e\u003e k; while (n--) cin \u003e\u003e s[n]; while (k) { c += k / s[++n]; k %= s[n]; } cout \u003c\u003c c \u003c\u003c endl; return 0; } ","date":"2019-06-08","objectID":"/2019-06-08-11047/:0:0","tags":["algorithm","C++","greedy"],"title":"[백준]11047 동전 0","uri":"/2019-06-08-11047/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-07","objectID":"/2019-06-07-2164/","tags":["algorithm","Python","수학"],"title":"[백준]2164 카드2","uri":"/2019-06-07-2164/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2164 풀이: 카드의 갯수가 2 ^ i 개일 경우 남게 되는 카드의 번호는 2 ^ i 이다. 카드의 갯수가 (2 ^ i) + n 개 일 경우 남게 되는 카드의 번호는 2 * n 이다. 코드: 사용언어 : Python 3 n,s=int(input()),1 while s\u003cn: s*=2 print(s if s==n else 2*n-s) ","date":"2019-06-07","objectID":"/2019-06-07-2164/:0:0","tags":["algorithm","Python","수학"],"title":"[백준]2164 카드2","uri":"/2019-06-07-2164/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-06","objectID":"/2019-06-06-12015/","tags":["algorithm","C++","DP"],"title":"[백준]12015 가장 긴 증가하는 부분 수열 2","uri":"/2019-06-06-12015/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/12015 풀이: https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; vector\u003cint\u003ed; int main(void) { int n, s, l; cin \u003e\u003e n; while (n--) { cin \u003e\u003e s; l = lower_bound(d.begin(), d.end(), s) - d.begin(); if (l == d.size()) d.push_back(s); else d[l] = s; } cout \u003c\u003c d.size() \u003c\u003c endl; return 0; } ","date":"2019-06-06","objectID":"/2019-06-06-12015/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]12015 가장 긴 증가하는 부분 수열 2","uri":"/2019-06-06-12015/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-05","objectID":"/2019-06-05-1365/","tags":["algorithm","C++","LIS"],"title":"[백준]1365 꼬인 전깃줄","uri":"/2019-06-05-1365/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1365 풀이: https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; vector\u003cint\u003ed; int main(void) { int n, s, l; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e s; l = lower_bound(d.begin(), d.end(), s) - d.begin(); if (l == d.size()) d.push_back(s); else d[l] = s; } cout \u003c\u003c n - d.size() \u003c\u003c endl; return 0; } ","date":"2019-06-05","objectID":"/2019-06-05-1365/:0:0","tags":["algorithm","C++","LIS"],"title":"[백준]1365 꼬인 전깃줄","uri":"/2019-06-05-1365/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-04","objectID":"/2019-06-04-2352/","tags":["algorithm","C++","greedy","DP","LIS"],"title":"[백준]2352 반도체 설계","uri":"/2019-06-04-2352/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2352 풀이: 맨 처음 값부터 하나 하나 입력받는다. 입력받은 값이 벡터 안에 있는 값들 보다 크다면 벡터에 맨 뒤에 넣는다. 벡터의 처음부터 검색했을 때, 입력받은 값보다 큰 값이 있다면, 그 값과 교체한다. 벡터의 원소 갯수를 출력한다. 일반적으로 for문을 두개 쓴 O(n^2)의 코드는 시간초과가 나므로 주의하자 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; vector\u003cint\u003ed; int main(void) { int n, s, l; cin \u003e\u003e n; while(n--) { cin \u003e\u003e s; l = lower_bound(d.begin(), d.end(), s) - d.begin(); if (l == d.size()) d.push_back(s); else d[l] = s; } cout \u003c\u003c d.size() \u003c\u003c endl; return 0; } 시간 초과 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int s[40001], d[40001], r = 0; int main(void) { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e s[i]; for (int t = 0; t \u003c i; t++) { if (s[i] \u003e s[t]) d[i] = max(d[i], d[t]); } d[i]++; r = max(r, d[i]); } cout \u003c\u003c r \u003c\u003c endl; return 0; } ","date":"2019-06-04","objectID":"/2019-06-04-2352/:0:0","tags":["algorithm","C++","greedy","DP","LIS"],"title":"[백준]2352 반도체 설계","uri":"/2019-06-04-2352/"},{"categories":["백준"],"content":"algorithm","date":"2019-06-02","objectID":"/2019-06-02-1495/","tags":["algorithm","C++","DP"],"title":"[백준]1495 기타리스트","uri":"/2019-06-02-1495/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1495 풀이: dp[a][b]를 a 번째 곡을 연주 할 때, b 볼륨으로 연주 할 수 있는가? 라고 하자. dp[0][S]는 0 번째 곡을 연주 할 때, S 볼륨으로 연주할 수 있으므로(시작지점) 1을 할당한다. 0번째 곡을 연주할 때, S볼륨으로 연주가 가능하다면, 1번째 곡을 연주할 때, S+s[1] or S-s[1] 볼륨도 연주 가능하다(0\u003c=볼륨\u003c=m 일때) 즉, dp[i][t + s[i]] = dp[i - 1][t] or dp[i][t - s[i]] = dp[i - 1][t] 마지막에 dp[N]값을 모두 순환하며, 가장 높은 값을 출력하고, 가능한 볼륨이 없다면 -1을 출력한다. 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int s, N, S, M; bool d[102][1002]; int main(void) { cin \u003e\u003e N \u003e\u003e S \u003e\u003e M; d[0][S] = 1; for (int i = 1; i \u003c= N; i++) { cin \u003e\u003e s; for (int t = 0; t \u003c= M; t++) if (d[i - 1][t]) { if (t \u003e= s) d[i][t - s] = 1; if (t + s \u003c= M) d[i][t + s] = 1; } } s = -1; for (int i = 0; i \u003c= M; i++) if (d[N][i]) s = i; cout \u003c\u003c s \u003c\u003c endl; return 0; } ","date":"2019-06-02","objectID":"/2019-06-02-1495/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1495 기타리스트","uri":"/2019-06-02-1495/"},{"categories":["백준"],"content":"algorithm","date":"2019-05-30","objectID":"/2019-05-30-4781/","tags":["algorithm","C++","DP"],"title":"[백준]4781 사탕 가게","uri":"/2019-05-30-4781/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/4781 풀이: dp[a]를 a원으로 구매할 수 있는 가장 높은 칼로리라고 한다. 사탕의 칼로리를 s, 가격을 d라고 했을 때, 현제 a원으로 구매할 수 있는 가장 높은 칼로리와 a-d원 으로 구매할 수 있는 가장높을칼로리 + s 를 비교하여 높은 값으로 교체한다. 즉, dp[t] = max(dp[t], dp[t - d] + s) 를 반복하여 do[m]값을 구한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003eusing namespace std; double M1, d1; int N, M, s, d, dp[10002]; int main(void) { while (1) { memset(dp, 0, sizeof(dp)); cin \u003e\u003e N \u003e\u003e M1; if (N == 0) break; M = M1 * 100; for (int i = 0; i \u003c N; i++) { cin \u003e\u003e s \u003e\u003e d1; d = d1 * 100; for (int t = d; t \u003c= M; t++) dp[t] = max(dp[t], dp[t - d] + s); } cout \u003c\u003c dp[M] \u003c\u003c endl; } return 0; } ","date":"2019-05-30","objectID":"/2019-05-30-4781/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]4781 사탕 가게","uri":"/2019-05-30-4781/"},{"categories":["백준"],"content":"algorithm","date":"2019-05-29","objectID":"/2019-05-29-2662/","tags":["algorithm","C++","DP"],"title":"[백준]2662 기업 투자","uri":"/2019-05-29-2662/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2662 풀이: dp[a][b]를 남은 금액이 a원 일 때, b번째 기업에 투자해서 얻을 수 있는 최대 이익이라고 하자. 첫번째 기업에 0원을 투자하는 것 부터 M번째 기업에 N원을 투자하는 것 까지 반복하여 최대 이익금을 구한다. 최대 이익금일 때 각 기업에 얼마를 투자했는지 구한 후 출력한다. 시간초과가 나기 쉬우므로 메모이제이션을 한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003ccstring\u003eusing namespace std; int N, M, s[302][22], dp[302][22], x[302][22]; int q(int a, int c) { if (c \u003e M) return 0; int \u0026m = dp[a][c]; if (m != -1) return m; m = 0; for (int i = 0; i \u003c= a; i++){ int n = s[i][c] + q(a - i, c + 1); if (m \u003c n) { m = n; x[a][c] = i; } } return m; } int main(void) { cin \u003e\u003e N \u003e\u003e M; memset(dp, -1, sizeof(dp)); for (int i = 1; i \u003c= N; i++) for (int t = 0; t \u003c= M; t++) cin \u003e\u003e s[i][t]; cout \u003c\u003c q(N, 1) \u003c\u003c endl; for (int i = 1; i \u003c= M; i++) { cout \u003c\u003c x[N][i] \u003c\u003c \" \"; N -= x[N][i]; } cout \u003c\u003c endl; return 0; } ","date":"2019-05-29","objectID":"/2019-05-29-2662/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2662 기업 투자","uri":"/2019-05-29-2662/"},{"categories":["백준"],"content":"algorithm","date":"2019-05-28","objectID":"/2019-05-28-1937/","tags":["algorithm","C++","DP","정렬","LIS"],"title":"[백준]1937 욕심쟁이 판다","uri":"/2019-05-28-1937/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1937 풀이: k[a][b]를 (a , b)지점에서 시작한 판다가 살아남은 최대 일수라고 한다. (a, b) 주변 십자가 방향 지점( (1,0), (-1, 0), (0, 1), (0, -1)) 에서 대나무의 양이 (a, b) 보다 낮다면 그 지점에 최대 일수에서 +1 한 값이 k[a][b] 값이 된다. 높은 값에서 낮은값으로 찾아가면서 최대 일수를 구한다. 시간초과가 날 수 있으므로 메모이제이션을 통해 시행횟수를 제한해준다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, s[510][510], k[510][510]; int dx[] = { 1,0,0,-1 }; int dy[] = { 0,1,-1,0 }; int panda(int a, int b){ for (int y = 0; y \u003c 4; y++) if (a + dy[y] \u003e= 0 \u0026\u0026 a + dy[y] \u003c n \u0026\u0026 b + dx[y] \u003e= 0 \u0026\u0026 b + dx[y] \u003c n) if (s[a][b] \u003c s[a + dy[y]][b + dx[y]]) { if(k[a + dy[y]][b + dx[y]] == 1) k[a][b] = max(k[a][b], panda(a + dy[y], b + dx[y]) + 1); else k[a][b] = max(k[a][b], k[a + dy[y]][b + dx[y]] + 1); } return k[a][b]; } int main(void) { cin \u003e\u003e n; int m = 1; fill(\u0026k[0][0], \u0026k[n][n], 1); for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c n; t++) cin \u003e\u003e s[i][t]; for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c n; t++) m = max(m, panda(i, t)); cout \u003c\u003c m \u003c\u003c endl; return 0; } ","date":"2019-05-28","objectID":"/2019-05-28-1937/:0:0","tags":["algorithm","C++","DP","정렬","LIS"],"title":"[백준]1937 욕심쟁이 판다","uri":"/2019-05-28-1937/"},{"categories":["백준"],"content":"algorithm","date":"2019-05-27","objectID":"/2019-05-27-5069/","tags":["algorithm","C++","DP"],"title":"[백준]5069 미로에 갇힌 상근","uri":"/2019-05-27-5069/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/5069 풀이: s[n][t][y]를 n번 이동해서 (t, y)인 방으로 다시 돌아오는 경우의 수라고 한다. 처음 상근이가 있는 방을 (10, 10)이라고 한다(n의 최대 수가 14 이므로 10칸을 넘어가지 않기 때문에) s[n][10][10] 은 n번 이동해서 상근이가 있는 방으로 돌아와야하므로 상근이의 근처에 있는 모든 n-1번 이동하여 돌아오는 경우의 수들의 합과 같다. 즉 s[n][10][10] = s[n-1][10][11] + s[n-1][10][9] + s[n-1][11][11] + s[n-1][11][10] + s[n-1][9][9] + s[n-1][9][10] 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int s[15][21][21]; int dy[] = { 0,0,1,1,-1,-1 }; int dx[] = { 1,-1,1,0,-1,0 }; int main(void) { int T, a; cin \u003e\u003e T; s[0][10][10] = 1; for (int i = 1; i \u003c 15; i++) for (int t = 1; t \u003c 21; t++) for (int y = 1; y \u003c 21; y++) for (int u = 0; u \u003c 6; u++) if (t + dx[u] \u003e 0 \u0026\u0026 t + dx[u] \u003c 21 \u0026\u0026 y + dy[u] \u003e 0 \u0026\u0026 y + dy[u] \u003c 21) s[i][t][y] += s[i - 1][t + dx[u]][y + dy[u]]; while (T--) { cin \u003e\u003e a; cout \u003c\u003c s[a][10][10] \u003c\u003c endl; } return 0; } ","date":"2019-05-27","objectID":"/2019-05-27-5069/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]5069 미로에 갇힌 상근","uri":"/2019-05-27-5069/"},{"categories":["백준"],"content":"algorithm","date":"2019-03-29","objectID":"/2019-03-29-1351/","tags":["algorithm","C++","DP"],"title":"[백준]1351 무한 수열","uri":"/2019-03-29-1351/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1351 풀이: N번째 수열부터 차례대로 찾아나간다. N번째 수열이 map 에 존재한다면 그대로 리턴, 없다면 N = a/b + a/c 로 돌아가서 찾기 N이 0이라면 1을 리턴 각각의 값이 매우 크므로 long long 사용 실패 코드 예시처럼 map을 쓰지않고 리턴을 할 경우 같은 수열이 여러번 중복되어 계산되기 때문에 시간초과가 날 수 있다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cmap\u003eusing namespace std; long long a, b, c; map\u003clong long, long long\u003e n; long long infi(long long q) { if (q == 0) return 1; if (n.count(q / b) == 0) { n.insert(make_pair(q / b, infi(q / b))); } if (n.count(q / c) == 0) { n.insert(make_pair(q / c, infi(q / c))); } return n.at(q / b) + n.at(q / c); } int main(void) { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; cout \u003c\u003c infi(a) \u003c\u003c endl; return 0; } 실패 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; double a, b, c; double infi(double q) { if (q == 0) return 1; return infi(q / b) + infi(q / c); } int main(void) { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; cout \u003c\u003c infi(a) \u003c\u003c endl; return 0; } ","date":"2019-03-29","objectID":"/2019-03-29-1351/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1351 무한 수열","uri":"/2019-03-29-1351/"},{"categories":["백준"],"content":"algorithm","date":"2018-03-16","objectID":"/2018-03-16-1712/","tags":["algorithm","Python","수학"],"title":"[백준]1712 손익분기점","uri":"/2018-03-16-1712/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1712 풀이: 고정비용을 노트북 가격에서 생산비인 가변 비용을 뺀 값으로 나눈 몫을 출력한다. 만약 가변비용이 노트북의 가격보다 높다면 -1을 출력한다. 코드: 사용언어 : Python 3 a,b,c=map(int,input().split()) if b\u003e=c: print(\"-1\") else: print(a//(c-b)+1) ","date":"2018-03-16","objectID":"/2018-03-16-1712/:0:0","tags":["algorithm","Python","수학"],"title":"[백준]1712 손익분기점","uri":"/2018-03-16-1712/"},{"categories":["백준"],"content":"algorithm","date":"2018-02-05","objectID":"/2018-02-05-1919/","tags":["algorithm","Python","수학","문자열"],"title":"[백준]1919 애너그램 만들기","uri":"/2018-02-05-1919/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1919 풀이: a~z까지의 알파벳 중 문자열에 나온 개수를 확인 후 그 차이를 출력한다. 코드: 사용언어 : Python 3 a,b=input(),input() print(sum(abs(b.count(chr(i))-a.count(chr(i)))for i in range(97,123))) ","date":"2018-02-05","objectID":"/2018-02-05-1919/:0:0","tags":["algorithm","Python","수학","문자열"],"title":"[백준]1919 애너그램 만들기","uri":"/2018-02-05-1919/"},{"categories":["백준"],"content":"algorithm","date":"2018-02-04","objectID":"/2018-02-04-2338/","tags":["algorithm","C++","수학","큰 수"],"title":"[백준]2338 긴자리 계산","uri":"/2018-02-04-2338/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2338 풀이: 두 수를 입력받는다. 두 수를 더한값, 뺀값, 곱한값을 각각 출력한다. 코드: 사용언어 : Python 3 a,b=int(input()),int(input()) print(a+b,a-b,a*b,sep='\\n') ","date":"2018-02-04","objectID":"/2018-02-04-2338/:0:0","tags":["algorithm","C++","수학","큰 수"],"title":"[백준]2338 긴자리 계산","uri":"/2018-02-04-2338/"},{"categories":["백준"],"content":"algorithm","date":"2018-02-03","objectID":"/2018-02-03-2154/","tags":["algorithm","C++","수학"],"title":"[백준]2154 수 이어 쓰기 3","uri":"/2018-02-03-2154/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2154 풀이: 전체 수를 string타입으로 나열한다. 그 숫자 중 제시된 숫자 n이 맨 처음으로 나오는 인덱스를 출력한다. 코드: 사용언어 : Python 3 n,s=int(input()),\"\" for i in range(1,n+1): s+=str(i) print(s.find(str(n))+1) ","date":"2018-02-03","objectID":"/2018-02-03-2154/:0:0","tags":["algorithm","C++","수학"],"title":"[백준]2154 수 이어 쓰기 3","uri":"/2018-02-03-2154/"},{"categories":["백준"],"content":"algorithm","date":"2018-01-11","objectID":"/2018-01-11-2624/","tags":["algorithm","C++","DP"],"title":"[백준]2624 동전 바꿔주기","uri":"/2018-01-11-2624/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2624 풀이: coin[i] : i원의 지폐를 동전으로 교환할 수 있는 경우의 수 지폐의 가격 + 동전의 가격 * 동전의 개수를 계속 쌓아간다. 코드: #include \u003ciostream\u003eusing namespace std; pair\u003cint, int\u003e a[101]; int coin[10001] = { 0 }; int main(void) { int T, k, n, m; cin \u003e\u003e T \u003e\u003e k; for (int i = 0; i \u003c k; i++) { cin \u003e\u003e n \u003e\u003e m; a[i] = make_pair(n, m); } coin[0] = 1; for (int i = 0; i \u003c k; i++) for (int t = T; t \u003e 0 ; t--) for (int y = 1; y \u003c= a[i].second; y++) { if (t - (a[i].first * y) \u003e= 0) coin[t] += coin[t - (a[i].first * y)]; } cout \u003c\u003c coin[T] \u003c\u003c endl; return 0; } 주의 코드: 백준에서 map을 지원하지 않는건지 내가 map에 이해도가 안좋은건지 위 코드와 같은 코드지만 틀렸다고 한다. #include \u003ciostream\u003e#include \u003cmap\u003eusing namespace std; map\u003cint, int\u003e a; int coin[10010] = { 0 }; int main(void) { int T, k, n, m; cin \u003e\u003e T \u003e\u003e k; for (int i = 0; i \u003c k; i++) { cin \u003e\u003e n \u003e\u003e m; a[n] = m; } coin[0] = 1; map\u003cint, int\u003e::iterator itr; for (itr = a.begin(); itr != a.end(); itr++) for (int t = T; t \u003e 0 ; t--) for (int y = 1; y \u003c= itr-\u003esecond; y++) { if (t - (itr-\u003efirst * y) \u003e= 0) coin[t] += coin[t - (itr-\u003efirst * y)]; } cout \u003c\u003c coin[T] \u003c\u003c endl; return 0; } ","date":"2018-01-11","objectID":"/2018-01-11-2624/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2624 동전 바꿔주기","uri":"/2018-01-11-2624/"},{"categories":["백준"],"content":"algorithm","date":"2018-01-10","objectID":"/2018-01-10-3908/","tags":["algorithm","C++","DP","조합론","냅색"],"title":"[백준]3908 서로 다른 소수의 합","uri":"/2018-01-10-3908/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/3908 풀이: 소수를 찾는다. 소수를 하나씩 추가해가면서 a[n][k]를 찾는다. a[n][k] : 양의 정수 n을 서로 다른 k개의 소수의 합으로 나타낼 수 있는 최대의 경우의 수 코드: #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cmath.h\u003e#include \u003cstring.h\u003eusing namespace std; int T, n, k, a[1122][16] = { 0 }; bool isprime[1122]; vector\u003cint\u003e b; int prime() { memset(isprime, 1, sizeof(isprime)); isprime[0] = isprime[1] = false; for (int i = 2; i \u003c sqrt(1122); i++) if(isprime[i]) for (int t = i * i; t \u003c 1122; t += i) isprime[t] = false; for (int i = 2; i \u003c 1122; i++) if (isprime[i]) b.push_back(i); } int main(void) { prime(); cin \u003e\u003e T; a[0][0] = 1; for (int i = 0; i \u003c b.size(); i++) for (int t = 1121; t \u003e= b[i]; t--) for (int y = 1; y \u003c= 14; y++) a[t][y] += a[t - b[i]][y - 1]; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n \u003e\u003e k; cout \u003c\u003c a[n][k] \u003c\u003c endl; } return 0; } ","date":"2018-01-10","objectID":"/2018-01-10-3908/:0:0","tags":["algorithm","C++","DP","조합론","냅색"],"title":"[백준]3908 서로 다른 소수의 합","uri":"/2018-01-10-3908/"},{"categories":["백준"],"content":"algorithm","date":"2018-01-05","objectID":"/2018-01-05-2748/","tags":["algorithm","C++","DP"],"title":"[백준]2748 피보나치 수 2","uri":"/2018-01-05-2748/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2748 풀이: a[i % 3] : n번째 피보나치 수 a[i % 3] = a[(i - 1) % 3] + a[(i - 2) % 3]; 코드: #include \u003ciostream\u003eusing namespace std; long long a[3] = { 0,1 }, n; int main() { cin \u003e\u003e n; for (int i = 2; i \u003c= n; i++) a[i % 3] = a[(i - 1) % 3] + a[(i - 2) % 3]; cout \u003c\u003c a[n % 3] \u003c\u003c endl; } ","date":"2018-01-05","objectID":"/2018-01-05-2748/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2748 피보나치 수 2","uri":"/2018-01-05-2748/"},{"categories":["백준"],"content":"algorithm","date":"2018-01-02","objectID":"/2018-01-02-11568/","tags":["algorithm","C++","DP","LIS"],"title":"[백준]11568 민균이의 계략","uri":"/2018-01-02-11568/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11568 풀이: 11053 가장 긴 증가하는 부분 수열 의 문제와 같으므로 링크를 참고 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; long long a[1001] = { 0 }, b[1001]; int main(void) { long long n, temp; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; b[i] = 1; } for (int i = 0; i \u003c n; i++) { temp = 0; for (int t = 0; t \u003c= i; t++) { if (a[i] \u003e a[i - t]) temp = max(b[i - t], temp); } b[i] += temp; } for (int i = 0; i \u003c n; i++) { temp = max(b[i], temp); } cout \u003c\u003c temp \u003c\u003c endl; return 0; } ","date":"2018-01-02","objectID":"/2018-01-02-11568/:0:0","tags":["algorithm","C++","DP","LIS"],"title":"[백준]11568 민균이의 계략","uri":"/2018-01-02-11568/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-26","objectID":"/2017-12-26-2228/","tags":["algorithm","C++","DP"],"title":"[백준]2228 구간 나누기","uri":"/2017-12-26-2228/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2228 풀이: dp[n][m] : n개의 숫자를 m개의 구간으로 나눈 최대 합 dp[i][t] = dp[i - 1][t] : i번째 수를 포함하지 않는 경우 dp[i][t] = max(dp[i][t], (t == 1 ? 0 : dp[y - 1][t - 1]) + a[i] - a[y]) : i번째 수를 포함하는 경우 i번째를 포함하므로 구간을 하나 빼고 그것에 i번째 수를 포함하는 구간을 더한다. max함수를 쓰므로 dp 초기화를 잘해줘야한다. 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[101] = { 0 }, dp[101][52] = { 0 }; int main(void) { int n, m, temp; cin \u003e\u003e n \u003e\u003e m; fill(dp[0] + 1, dp[0] + m + 1, -2147483646); for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e temp; a[i] = a[i - 1] + temp; for (int t = 1; t \u003c= m; t++) { dp[i][t] = dp[i - 1][t]; for (int y = i - 1; y / 2 \u003e= t - 1; y--) { dp[i][t] = max(dp[i][t], (t == 1 ? 0 : dp[y - 1][t - 1]) + a[i] - a[y]); } } } cout \u003c\u003c dp[n][m] \u003c\u003c endl; return 0; } ","date":"2017-12-26","objectID":"/2017-12-26-2228/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2228 구간 나누기","uri":"/2017-12-26-2228/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-21","objectID":"/2017-12-21-7579/","tags":["algorithm","C++","DP"],"title":"[백준]7579 앱","uri":"/2017-12-21-7579/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/7579 풀이: 처음 문제를 풀때는 DP[메모리]로 풀었더니 시간초과가 났다. 그래서 DP[c]로 풀게되었다. 가격이 0이고 메모리가 0인 지점부터 하나하나 더해가면서 만들어나간다. 그 후 가격이 낮은 곳부터 검사하면서 메모리가 M값보다 높아지면 출력한다. iter = a.end(); 를 처음에 iter = a.begin(); 으로 했을 때 출력이 잘못되는 것을 발견하였다. 아마 작은 값부터 더해가는 과정에 겹치는 값이 생겼을 것이라고 본다. 코드: #include \u003ciostream\u003e#include \u003cmap\u003e#include \u003calgorithm\u003eusing namespace std; map\u003cint, int\u003e a; int k[101], c[101]; int main(void) { int n, m, size, temp; cin \u003e\u003e n \u003e\u003e m; a[0] = 0; for (int i = 0; i \u003c n; i++) cin \u003e\u003e k[i]; for (int i = 0; i \u003c n; i++) cin \u003e\u003e c[i]; map\u003cint, int\u003e::iterator iter; for (int i = 0; i \u003c n; i++) { size = a.size(); iter = a.end(); iter--; for (int t = 0; t \u003c size; t++, iter--) a[iter-\u003efirst + c[i]] = max(a[iter-\u003efirst + c[i]], a[iter-\u003efirst] + k[i]); } for (iter = a.begin(); iter != a.end(); ++iter) { if (iter-\u003esecond \u003e= m) { temp = iter-\u003efirst; break; } } cout \u003c\u003c temp \u003c\u003c endl; return 0; } 시간 초과 코드: #include \u003ciostream\u003e#include \u003cmap\u003e#include \u003calgorithm\u003eusing namespace std; map\u003cint, int\u003e a; int k[101], c[101]; int main(void) { int n, m, size; cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n; i++) cin \u003e\u003e k[i]; for (int i = 0; i \u003c n; i++) cin \u003e\u003e c[i]; for (int i = 0; i \u003c n; i++) { map\u003cint, int\u003e::iterator iter; size = a.size(); iter = a.begin(); for (int t = 0; t \u003c size; t++, ++iter) { if (a[iter-\u003efirst + k[i]] == 0) a[iter-\u003efirst + k[i]] = iter-\u003esecond + c[i]; else a[iter-\u003efirst + k[i]] = min(a[iter-\u003efirst + k[i]], iter-\u003esecond + c[i]); } if (a[k[i]] == 0) a[k[i]] = c[i]; else a[k[i]] = min(a[k[i]],c[i]); } int temp = 2147483647; map\u003cint, int\u003e::iterator iter; for (iter = a.begin(); iter != a.end(); ++iter) { if (iter-\u003efirst \u003e= m) temp = min(iter-\u003esecond, temp); } cout \u003c\u003c temp \u003c\u003c endl; return 0; } ","date":"2017-12-21","objectID":"/2017-12-21-7579/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]7579 앱","uri":"/2017-12-21-7579/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-20","objectID":"/2017-12-20-1038/","tags":["algorithm","C++","DP"],"title":"[백준]1038 감소하는 수","uri":"/2017-12-20-1038/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1038 풀이: 10, 321 등 감소하는 수를 찾는 문제 감소하는 수를 하나씩 만들어 가면서 카운트를 증가시킨다. 카운트의 값이 제시된 N값과 일치하면 출력한다. 제시된 N값이 9876543210의 위치인 1022 보다 크다면 -1을 출력한다. 코드: #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; vector\u003cint\u003e a; int main(void) { int n; int cnt = 11; cin \u003e\u003e n; if (n \u003c 11) { cout \u003c\u003c n \u003c\u003c endl; } else if (n \u003e 1022) cout \u003c\u003c \"-1\" \u003c\u003c endl; else { a.push_back(0); a.push_back(2); while (cnt != n) { a[0]++; for (int i = 0; i \u003c a.size() - 1; i++) { if (a[i] \u003e= a[i + 1]) { a[i] = 0; a[i + 1]++; i = -1; } if (a[i + 1] \u003e 9) { a[i + 1] = 0; if (i + 1 == a.size() - 1) { a.push_back(1); i = -1; } else a[i + 2]++; } } cnt++; } for (int i = a.size() - 1; i \u003e= 0; i--) { cout \u003c\u003c a[i]; } cout \u003c\u003c endl; } return 0; } ","date":"2017-12-20","objectID":"/2017-12-20-1038/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1038 감소하는 수","uri":"/2017-12-20-1038/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-19","objectID":"/2017-12-19-2629/","tags":["algorithm","C++","DP"],"title":"[백준]2629 양팔저울","uri":"/2017-12-19-2629/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2629 풀이: 양팔저울에 추를 매달아 구할 수 있는 무게를 알아내는 문제 양팔저울에 한 곳에 놓았을 때, 양쪽에 서로 따로 놓았을 때 두 가지의 경우가 있다. 이 때 같이놓으면 + 따로 놓은것은 -로 놓고 배열에 저장한다. 구슬의 무게에 맞는 배열의 값이 1이면 구할 수 있고, 1이 아닌경우 구할 수 없는 것으로 취급한다. 코드: #include \u003ciostream\u003e#include \u003cmap\u003e#include \u003cvector\u003eusing namespace std; map\u003cint, int\u003e a; vector\u003cint\u003e b; int main(void) { int n, temp, k, size; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e temp; map\u003cint, int\u003e::iterator iter; size = a.size(); iter = a.begin(); for (int t = 0; t \u003c size; t++) { b.push_back(iter-\u003efirst + temp); b.push_back(temp - iter-\u003efirst); b.push_back(iter-\u003efirst - temp); iter++; } a[temp] = 1; while (b.size() != 0) { a[b.back()] = 1; b.pop_back(); } } cin \u003e\u003e k; for (int i = 0; i \u003c k; i++) { cin \u003e\u003e temp; if (a[temp] == 1) cout \u003c\u003c \"Y \"; else cout \u003c\u003c \"N \"; } cout \u003c\u003c endl; return 0; } ","date":"2017-12-19","objectID":"/2017-12-19-2629/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2629 양팔저울","uri":"/2017-12-19-2629/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-18","objectID":"/2017-12-18-2698/","tags":["algorithm","C++","DP"],"title":"[백준]2698 인접한 비트의 개수","uri":"/2017-12-18-2698/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2698 풀이: a[n][k][0] : 크기가 n이고 인접비트의 수가 k이며, 끝에 비트가 0인 수 a[n][k][1] : 크기가 n이고 인접비트의 수가 k이며, 끝에 비트가 1인 수 a[n][k][0] = a[n - 1][k][0] + a[n - 1][k][1] a[n][k][1] = a[n - 1][k][0] + a[n - 1][k - 1][1] 코드: #include \u003ciostream\u003eusing namespace std; int a[102][102][2] = { 0 }; int main(void) { int T, n, k; int cnt = 2; cin \u003e\u003e T; a[1][0][1] = 1; a[1][0][0] = 1; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n \u003e\u003e k; for (int t = cnt; t \u003c n + 1; t++) { for (int y = 0; y \u003c t; y++) { a[t][y][0] = a[t - 1][y][0] + a[t - 1][y][1]; a[t][y][1] = a[t - 1][y][0] + a[t - 1][y - 1][1]; } } cout \u003c\u003c a[n][k][0] + a[n][k][1] \u003c\u003c endl; cnt = n; } return 0; } ","date":"2017-12-18","objectID":"/2017-12-18-2698/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2698 인접한 비트의 개수","uri":"/2017-12-18-2698/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-17","objectID":"/2017-12-17-1793/","tags":["algorithm","C++","DP","큰 수"],"title":"[백준]1793 타일링","uri":"/2017-12-17-1793/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1793 풀이: 11727 2XN 타일링2 DP는 링크와 같으므로 링크를 참고 링크의 코드와 다르게 int 보다 큰 값을 출력해야하므로 어려움이 있다. vector를 사용하여 int를 한자리수 씩 계산하는 방법으로 풀었다. 만약 자릿수의 값이 10보다 커지면 다음 자릿수의 값을 그만큼 올려주는 식으로 풀었다. 코드: #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; vector\u003cint\u003e a[251]; int main(void) { int n, temp; int cnt = 3; a[0].push_back(1); a[1].push_back(1); a[2].push_back(3); while(cin \u003e\u003e n){ if (a[n].size() == 0) { for (int t = cnt; t \u003c n + 1; t++) { int carry = 0; for (int y = 0; y \u003c a[t - 2].size(); y++) { temp = 2 * a[t - 2][y] + a[t - 1][y] + carry; if (temp \u003e= 10) { carry = temp / 10; temp %= 10; a[t].push_back(temp); if (y == a[t - 2].size() - 1) { if (a[t - 1].size() \u003e a[t - 2].size()) a[t].push_back(carry + a[t - 1][y + 1]); else a[t].push_back(carry); } } else { a[t].push_back(temp); carry = 0; } } } } for (int y = a[n].size() - 1; y \u003e= 0; y--) { cout \u003c\u003c a[n][y]; } cout \u003c\u003c endl; cnt = n + 1; } return 0; } ","date":"2017-12-17","objectID":"/2017-12-17-1793/:0:0","tags":["algorithm","C++","DP","큰 수"],"title":"[백준]1793 타일링","uri":"/2017-12-17-1793/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-16","objectID":"/2017-12-16-2718/","tags":["algorithm","C++","DP","비트마스크"],"title":"[백준]2718 타일 채우기","uri":"/2017-12-16-2718/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2718 풀이: a[t] 는 4 x t 크기의 타일을 채울 수 있는 경우의 수 a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4]; 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[30] = { 1,5,11,36 }; int main(void) { int T,n,cnt; cnt = 5; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n; if (a[n - 1] == 0) for (int t = cnt-1; t \u003c n; t++) { a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4]; } cout \u003c\u003c a[n - 1] \u003c\u003c endl; cnt = max(cnt, n); } return 0; } ","date":"2017-12-16","objectID":"/2017-12-16-2718/:0:0","tags":["algorithm","C++","DP","비트마스크"],"title":"[백준]2718 타일 채우기","uri":"/2017-12-16-2718/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-15","objectID":"/2017-12-15-11722/","tags":["algorithm","C++","DP"],"title":"[백준]11722 가장 긴 감소하는 부분 수열","uri":"/2017-12-15-11722/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11722 풀이: 11053 가장 긴 증가하는 부분 수열의 문제와 똑같으므로 링크를 참고 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main(void) { int n, temp; cin \u003e\u003e n; int a[1001] = { 0 }; int b[1001]; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; b[i] = 1; } for (int i = 0; i \u003c n; i++) { temp = 0; for (int t = 0; t \u003c= i; t++) { if (a[i] \u003c a[i - t]) temp = max(b[i - t], temp); } b[i] += temp; } for (int i = 0; i \u003c n; i++) { temp = max(b[i], temp); } cout \u003c\u003c temp \u003c\u003c endl; return 0; } ","date":"2017-12-15","objectID":"/2017-12-15-11722/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11722 가장 긴 감소하는 부분 수열","uri":"/2017-12-15-11722/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-14","objectID":"/2017-12-14-4883/","tags":["algorithm","C++","DP"],"title":"[백준]4883 삼각 그래프","uri":"/2017-12-14-4883/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/4883 풀이: N X 3 행렬에서 맨 위 중앙에서 출발하여 맨 아래 중앙까지 가는 경로 중 가장 최소 비용을 찾는 문제 각 i행의 1,2,3번째 열의 각각 최소비용은 i-1 번째 행에서의 최소 비용을 더해준 값이다. 맨 마지막 행의 2번째 열을 출력한다. 0이 출력되면 끝나므로 if문으로 while 문을 빠져나갈 수 있게한다. 하나의 테스트케이스마다 숫자를 출력해야하므로 count 값을 각 케이스마다 ++해준다. 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[100005][3], b[100005][3]; int main(void) { int count = 1; while (true) { int n, temp, temp2; cin \u003e\u003e n; if (n == 0) break; for (int i = 0; i \u003c n; i++) { for (int t = 0; t \u003c 3; t++) { cin \u003e\u003e a[i][t]; b[i][t] = a[i][t]; } } b[0][2] += b[0][1]; b[1][0] += b[0][1]; b[1][1] += min(min(b[0][1],b[1][0]), b[0][2]); b[1][2] += min(min(b[1][1], b[0][1]), b[0][2]); for (int i = 2; i \u003c n; i++) { for (int t = 0; t \u003c 3; t++) { if (t == 0) b[i][t] += min(b[i - 1][t], b[i - 1][t + 1]); else if (t == 1) b[i][t] += min(min(b[i - 1][t], b[i - 1][t + 1]), min(b[i - 1][t - 1], b[i][t - 1])); else if (t == 2) b[i][t] += min(min(b[i - 1][t - 1], b[i - 1][t]), b[i][t - 1]); } } cout \u003c\u003c count \u003c\u003c \". \" \u003c\u003c b[n - 1][1] \u003c\u003c endl; count++; } return 0; } ","date":"2017-12-14","objectID":"/2017-12-14-4883/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]4883 삼각 그래프","uri":"/2017-12-14-4883/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-13","objectID":"/2017-12-13-10164/","tags":["algorithm","C++","DP"],"title":"[백준]10164 격자상의 경로","uri":"/2017-12-13-10164/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10164 풀이: N X M 행렬에서 K번째 수를 꼭 지나치면서 오른쪽 맨 아래까지 가는 최대 경우의 수 1~K 까지 가는 경우의 수 * K~M*N 까지 가는 경우의 수 DP[i][t] i행 t열로 갈 수 있는 경우의 수 DP[i][t] = DP[i-1][t] + DP[i][t-1] 코드: #include \u003ciostream\u003eusing namespace std; int a[16][16] = { 0 }; int b[16][16] = { 0 }; int main(void) { int n, m, k, q, w, e, r; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; q = k / m + 1; w = k%m; if (k != 0 \u0026\u0026 w == 0) { w = m; q = k / m; } if (k == 0) { q = n; w = m; } e = n - q + 1; r = m - w + 1; for (int i = 0; i \u003c q; i++) { for (int t = 0; t \u003c w; t++) { if (i == 0 || t == 0) a[i][t] = 1; else a[i][t] = a[i - 1][t] + a[i][t - 1]; } } for (int i = 0; i \u003c e; i++) { for (int t = 0; t \u003c r; t++) { if (i == 0 || t == 0) b[i][t] = 1; else b[i][t] = b[i - 1][t] + b[i][t - 1]; } } cout \u003c\u003c b[e - 1][r - 1] * a[q - 1][w - 1] \u003c\u003c endl; return 0; } ","date":"2017-12-13","objectID":"/2017-12-13-10164/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]10164 격자상의 경로","uri":"/2017-12-13-10164/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-12","objectID":"/2017-12-12-11053/","tags":["algorithm","C++","DP"],"title":"[백준]11053 가장 긴 증가하는 부분 수열","uri":"/2017-12-12-11053/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11053 풀이: 1965 상자넣기의 문제와 똑같으므로 링크를 참고 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main(void) { int n, temp; cin \u003e\u003e n; int a[1001] = { 0 }; int b[1001]; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; b[i] = 1; } for (int i = 0; i \u003c n; i++) { temp = 0; for (int t = 0; t \u003c= i; t++) { if (a[i] \u003e a[i - t]) temp = max(b[i - t], temp); } b[i] += temp; } for (int i = 0; i \u003c n; i++) { temp = max(b[i], temp); } cout \u003c\u003c temp \u003c\u003c endl; return 0; } ","date":"2017-12-12","objectID":"/2017-12-12-11053/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11053 가장 긴 증가하는 부분 수열","uri":"/2017-12-12-11053/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-12","objectID":"/2017-12-12-6603/","tags":["algorithm","C++","BFS","DFS"],"title":"[백준]6603 로또","uri":"/2017-12-12-6603/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/6603 풀이: N 개의 로또 번호 중 6개를 선택하여 로또를 만드는 프로그램 6개의 번호를 사전순으로 하나씩 선택하면서 출력한다. 출력 사이사이에 빈칸을 만들어주고, 하나의 테스트 케이스가 끝나면 빈 줄을 하나 출력한다. 0이 출력되면 끝나므로 while 문 안에 if문으로 제한을 넣어준다. 코드: #include \u003ciostream\u003eusing namespace std; int a[13]; int main(void) { while (true) { int n; cin \u003e\u003e n; if (n == 0) break; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } int b[6] = { 0,1,2,3,4,5 }; while (true) { cout \u003c\u003c a[b[0]] \u003c\u003c \" \" \u003c\u003c a[b[1]] \u003c\u003c \" \" \u003c\u003c a[b[2]] \u003c\u003c \" \" \u003c\u003c a[b[3]] \u003c\u003c \" \" \u003c\u003c a[b[4]] \u003c\u003c \" \" \u003c\u003c a[b[5]] \u003c\u003c endl; if (b[0] \u003e= n - 6) break; else if (b[1] \u003e= n - 5) { b[0]++; for (int i = 0; i \u003c 5; i++) { b[i + 1] = b[i] + 1; } } else if (b[2] \u003e= n - 4) { b[1]++; for (int i = 1; i \u003c 5; i++) { b[i + 1] = b[i] + 1; } } else if (b[3] \u003e= n - 3) { b[2]++; for (int i = 2; i \u003c 5; i++) { b[i + 1] = b[i] + 1; } } else if (b[4] \u003e= n - 2) { b[3]++; for (int i = 3; i \u003c 5; i++) { b[i + 1] = b[i] + 1; } } else if (b[5] \u003e= n - 1) { b[4]++; b[5] = b[4] + 1; } else b[5]++; } cout \u003c\u003c endl; } return 0; } ","date":"2017-12-12","objectID":"/2017-12-12-6603/:0:0","tags":["algorithm","C++","BFS","DFS"],"title":"[백준]6603 로또","uri":"/2017-12-12-6603/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-10","objectID":"/2017-12-10-11060/","tags":["algorithm","C++","DP"],"title":"[백준]11060 점프 점프","uri":"/2017-12-10-11060/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11060 풀이: cnt[i] 는 i번째 에서의 최소 가짓수 cnt를 모두 최댓값으로 채운 후 a[i] 이하의 값으로 점프할 때 마다 cnt[i + t] 값을 min(cnt[i + t], cnt[i] + 1) 로 해줌으로써 최소 가짓수를 찾는다 만약 도착점의 값이 처음 채운 1001과 같다면 갈 수 없는 경우이므로 -1을 출력한다. 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[1001], cnt[1001]; int main(void) { int n; cin \u003e\u003e n; fill_n(cnt, n, 1001); for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } cnt[0] = 0; for (int i = 0; i \u003c n; i++) { for (int t = 1; t \u003c= a[i]; t++) { cnt[i + t] = min(cnt[i + t], cnt[i] + 1); } } if (cnt[n - 1] == 1001) cout \u003c\u003c \"-1\" \u003c\u003c endl; else cout \u003c\u003c cnt[n - 1] \u003c\u003c endl; return 0; } ","date":"2017-12-10","objectID":"/2017-12-10-11060/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11060 점프 점프","uri":"/2017-12-10-11060/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-09","objectID":"/2017-12-09-9084/","tags":["algorithm","C++","DP"],"title":"[백준]9084 동전","uri":"/2017-12-09-9084/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9084 풀이: 첫번째 동전부터 경우의 수를 더해감. 코드: #include \u003ciostream\u003eusing namespace std; int coin[10001] = { 0 }; int main(void) { int n, a, num; cin \u003e\u003e n; for (int t = 0; t \u003c n; t++) { fill_n(coin, 10000, 0); cin \u003e\u003e a; int *q = new int[a]; for (int i = 0; i \u003c a; i++) { cin \u003e\u003e q[i]; } cin \u003e\u003e num; for (int i = 0; i \u003c= num; i++) { if (i%q[0] == 0) coin[i]++; } for (int i = 1; i \u003c a; i++) { for (int t = q[i]; t \u003c= num; t++) { coin[t] += coin[t - q[i]]; } } cout \u003c\u003c coin[num] \u003c\u003c endl; } return 0; } ","date":"2017-12-09","objectID":"/2017-12-09-9084/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]9084 동전","uri":"/2017-12-09-9084/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-08","objectID":"/2017-12-08-1904/","tags":["algorithm","C++","DP","수학"],"title":"[백준]1904 01타일","uri":"/2017-12-08-1904/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1904 풀이: a[i] 는 길이가 i인 모든 이진수열의 개수 a[i] = a[i - 1] + a[i - 2] 주어진 조건에 맞게 15746 으로 나눈 나머지를 출력 코드: #include \u003ciostream\u003eusing namespace std; int a[1000001] = { 1,2 }; int main(void) { int n; cin \u003e\u003e n; for (int i = 2; i \u003c n; i++) { a[i] = (a[i - 1] % 15746 + a[i - 2] % 15746) % 15746; } cout \u003c\u003c a[n - 1] \u003c\u003c endl; return 0; } ","date":"2017-12-08","objectID":"/2017-12-08-1904/:0:0","tags":["algorithm","C++","DP","수학"],"title":"[백준]1904 01타일","uri":"/2017-12-08-1904/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-07","objectID":"/2017-12-07-11055/","tags":["algorithm","C++","DP"],"title":"[백준]11055 가장 큰 증가 부분 수열","uri":"/2017-12-07-11055/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11055 풀이: 배열의 이전을 돌며 가장 합이 큰 값을 더함 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[1002], maxA[1002]; int main(void) { int n; cin \u003e\u003e n; int maximum = 0; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; maxA[i] = a[i]; } for (int i = 0; i \u003c n; i++) { int temp = 0; for (int t = i-1; t \u003e= 0; t--) { if (a[t] \u003c a[i]) { temp = max(temp, maxA[t]); } } maxA[i] += temp; maximum = max(maximum, maxA[i]); } cout \u003c\u003c maximum \u003c\u003c endl; return 0; } ","date":"2017-12-07","objectID":"/2017-12-07-11055/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11055 가장 큰 증가 부분 수열","uri":"/2017-12-07-11055/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-05","objectID":"/2017-12-05-2957/","tags":["algorithm","C++","BFS"],"title":"[백준]2957 이진 탐색 트리","uri":"/2017-12-05-2957/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2957 풀이: 트리의 루트에서 부터 왼쪽 오른쪽에 삽입할때 마다 높이를 1씩 증가시켜 준다. cin , cout을 사용할 경우 시간초과가 나므로 scanf, printf 를 사용하도록 하자 출력의 사이즈가 int 사이즈를 넘어가므로 long long 을 사용하자 코드: #include \u003ciostream\u003e#include \u003cmap\u003e#include \u003calgorithm\u003e#include \u003cstdio.h\u003eusing namespace std; int main(void) { int n, num; cin \u003e\u003e n; map\u003cint, long long int\u003e a; a[300001] = -1; a[0] = -1; long long temp = 0; for (int i = 0; i \u003c n; i++) { scanf_s(\"%d\", \u0026num); a[num] = max((--a.lower_bound(num))-\u003esecond, a.upper_bound(num)-\u003esecond) + 1; temp += a[num]; printf_s(\"%lld\\n\", temp); } return 0; } ","date":"2017-12-05","objectID":"/2017-12-05-2957/:0:0","tags":["algorithm","C++","BFS"],"title":"[백준]2957 이진 탐색 트리","uri":"/2017-12-05-2957/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-03","objectID":"/2017-12-03-2225/","tags":["algorithm","C++","DP"],"title":"[백준]2225 합분해","uri":"/2017-12-03-2225/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2225 풀이: a[i][t] 는 0~i+1 까지 정수 t+1 개를 더하여 그 합이 i+1 이 되는 경우의 수 이다. a[i][t] = a[i-1][t] + a[i][t-1] 로 나타낼 수 있다. 이때 수의 값이 너무 커져 오버플로우가 발생할 수 있으므로 1000000000으로 나눈 나머지를 출력한다. 코드: #include \u003ciostream\u003eusing namespace std; long long a[201][201]; int main(void) { int n, k; cin \u003e\u003e n \u003e\u003e k; for (int i = 0; i \u003c n; i++) { a[i][0] = 1; for (int t = 1; t \u003c k; t++) { if (i == 0) a[i][t] = t + 1; else a[i][t] = ((a[i - 1][t]) % 1000000000 + (a[i][t - 1]) % 1000000000) % 1000000000; } } cout \u003c\u003c a[n - 1][k - 1] \u003c\u003c endl; return 0; } ","date":"2017-12-03","objectID":"/2017-12-03-2225/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2225 합분해","uri":"/2017-12-03-2225/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-02","objectID":"/2017-12-02-11051/","tags":["algorithm","C++","DP"],"title":"[백준]11051 이항계수2","uri":"/2017-12-02-11051/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11051 풀이: nCk 를 나타내는 함수 Comb() 를 만든다. 재귀함수의 특성상 시간초과 때문에 배열에 값을 저장해놓는다. 참고: 1010 다리놓기 코드: #include \u003ciostream\u003eusing namespace std; long long cnt[1001][1001] = { 0 }; int Comb(int n, int r) { if (r == 0 || r == n) return 1; else if (r == n - 1 || r == 1) return n; if (cnt[n - 1][r] == 0) cnt[n - 1][r] = Comb(n - 1, r); if (cnt[n - 1][r - 1] == 0) cnt[n - 1][r - 1] = Comb(n - 1, r - 1); return (cnt[n - 1][r] % 10007 + cnt[n - 1][r - 1] % 10007) % 100007; } int main(void) { int n, k; cin \u003e\u003e n \u003e\u003e k; cout \u003c\u003c Comb(n, k) % 10007\u003c\u003c endl; return 0; } ","date":"2017-12-02","objectID":"/2017-12-02-11051/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11051 이항계수2","uri":"/2017-12-02-11051/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-02","objectID":"/2017-12-02-1890/","tags":["algorithm","C++","DP"],"title":"[백준]1890 점프","uri":"/2017-12-02-1890/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1890 풀이: cnt[[x][y] 는 x열 y행 에서의 최대 경로의 개수 시간초과를 막기위해 if (cnt[x][y] \u003e= 0) 를 넣어 중복을 피함 코드: #include \u003ciostream\u003eusing namespace std; int n, a[101][101]; long long cnt[101][101]; long long jump(int x, int y) { if (x == n - 1 \u0026\u0026 y == n - 1) return 1; if (cnt[x][y] \u003e= 0) return cnt[x][y]; cnt[x][y] = 0; if (a[x][y] + x \u003c n) cnt[x][y] += jump(a[x][y] + x, y); if (a[x][y] + y \u003c n) cnt[x][y] += jump(x, a[x][y] + y); return cnt[x][y]; } int main(void) { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { for (int t = 0; t \u003c n; t++) { cin \u003e\u003e a[i][t]; } } fill(cnt[0], cnt[100], -1); cout \u003c\u003c jump(0, 0) \u003c\u003c endl; return 0; } ","date":"2017-12-02","objectID":"/2017-12-02-1890/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1890 점프","uri":"/2017-12-02-1890/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-02","objectID":"/2017-12-02-2096/","tags":["algorithm","C++","DP"],"title":"[백준]2096 내려가기","uri":"/2017-12-02-2096/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2096 풀이: b[i][0] 은 i번째 수를 골랐을 때의 최댓값 b[i][0] 은 i번째 수를 골랐을 때의 최솟값 참고: 1149 RGB거리 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[3],c[3]; int main(void) { int n,temp; cin \u003e\u003e n; int b[2][3] = { 0 }; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[0] \u003e\u003e a[1] \u003e\u003e a[2]; c[0] = b[0][0]; c[1] = b[0][1]; c[2] = b[0][2]; temp = max(c[1], c[0]); b[0][0] = a[0] + temp; b[0][1] = a[1] + max(temp, c[2]); b[0][2] = a[2] + max(c[1], c[2]); c[0] = b[1][0]; c[1] = b[1][1]; c[2] = b[1][2]; temp = min(c[1], c[0]); b[1][0] = a[0] + temp; b[1][1] = a[1] + min(temp, c[2]); b[1][2] = a[2] + min(c[1], c[2]); } temp = max(b[0][1], b[0][0]); cout \u003c\u003c max(temp, b[0][2]) \u003c\u003c \" \"; temp = min(b[1][1], b[1][0]); cout \u003c\u003c min(temp, b[1][2]) \u003c\u003c endl; return 0; } ","date":"2017-12-02","objectID":"/2017-12-02-2096/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2096 내려가기","uri":"/2017-12-02-2096/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-01","objectID":"/2017-12-01-1309/","tags":["algorithm","C++","DP"],"title":"[백준]1309 동물원","uri":"/2017-12-01-1309/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1309 풀이: a[i] 가 2 x i 칸에 채울 수 있는 배치의 최댓값이라 하자. a[i] = 2 * a[i - 1] + a[i - 2] 로 구할 수 있다. 코드: #include \u003ciostream\u003eusing namespace std; int main(void) { int n; cin \u003e\u003e n; int a[100001] = { 3,7,0 }; for (int i = 2; i \u003c n; i++) { a[i] = (2* a[i - 1] + a[i - 2]) % 9901; } cout \u003c\u003c a[n - 1] % 9901 \u003c\u003c endl; return 0; } ","date":"2017-12-01","objectID":"/2017-12-01-1309/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1309 동물원","uri":"/2017-12-01-1309/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-01","objectID":"/2017-12-01-1520/","tags":["algorithm","C++","DP"],"title":"[백준]1520 내리막 길","uri":"/2017-12-01-1520/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1520 풀이: cnt[i][t] 가 i행 t열을 골랐을 때 최대 경로의 수 이다. 왼쪽 위 부터 차례대로 방문한다. 왼쪽, 오른쪽, 위, 아래 를 모두 검사하여 지금 계단의 지점보다 낮은 지점을 찾는다. 계속 검사하면서 가다가 오른쪽 끝 즉, (n,m) 을 만나면 return 1을 해준다. 시간초과 때문에 재방문을 피하기위해 cnt의 값을 모두 -1로 바꿔놓고 0이상이면 검사를 끝내도록 하였다. 코드: #include \u003ciostream\u003eusing namespace std; int n, m; int a[501][501]; int cnt[501][501]; int downhill(int q, int w) { if (q == n \u0026\u0026 w == m) return 1; if (cnt[q][w] \u003e= 0) return cnt[q][w]; cnt[q][w] = 0; int x[5] = { 0, 1, 0, -1, 0 }; int y[5] = { 0, 0, 1, 0, -1 }; for (int i = 0; i \u003c 5; i++) { if (q + x[i] \u003e 0 \u0026\u0026 q + x[i] \u003c= n \u0026\u0026 w + y[i] \u003e 0 \u0026\u0026 w + y[i] \u003c= m \u0026\u0026 a[q + x[i]][w + y[i]] \u003c a[q][w]) { cnt[q][w] += downhill(q + x[i], w + y[i]); } } return cnt[q][w]; } int main(void) { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { for (int t = 1; t \u003c= m; t++) { cin \u003e\u003e a[i][t]; } } fill(cnt[0],cnt[500], -1); cout \u003c\u003c downhill(1,1) \u003c\u003c endl; return 0; } ","date":"2017-12-01","objectID":"/2017-12-01-1520/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1520 내리막 길","uri":"/2017-12-01-1520/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-01","objectID":"/2017-12-01-1965/","tags":["algorithm","C++","DP","LIS"],"title":"[백준]1965 상자넣기","uri":"/2017-12-01-1965/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1965 풀이: b[i] 가 i 번째 상자를 골랐을 때의 상자의 최대 갯수라고 하자. b[i] = b[i] + 0~i 번째 까지 중 가장 큰 값 이다. 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main(void) { int n,temp; cin \u003e\u003e n; int a[1001] = { 0 }; int b[1001]; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; b[i] = 1; } for (int i = 0; i \u003c n; i++) { temp = 0; for (int t = 0; t \u003c= i; t++) { if (a[i] \u003e a[i - t]) temp = max(b[i - t], temp); } b[i] += temp; } for (int i = 0; i \u003c n; i++) { temp = max(b[i], temp); } cout \u003c\u003c temp \u003c\u003c endl; return 0; } ","date":"2017-12-01","objectID":"/2017-12-01-1965/:0:0","tags":["algorithm","C++","DP","LIS"],"title":"[백준]1965 상자넣기","uri":"/2017-12-01-1965/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-01","objectID":"/2017-12-01-2133/","tags":["algorithm","C++","DP"],"title":"[백준]2133 타일 채우기","uri":"/2017-12-01-2133/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2133 풀이: N이 홀수라면 타일을 채울 수 없으므로 언제나 0을 출력한다. 짝수일경우 i를 N/2-1 로 생각하고 a[i] = 4 * a[i - 1] - a[i - 2] 로 구한다. 코드: #include \u003ciostream\u003e#include \u003cmath.h\u003eusing namespace std; int main(void) { int n; long long a[30] = { 3,11,0 }; cin \u003e\u003e n; if (n % 2 == 1) cout \u003c\u003c \"0\" \u003c\u003c endl; else { for (int t = 2; t \u003c n/2; t++) { a[t] = 4*a[t-1] - a[t-2]; } cout \u003c\u003c a[n/2-1] \u003c\u003c endl; } return 0; } ","date":"2017-12-01","objectID":"/2017-12-01-2133/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2133 타일 채우기","uri":"/2017-12-01-2133/"},{"categories":["백준"],"content":"algorithm","date":"2017-12-01","objectID":"/2017-12-01-6359/","tags":["algorithm","C++","DP"],"title":"[백준]6359 만취한 상범","uri":"/2017-12-01-6359/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/6359 풀이: n 개의 방이 있을 때 탈출할 수 있는 사람의 수는 sqrt(n)명이다. 코드: #include \u003ciostream\u003e#include \u003cmath.h\u003eusing namespace std; int main(void) { int n,T; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n; cout \u003c\u003c (int)sqrt(n) \u003c\u003c endl; } return 0; } ","date":"2017-12-01","objectID":"/2017-12-01-6359/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]6359 만취한 상범","uri":"/2017-12-01-6359/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-30","objectID":"/2017-11-30-10844/","tags":["algorithm","C++","DP"],"title":"[백준]10844 쉬운 계단 수","uri":"/2017-11-30-10844/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/10844 풀이: a[i][t] 는 길이가 i인 숫자에서 1의 자릿 수가 t일 때의 경우의 수 t가 0 이면 a[i][t] = a[i - 1][t + 1] t가 9 이면 a[i][t] = a[i - 1][t - 1] 둘다 아니면 a[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) 이 때 오버플로우가 발생하므로 각각의 계산에 1000000000을 나눠준다. 코드: #include \u003ciostream\u003eusing namespace std; long long a[101][10] = { 0 }; int main(void) { int n; cin \u003e\u003e n; long long cnt = 0; for (int i = 1; i \u003c 10; i++) { a[0][i] = 1; } for (int i = 1; i \u003c n; i++) { for (int t = 0; t \u003c 10; t++) { if (t == 0) a[i][t] = a[i - 1][t + 1] % 1000000000; else if (t == 9) a[i][t] = a[i - 1][t - 1] % 1000000000; else a[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) % 1000000000; } } for (int i = 0; i \u003c 10; i++) { cnt += a[n - 1][i] % 1000000000; } cout \u003c\u003c cnt % 1000000000 \u003c\u003c endl; return 0; } ","date":"2017-11-30","objectID":"/2017-11-30-10844/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]10844 쉬운 계단 수","uri":"/2017-11-30-10844/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-30","objectID":"/2017-11-30-11057/","tags":["algorithm","C++","DP"],"title":"[백준]11057 오르막수","uri":"/2017-11-30-11057/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11057 풀이: a[i][t] 는 길이가 i인 수에서 1의 자리가 t인 수의 오르막 수의 개수 a[i][t] += max(a[i - 1][t], a[i][t - 1]); 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[1002][1002] = { 0 }; int main(void) { int n, m; cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { for (int t = 1; t \u003c= m; t++) { cin \u003e\u003e a[i][t]; } } for (int i = 1; i \u003c= n; i++) { for (int t = 1; t \u003c= m; t++) { a[i][t] += max(a[i - 1][t], a[i][t - 1]); } } cout \u003c\u003c a[n][m] \u003c\u003c endl; return 0; } ","date":"2017-11-30","objectID":"/2017-11-30-11057/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11057 오르막수","uri":"/2017-11-30-11057/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-30","objectID":"/2017-11-30-11727/","tags":["algorithm","C++","DP"],"title":"[백준]11727 2xN 타일링2","uri":"/2017-11-30-11727/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11727 풀이: a[i] 는 타일이 2xi 일때의 경우의 수 a[i] = (2 * a[i - 2] + a[i - 1] 주어진 조건에서 10007으로 나눈 나머지를 출력하라고 하였으므로 나눠줌. 코드: #include \u003ciostream\u003eusing namespace std; int a[1001] = { 1,3,0 }; int main(void) { int n; cin \u003e\u003e n; for (int i = 2; i \u003c n; i++) { a[i] = (2 * a[i - 2] + a[i - 1])%10007; } cout \u003c\u003c a[n - 1] \u003c\u003c endl; return 0; } ","date":"2017-11-30","objectID":"/2017-11-30-11727/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11727 2xN 타일링2","uri":"/2017-11-30-11727/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-30","objectID":"/2017-11-30-1699/","tags":["algorithm","C++","DP"],"title":"[백준]1699 제곱수의 합","uri":"/2017-11-30-1699/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1699 풀이: q[i] 는 i 일 때 제곱수로 나타낼 수 있는 최소의 경우의 수 n 이 i + t^2 으로 나타내 질 때, 최소의 경우의 수를 찾음 코드: #include \u003ciostream\u003e#include \u003cmath.h\u003eint q[100002] = { 0 }; using namespace std; int main(void) { int n,a; cin \u003e\u003e n; a = sqrt(n); for (int i = 1; i \u003c= n; i++) { q[i] = 10001; for (int t = 1; t \u003c= a; t++) { if (i == t*t) q[i] = 1; } } for (int i = 1; i \u003c= n; i++) { for (int t = 1; t \u003c= a; t++) { if (i + (t*t) \u003c= n \u0026\u0026 q[i + (t*t)] \u003e q[i] + 1) q[i + (t*t)] = q[i] + 1; } } cout \u003c\u003c q[n] \u003c\u003c endl; } ","date":"2017-11-30","objectID":"/2017-11-30-1699/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1699 제곱수의 합","uri":"/2017-11-30-1699/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-30","objectID":"/2017-11-30-1912/","tags":["algorithm","C++","DP","수학"],"title":"[백준]1912 연속합","uri":"/2017-11-30-1912/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1912 풀이: a[i] 는 i번째를 골랐을 때, 최대값 만약 a[i-1] 이 0 보다 크다면, a[i] += a[i-1] 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[100001] = { 0 }; int main(void) { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } int temp = a[0]; for (int i = 1; i \u003c n; i++) { if(a[i-1] \u003e 0) a[i] += a[i - 1]; temp = max(temp, a[i]); } cout \u003c\u003c temp \u003c\u003c endl; return 0; } ","date":"2017-11-30","objectID":"/2017-11-30-1912/:0:0","tags":["algorithm","C++","DP","수학"],"title":"[백준]1912 연속합","uri":"/2017-11-30-1912/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-30","objectID":"/2017-11-30-2163/","tags":["algorithm","C++","수학","DP"],"title":"[백준]2163 초콜릿 자르기","uri":"/2017-11-30-2163/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2163 풀이: N x M 크기의 초콜릿을 자르는 최소의 경우의 수 N * M - 1 코드: #include \u003ciostream\u003eusing namespace std; int main(void) { int n, m; cin \u003e\u003e n \u003e\u003e m; cout \u003c\u003c n*m - 1 \u003c\u003c endl; return 0; } ","date":"2017-11-30","objectID":"/2017-11-30-2163/:0:0","tags":["algorithm","C++","수학","DP"],"title":"[백준]2163 초콜릿 자르기","uri":"/2017-11-30-2163/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-30","objectID":"/2017-11-30-9461/","tags":["algorithm","C++","DP"],"title":"[백준]9461 파도반 수열","uri":"/2017-11-30-9461/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9461 풀이: a[i] 는 i 번째 수열 a[i] = a[i-1] + a[i-5] 코드: #include \u003ciostream\u003eusing namespace std; long long a[101] = { 1,1,1,2,2,0 }; int main(void) { int T,n; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n; for (int t = 5; t \u003c n; t++) { a[t] = a[t - 1] + a[t - 5]; } cout \u003c\u003c a[n - 1] \u003c\u003c endl; } return 0; } ","date":"2017-11-30","objectID":"/2017-11-30-9461/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]9461 파도반 수열","uri":"/2017-11-30-9461/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-29","objectID":"/2017-11-29-2156/","tags":["algorithm","C++","DP"],"title":"[백준]2156 포도주 시식","uri":"/2017-11-29-2156/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2156 풀이: b[i][0] 은 i번째를 골랐을 때, i-1번째를 안고른 경우의 수 b[i][1] 은 i번째를 골랐을 때, i-1번째를 고른 경우의 수 b[i][2] 은 i번째를 골랐을 때, i-2번째를 안고른 경우의 수 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main(void) { int n; cin \u003e\u003e n; int a[10001]; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } int b[10001][3] = { a[0],a[0],a[0],a[1],a[0] + a[1],a[1],0 }; int temp; for (int i = 2; i \u003c n; i++) { for (int t = 0; t \u003c 3; t++) { if (t == 0) { temp = max(b[i - 2][0], b[i - 2][1]); b[i][t] = max(temp, b[i - 2][2]) + a[i]; } if (t == 1) b[i][t] = max(b[i - 1][0], b[i - 1][2]) + a[i]; if (t == 2) b[i][t] = b[i - 3][1] + a[i]; } } temp = max(b[n - 1][0], b[n - 2][1]); temp = max(temp, b[n - 1][1]); cout \u003c\u003c max(temp, b[n - 1][2]) \u003c\u003c endl; return 0; } ","date":"2017-11-29","objectID":"/2017-11-29-2156/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2156 포도주 시식","uri":"/2017-11-29-2156/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-28","objectID":"/2017-11-28-1003/","tags":["algorithm","C++","DP"],"title":"[백준]1003 피보나치 함수","uri":"/2017-11-28-1003/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1003 풀이: 0이 쓰이면 카운트 0을 ++ 1이 쓰이면 카운트 1을 ++ 코드: #include \u003ciostream\u003e // 재귀를 이용using namespace std; int cnt[2] = { 0 }; int fibonacci(int n) { if (n == 0) { cnt[0]++; return 0; } else if (n == 1) { cnt[1]++; return 1; } else return fibonacci(n-1) + fibonacci(n-2); } int main(void) { int T,n; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n; cnt[0] = 0; cnt[1] = 0; fibonacci(n); cout \u003c\u003c cnt[0] \u003c\u003c \" \" \u003c\u003c cnt[1] \u003c\u003c endl; } return 0; } } #include \u003ciostream\u003e // 포문 이용using namespace std; int main(void) { int T, n; int a[41] = { 0 }; int b[41] = { 0 }; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n; a[0] = 1; a[1] = 0; b[0] = 0; b[1] = 1; for (int t = 2; t \u003c= n; t++) { a[t] = a[t - 1] + a[t - 2]; b[t] = b[t - 1] + b[t - 2]; } cout \u003c\u003c a[n] \u003c\u003c \" \" \u003c\u003c b[n] \u003c\u003c endl; } } ","date":"2017-11-28","objectID":"/2017-11-28-1003/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1003 피보나치 함수","uri":"/2017-11-28-1003/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-28","objectID":"/2017-11-28-11726/","tags":["algorithm","C++","DP"],"title":"[백준]11726 2×n 타일링","uri":"/2017-11-28-11726/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11726 풀이: 정수 i를 1,2 의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] 으로 구할 수 있다. 코드: #include \u003ciostream\u003eusing namespace std; int main(void) { int n; int a[1001] = { 1,2,0 }; cin \u003e\u003e n; for (int t = 2; t \u003c n; t++) { a[t] = (a[t - 1] + a[t - 2]) % 10007; } cout \u003c\u003c a[n - 1]\u003c\u003c endl; return 0; } ","date":"2017-11-28","objectID":"/2017-11-28-11726/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11726 2×n 타일링","uri":"/2017-11-28-11726/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-28","objectID":"/2017-11-28-1463/","tags":["algorithm","C++","DP"],"title":"[백준]1463 1로 만들기","uri":"/2017-11-28-1463/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1463 풀이: i 일때 연산 횟수를 a[i] 라고 둔다. 2와 3으로 동시에 나눠질때, 따로 나눠질때, 나눠지지 않을때로 나눠서 계산한다. n번까지 연산 후 a[n]을 출력한다. 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[1000002] = { 0 }; int main(void) { int n; cin \u003e\u003e n; for (int i = 2; i \u003c= n; i++) { if (i % 2 == 0 \u0026\u0026 i % 3 == 0) { int temp = min(a[i / 2], a[i / 3]); a[i] = min(temp, a[i - 1]) + 1; } else if(i % 2 == 0 \u0026\u0026 i % 3 != 0) a[i] = min(a[i / 2], a[i - 1]) + 1; else if(i % 2 != 0 \u0026\u0026 i % 3 == 0) a[i] = min(a[i - 1], a[i / 3]) + 1; else a[i] = a[i - 1] + 1; } cout \u003c\u003c a[n] \u003c\u003c endl; return 0; } ","date":"2017-11-28","objectID":"/2017-11-28-1463/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1463 1로 만들기","uri":"/2017-11-28-1463/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-28","objectID":"/2017-11-28-9095/","tags":["algorithm","C++","DP"],"title":"[백준]9095 1, 2, 3 더하기","uri":"/2017-11-28-9095/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9095 풀이: 정수 i를 1,2,3의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] + a[i-3] 으로 구할 수 있다. 코드: #include \u003ciostream\u003eusing namespace std; int main(void) { int T,n; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { int a[11] = { 1,2,4,0 }; cin \u003e\u003e n; for (int t = 3; t \u003c n; t++) { a[t] = a[t - 1] + a[t - 2] + a[t - 3]; } cout \u003c\u003c a[n - 1] \u003c\u003c endl; } return 0; } ","date":"2017-11-28","objectID":"/2017-11-28-9095/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]9095 1, 2, 3 더하기","uri":"/2017-11-28-9095/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-27","objectID":"/2017-11-27-1149/","tags":["algorithm","C++","DP"],"title":"[백준]1149 RGB거리","uri":"/2017-11-27-1149/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1149 풀이: r,g,b를 각각 b[0], b[1], b[2] 로 둠. r을 선택했다면 이전에서 g,b 중 작은값에 이번에 r값을 더하는 식으로 r,g,b 반복 r,g,b 최종값에서 가장 최소값 출력 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main(void) { int n; cin \u003e\u003e n; int a[3001]; int b[3]; for (int i = 0; i \u003c n*3; i++) { cin \u003e\u003e a[i]; } for (int i = 1; i \u003c n; i++) { b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; a[0] = min(b[1], b[2]) + a[i * 3]; a[1] = min(b[0], b[2]) + a[(i * 3) + 1]; a[2] = min(b[0], b[1]) + a[(i * 3) + 2]; } int temp = min(a[0], a[1]); cout \u003c\u003c min(temp, a[2]) \u003c\u003c endl; return 0; } ","date":"2017-11-27","objectID":"/2017-11-27-1149/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1149 RGB거리","uri":"/2017-11-27-1149/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-26","objectID":"/2017-11-26-11052/","tags":["algorithm","C++","DP"],"title":"[백준]11052 붕어빵 판매하기","uri":"/2017-11-26-11052/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/11052 풀이: 붕어의 개수가 i개 일 때를 b[i] 라고 놓고 b[i] = (t개 일때 가격 + 남은 붕어 빵의 가격) 과 b[i] 개중 큰값을 넣음. 구하고자 하는 n개 즉 b[n]을 찾음. 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main(void) { int n, m, w; int a[1002]; int b[1002] = { 0 }; cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } for (int i = 1; i \u003c= n; i++) { for (int t = 0; t \u003c i; t++) { b[i] = max(b[i], b[t] + a[i - t]); } } cout \u003c\u003c b[n] \u003c\u003c endl; return 0; } ","date":"2017-11-26","objectID":"/2017-11-26-11052/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]11052 붕어빵 판매하기","uri":"/2017-11-26-11052/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-25","objectID":"/2017-11-25-1004/","tags":["algorithm","C++"],"title":"[백준]1004 어린왕자","uri":"/2017-11-25-1004/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1004 풀이: 시작점과 도착점이 같이 원안에 있지않을 때, 시작점, 도착점이 원 안에 있다면 카운트를 ++ 코드: #include \u003ciostream\u003e#include \u003cmath.h\u003eusing namespace std; int main(void) { int T; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { int n, x1, x2, y1, y2; int x[50]; int y[50]; int r[50]; int count = 0; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2 \u003e\u003e n; for (int t = 0; t \u003c n; t++) { cin \u003e\u003e x[t] \u003e\u003e y[t] \u003e\u003e r[t]; } for (int t = 0; t \u003c n; t++) { if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) \u003c r[t]) { if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) \u003e= r[t]) count++; } if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) \u003c r[t]) { if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) \u003e= r[t]) count++; } } cout \u003c\u003c count \u003c\u003c endl; } return 0; } ","date":"2017-11-25","objectID":"/2017-11-25-1004/:0:0","tags":["algorithm","C++"],"title":"[백준]1004 어린왕자","uri":"/2017-11-25-1004/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-25","objectID":"/2017-11-25-1010/","tags":["algorithm","C++","DP"],"title":"[백준]1010 다리놓기","uri":"/2017-11-25-1010/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1010 풀이: 서쪽 다리(N)에서 동쪽 다리(M)로 연결 이므로 조합인 mCn 을 사용 코드: #include \u003ciostream\u003eusing namespace std; int Comb(int n, int r) { if (r == 0 || r == n) return 1; else if (r == n - 1 || r == 1) return n; return Comb(n - 1, r) + Comb(n - 1, r - 1); } int main(void) { int T,n,m; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n \u003e\u003e m; cout \u003c\u003c Comb(m, n) \u003c\u003c endl; } return 0; } ","date":"2017-11-25","objectID":"/2017-11-25-1010/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1010 다리놓기","uri":"/2017-11-25-1010/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-25","objectID":"/2017-11-25-1718/","tags":["algorithm","C++","문자열"],"title":"[백준]1718 암호","uri":"/2017-11-25-1718/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1718 풀이: 평문에서 암호문을 뺀다. 만약 뺀 값이 0 이하일경우 z로 돌아간다. 코드: #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main(void) { string a; getline(cin, a); string key; cin \u003e\u003e key; char cy[30001] = { NULL }; for (int i = 0; i \u003c a.length(); i++) { if (a[i] == ' ') cy[i] = ' '; else if ((int)a[i] - (int)key[i%key.length()] \u003c= 0) cy[i] = (char)((int)a[i] - (int)key[i%key.length()] + 122); else cy[i] = (char)((int)a[i] - (int)key[i%key.length()] + 96); } cout \u003c\u003c cy \u003c\u003c endl; return 0; } ","date":"2017-11-25","objectID":"/2017-11-25-1718/:0:0","tags":["algorithm","C++","문자열"],"title":"[백준]1718 암호","uri":"/2017-11-25-1718/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-25","objectID":"/2017-11-25-2578/","tags":["algorithm","C++"],"title":"[백준]2578 빙고","uri":"/2017-11-25-2578/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2578 풀이: 빙고를 저장 사회자가 말하는 번호에 빙고판에 1 저장 빙고판 가로 세로 대각선 2개 판별 빙고가 3개 넘어가면 끝 코드: #include \u003ciostream\u003e#include \u003cmap\u003eusing namespace std; int main(void) { map\u003cint, int\u003e a; int b[25] = { 0 }; int c[25]; int num; int count = 0; for (int i = 0; i \u003c 25; i++) { cin \u003e\u003e num; a[num] = i; } for (int i = 0; i \u003c 25; i++) { cin \u003e\u003e num; b[a[num]] = 1; if (b[(a[num] / 5) * 5] == 1 \u0026\u0026 b[((a[num] / 5) * 5) + 1] == 1 \u0026\u0026 b[((a[num] / 5) * 5) + 2] == 1 \u0026\u0026 b[((a[num] / 5) * 5) + 3] == 1 \u0026\u0026 b[((a[num] / 5) * 5) + 4] == 1) count++; if (b[a[num] % 5] == 1 \u0026\u0026 b[a[num] % 5 + 5] == 1 \u0026\u0026 b[a[num] % 5 + 10] == 1 \u0026\u0026 b[a[num] % 5 + 15] == 1 \u0026\u0026 b[a[num] % 5 + 20] == 1) count++; if ((a[num] % 4 == 0 \u0026\u0026 a[num] != 0 \u0026\u0026 a[num] != 24) \u0026\u0026 b[4] == 1 \u0026\u0026 b[8] == 1 \u0026\u0026 b[12] == 1 \u0026\u0026 b[16] == 1 \u0026\u0026 b[20] == 1) count++; if (a[num] % 6 == 0 \u0026\u0026 b[0] == 1 \u0026\u0026 b[6] == 1 \u0026\u0026 b[12] == 1 \u0026\u0026 b[18] == 1 \u0026\u0026 b[24] == 1) count++; if (count \u003e= 3) { num = i; break; } } cout \u003c\u003c num + 1 \u003c\u003c endl; return 0; } ","date":"2017-11-25","objectID":"/2017-11-25-2578/:0:0","tags":["algorithm","C++"],"title":"[백준]2578 빙고","uri":"/2017-11-25-2578/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-24","objectID":"/2017-11-24-1932/","tags":["algorithm","C++","DP"],"title":"[백준]1932 숫자삼각형","uri":"/2017-11-24-1932/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1932 풀이: 첫 줄부터 밑에줄까지 내려가면서 값을 더해감 더한 값중 제일 큰 값을 찾음 코드: #include \u003ciostream\u003eusing namespace std; int q[501][501]; int good[501][501]; int main(void) { int num; int big = 0; cin \u003e\u003e num; for (int i = 0; i \u003c num; i++){ for (int t = 0; t \u003c i + 1; t++){ cin \u003e\u003e q[i][t]; } } good[0][0] = q[0][0]; for (int i = 1; i \u003c num; i++) { for (int t = 0; t \u003c i+1; t++){ if(t==0) good[i][t] = good[i - 1][t] + q[i][t]; else if (i == t) good[i][t] = good[i - 1][t - 1] + q[i][t]; else { if (good[i - 1][t - 1] \u003e good[i - 1][t]) good[i][t] = good[i - 1][t - 1] + q[i][t]; else good[i][t] = good[i - 1][t] + q[i][t]; } } } for (int i = 0; i \u003c num; i++) { if (good[num - 1][i] \u003e big) big = good[num - 1][i]; } cout \u003c\u003c big \u003c\u003c endl; return 0; } ","date":"2017-11-24","objectID":"/2017-11-24-1932/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]1932 숫자삼각형","uri":"/2017-11-24-1932/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-23","objectID":"/2017-11-23-2293/","tags":["algorithm","C++","DP"],"title":"[백준]2293 동전1","uri":"/2017-11-23-2293/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2293 풀이: 첫번째 동전부터 경우의 수를 더해감. 코드: #include \u003ciostream\u003eusing namespace std; int coin[10001] = { 0 }; int main(void) { int a; int num; cin \u003e\u003e a; cin \u003e\u003e num; int *q = new int[a]; for (int i = 0; i \u003c a; i++){ cin \u003e\u003e q[i]; } for (int i = 0; i \u003c= num; i++){ if (i%q[0] == 0) coin[i]++; } for (int i = 1; i \u003c a; i++){ for (int t = q[i]; t \u003c= num; t++){ coin[t] += coin[t - q[i]]; } } cout \u003c\u003c coin[num] \u003c\u003c endl; return 0; } ","date":"2017-11-23","objectID":"/2017-11-23-2293/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]2293 동전1","uri":"/2017-11-23-2293/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-22","objectID":"/2017-11-22-3613/","tags":["algorithm","C++","문자열"],"title":"[백준]3613 Java vs C++","uri":"/2017-11-22-3613/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/3613 풀이: java 변수면 c++로 c++ 이면 java로 변경 예외처리 코드: #include \u003ciostream\u003e#include \u003cstring.h\u003eusing namespace std; int main(void) { char a[201]; char b[201] = {'\\n'}; bool java = false; bool cplus = false; bool ero = true; cin \u003e\u003e a; int t = 0; for (int i = 0; i \u003c strlen(a); i++) { if (65 \u003c= (int)a[i] \u0026\u0026 (int)a[i] \u003c= 90) { if (i == 0 || cplus == true) { ero = false; break; } b[t] = '_'; t++; b[t] = a[i] + 32; java = true; } else if (a[i] == '_') { if (i == 0 || i == strlen(a)-1 || a[i + 1] == '_' || java == true || (65 \u003c= (int)a[i + 1] \u0026\u0026 (int)a[i + 1] \u003c= 90)) { ero = false; break; } b[t] = a[i + 1] - 32; i++; cplus = true; } else b[t] = a[i]; t++; } if (ero == false) cout \u003c\u003c \"Error!\" \u003c\u003c endl; else cout \u003c\u003c b \u003c\u003c endl; return 0; } ","date":"2017-11-22","objectID":"/2017-11-22-3613/:0:0","tags":["algorithm","C++","문자열"],"title":"[백준]3613 Java vs C++","uri":"/2017-11-22-3613/"},{"categories":["sw"],"content":"algorithm","date":"2017-11-21","objectID":"/2017-11-21-sw-1210/","tags":["algorithm","C++","탐색"],"title":"[sw]사다리","uri":"/2017-11-21-sw-1210/"},{"categories":["sw"],"content":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14ABYKADACFAYh\u0026 풀이: int[100][100] 배열에 사다리를 저장 사다리 끝에 있는 도착점을 찾음 사다리 위로 올라가며 옆에 길이 있나 확인 맨 위에 x값을 출력 코드: #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int lineup(int n[100][100], int yc, int xc, bool left, bool right) { if (yc == 0) return xc; if (xc \u003e 0 \u0026\u0026 right == false \u0026\u0026 n[yc][xc - 1] == 1) return lineup(n, yc, xc - 1,true,false); else if (xc \u003c 99 \u0026\u0026 left==false \u0026\u0026 n[yc][xc + 1] == 1) return lineup(n, yc, xc + 1,false,true); else return lineup(n, yc - 1, xc,false,false); } int main(void) { for (int t = 1; t \u003c 11; t++) { int a; cin \u003e\u003e a; int line[100][100]; int count; for (int i = 0; i \u003c 100; i++) { for (int y = 0; y \u003c 100; y++) { cin \u003e\u003e line[i][y]; } } for (int i = 0; i \u003c 100; i++) { if (line[99][i] == 2) { count = i; break; } } cout \u003c\u003c \"#\" \u003c\u003c t \u003c\u003c \" \" \u003c\u003c lineup(line, 98, count, false, false) \u003c\u003c endl; } return 0; } } ","date":"2017-11-21","objectID":"/2017-11-21-sw-1210/:0:0","tags":["algorithm","C++","탐색"],"title":"[sw]사다리","uri":"/2017-11-21-sw-1210/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-20","objectID":"/2017-11-20-1065/","tags":["algorithm","C++","탐색"],"title":"[백준]1065 한수","uri":"/2017-11-20-1065/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1065 풀이: 한수이면 카운트를 ++ 하는 함수를 만듦 코드: 사용언어 : c++ #include \u003ciostream\u003eusing namespace std; int hannum(int n, int c) { int b = (n % 1000) / 100; int d = ((n % 1000) % 100) / 10; int f = ((n % 1000) % 100) % 10; if (n \u003e 99) { if ((b - d == d - f) \u0026\u0026 n != 1000) c++; } else c++; if (n == 1) return c; else return hannum(n - 1, c); } int main(void) { int a; cin \u003e\u003e a; cout \u003c\u003c hannum(a, 0); return 0; } ","date":"2017-11-20","objectID":"/2017-11-20-1065/:0:0","tags":["algorithm","C++","탐색"],"title":"[백준]1065 한수","uri":"/2017-11-20-1065/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-20","objectID":"/2017-11-20-1475/","tags":["algorithm","C++","탐색"],"title":"[백준]1475 방번호","uri":"/2017-11-20-1475/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/1475 풀이: 방번호를 string에 저장 string 첫번째 자릿수부터 숫자를 확인 숫자에 맞는 배열에 ++ 배열에서 가장 큰 숫자를 가지고 있는 값을 출력 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main(void) { string a; int b[10] = { 0 }; cin \u003e\u003e a; for (int i = 0; i \u003c a.length(); i++) { if (((int)a[i] - 48) == 6 \u0026\u0026 b[6] \u003e b[9]) b[9] ++; else if (((int)a[i] - 48) == 9 \u0026\u0026 b[6] \u003c b[9]) b[6] ++; else b[(int)a[i] - 48]++; } int count = 0; for (int i = 0; i \u003c 10; i++) { if (b[i] \u003e count) count = b[i]; } cout \u003c\u003c count \u003c\u003c endl; return 0; } ","date":"2017-11-20","objectID":"/2017-11-20-1475/:0:0","tags":["algorithm","C++","탐색"],"title":"[백준]1475 방번호","uri":"/2017-11-20-1475/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-20","objectID":"/2019-06-01-2098/","tags":["algorithm","C++","외판원 순회"],"title":"[백준]2098 외판원 순회","uri":"/2019-06-01-2098/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/2098 풀이: dp[a][b]를 현제 위치가 a이고, 이때까지 방문한 도시들의 목록이 b인 여행비용의 최솟값이라고 한다. 방문한 도시들을 쉽게 나타내기 위해 비트마스크를 사용하였다. 최솟값을 구하는 문제이므로 r을 최대한 큰 수로 두고 min함수를 이용한다. 도시의 비용이 0인 경우 방문할 수 없으므로 제외시킨다. 방문 횟수가 많아 시간초과가 날 수 있으므로 메모이제이션을 한다. 순회 문제이기 때문에 시작위치는 상관없으므로 실행시간을 늘리지 않도록 주의한다. 코드: 사용언어 : c++ #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int w[17][17],d[17][100000], n; int T(int a, int b) { if ((1 \u003c\u003c n) - 1 == b \u0026\u0026 w[a][0] != 0) return w[a][0]; int \u0026r = d[a][b]; if (r \u003e 0) return r; r = 100000000; for (int i = 0; i \u003c n; i++) if (w[a][i] != 0 \u0026\u0026 (b \u0026 (1 \u003c\u003c i)) == 0) r = min(r, w[a][i] + T(i, b | (1 \u003c\u003c i))); return r; } int main(void) { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) for (int t = 0; t \u003c n; t++) cin \u003e\u003e w[i][t]; cout \u003c\u003c T(0, 1) \u003c\u003c endl; return 0; } ","date":"2017-11-20","objectID":"/2019-06-01-2098/:0:0","tags":["algorithm","C++","외판원 순회"],"title":"[백준]2098 외판원 순회","uri":"/2019-06-01-2098/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-20","objectID":"/2017-12-18-9507/","tags":["algorithm","C++","DP"],"title":"[백준]9507 Generations of Tribbles","uri":"/2017-12-18-9507/"},{"categories":["백준"],"content":"https://www.acmicpc.net/problem/9507 풀이: 문제에 DP가 주어져 있으므로 그대로 하면된다. 다만 큰 수가 나오므로 long long을 써야할 것이다. 코드: #include \u003ciostream\u003eusing namespace std; long long a[70] = {1,1,2,4,0}; int main(void) { int T,n; int cnt = 4; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n; for (int t = cnt; t \u003c n + 1; t++) { a[t] = a[t - 1] + a[t - 2] + a[t - 3] + a[t - 4]; } cout \u003c\u003c a[n] \u003c\u003c endl; cnt = n + 1; } return 0; } ","date":"2017-11-20","objectID":"/2017-12-18-9507/:0:0","tags":["algorithm","C++","DP"],"title":"[백준]9507 Generations of Tribbles","uri":"/2017-12-18-9507/"},{"categories":["백준"],"content":"algorithm","date":"2017-11-19","objectID":"/2017-11-19-start/","tags":["C++"],"title":"start","uri":"/2017-11-19-start/"},{"categories":["백준"],"content":"안녕하세요. ","date":"2017-11-19","objectID":"/2017-11-19-start/:0:0","tags":["C++"],"title":"start","uri":"/2017-11-19-start/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1011 풀이: 거리가 제곱수 일 때(d = s^2), 그 거리 까지 갈 수 있는 최소 작동수에서 최대 거리는 그 수의 제곱근(s) 이다. 최소 작동수는 대칭일때 만들어지므로 제곱수일 때 최소 작동수는 2*s - 1이 된다. 거리가 제곱수가 아니라면, 거리에서 그 거리보다 작은 제곱수를 뺀 나머지로 계산한다. (d - s^2) / s + 1 즉 제곱수 만큼 간 후 남은 거리를 갈 수 있는 최대 거리인 s로 나눈 값에 올림한 값과 같다. 코드: #include \u003ciostream\u003e #include \u003cmath.h\u003e using namespace std; int main(void) { int T, x, y; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e x \u003e\u003e y; long long temp = 0; int s = sqrt(y - x); if (s == 1) temp += y - x; else if ((y - x - s * s) % s == 0) temp += 2 * s + (y - x - s * s) / s - 1; else temp += 2 * s + (y - x - s * s) / s; cout \u003c\u003c temp \u003c\u003c endl; } return 0; } ","date":"0001-01-01","objectID":"/2018-01-08-1011/:0:0","tags":null,"title":"1011 Fly me to the Alpha Centauri","uri":"/2018-01-08-1011/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1016 풀이: min 수 부터 max 까지 제곱수의 배수가 되는 수를 찾는다. max-min+1 에서 위에서 찾은 제곱수의 배수의 개수를 뺀다. 코드: 사용언어 : Python 3 n,m=map(int,input().split()) a,b=0,[0]*1000001 for i in range(2,int(m**.5)+1): q=n if n%(i*i)!=0: q=(n//(i*i)+1)*i*i for t in range(q,m+1,i*i): if b[t-n]==0: b[t-n]=1 a+=1 print(m-n+1-a) ","date":"0001-01-01","objectID":"/2018-02-05-1016/:0:0","tags":null,"title":"1016 제곱 ㄴㄴ 수","uri":"/2018-02-05-1016/"},{"categories":null,"content":"https://www.acmicpc.net/problem/10569 풀이: 면의수 = 2 - 꼭짓점의 수 + 모서리의 수 코드: 사용언어 : Python 3 t=int(input()) for i in range(t): v,e=map(int, input().split()) print(2-v+e) ","date":"0001-01-01","objectID":"/2018-01-28-10569/:0:0","tags":null,"title":"10569 다면체","uri":"/2018-01-28-10569/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1072 풀이: 게임횟수 : x, 이긴게임 : y, 더해야하는 판수 a 100 * y/x + 1 = 100 * y+a/x+a 100 * y/x + 1 = c 로 놓고 c = 100 * y+a/x+a cx + ca = 100y + 100a (c - 100)a = 100y - cx a = (100y - cx) / (c - 100) 이렇게 나온 a값을 올림을 하면 더해야하는 판수가 나오게된다. 코드: 사용언어 : c++ #include \u003ciostream\u003e #include \u003cstdio.h\u003e #include \u003cmath.h\u003e using namespace std; long long a, b; int main(void) { while (scanf_s(\"%lld %lld\",\u0026a,\u0026b)!=EOF) { double c = (100 * b / a + 1); long long d = ceil((100 * b - a*c) / (c - 100)); if (100 * b / a \u003e= 99) cout \u003c\u003c \"-1\" \u003c\u003c endl; else printf(\"%lld\\n\",d); } return 0; } 실패 코드: 입력 반복을 파이썬으로 하는 방법을 모름 사용언어 : Python 3 a,b=map(int,input().split()) c=(int)(100*b/a+1) if 100*b/a\u003e=99: print(\"-1\") else: print(round((100*b-a*c)/(c-100)+0.5)) ","date":"0001-01-01","objectID":"/2018-03-16-1072/:0:0","tags":null,"title":"1072 게임","uri":"/2018-03-16-1072/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1075 풀이: 3자리 이후를 유지한 후 주어진 F로 나누어 지는 최솟값을 구하는 문제 답이 한자리 수일 경우 앞에 0을 붙이는 것을 주의하자. 코드: 사용언어 : Python 3 import math n = int(input()) f = int(input()) print('%02d' % (((math.ceil(((n//100) * 100) / f) * f) % 100))) ","date":"0001-01-01","objectID":"/2018-01-26-1075/:0:0","tags":null,"title":"1075 나누기","uri":"/2018-01-26-1075/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1076 풀이: 저항에 맞는 값을 하나씩 더한 후 마지막 값에 있는 저항에서 10의 index값만큼 제곱을 한 후 출력 코드: #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmath.h\u003e using namespace std; string b[10] = { \"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"grey\", \"white\" }; int main(void) { string a[3]; long long temp = 0, go = 0; for (int i = 0; i \u003c 3; i++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c 10; i++) { if (b[i] == a[0]) temp += i * 10; if (b[i] == a[1]) temp += i; if (b[i] == a[2]) go += powl(10, i); } cout \u003c\u003c temp * go \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2018-01-17-1076/:0:0","tags":null,"title":"1076 저항","uri":"/2018-01-17-1076/"},{"categories":null,"content":"https://www.acmicpc.net/problem/10808 풀이: 알파벳 순서대로 나온 카운트를 계산하여 하나씩 출력 코드: 사용언어 : Python 3 n=input() for i in range(97,123): print(n.count(chr(i)),end=' ') ","date":"0001-01-01","objectID":"/2018-02-04-10808/:0:0","tags":null,"title":"10808 알파벳 개수","uri":"/2018-02-04-10808/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1094 풀이: 자른 막대기 중 주어진 막대기보다 작은 값 중 최댓값을 주어진 막대기에 계속 뺀다. 뺄때마다 카운트를 증가시키면서 반복한다 코드: #include \u003ciostream\u003e using namespace std; int main(void) { int x, temp = 64, cnt = 0; cin \u003e\u003e x; while (x != 0) { if (x \u003e= temp) { cnt++; x -= temp; } else temp /= 2; } cout \u003c\u003c cnt \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2018-01-16-1094/:0:0","tags":null,"title":"1094 막대기","uri":"/2018-01-16-1094/"},{"categories":null,"content":"https://www.acmicpc.net/problem/10987 풀이: 모음의 개수를 출력 코드: 사용언어 : Python 3 n=input() print(sum(n.count(i)for i in 'aeiou')) ","date":"0001-01-01","objectID":"/2018-02-04-10987/:0:0","tags":null,"title":"10987 모음의 개수","uri":"/2018-02-04-10987/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1100 풀이: 8x8 의 체스칸 중 홀수행 홀수열, 짝수행 짝수열인 곳이 하얀 칸이다. 이 하얀칸 위에 말이 몇개있는지 카운트하여 출력한다. 코드: #include \u003ciostream\u003e using namespace std; char a[8][8]; int main(void){ int cnt = 0; for(int i=0;i\u003c8;i++){ for(int j=0;j\u003c8;j++) cin \u003e\u003e a[i][j]; } for(int i=0;i\u003c8;i++){ for(int j=0;j\u003c8;j++){ if(((j%2 == 0 \u0026\u0026 i%2 == 0) || (j%2 == 1 \u0026\u0026 i%2 == 1)) \u0026\u0026 a[i][j] == 'F') cnt ++; } } cout \u003c\u003c cnt \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2017-12-22-1100/:0:0","tags":null,"title":"1100 하얀 칸","uri":"/2017-12-22-1100/"},{"categories":null,"content":"https://www.acmicpc.net/problem/11006 풀이: 다리가 잘린 닭의 수 : 닭의 수 * 2 - 다리의 수 멀쩡한 닭의 수 : 닭의 수 - 다리가 잘린 닭의 수 코드: 사용언어 : Python 3 t=int(input()) for i in range(t): n,m=map(int,input().split()) print(m*2-n,m-(m*2-n)) ","date":"0001-01-01","objectID":"/2018-02-01-11006/:0:0","tags":null,"title":"11006 남욱의의 닭장","uri":"/2018-02-01-11006/"},{"categories":null,"content":"+++ author = “jyukki” categories = [“백준”] tags = [“algorithm”, “C++”, “DP”] date = “2017-11-30” description = “algorithm” featured = \"\" featuredalt = \"\" featuredpath = “date” linktitle = \"\" title = “[백준]11048 이동하기” +++ https://www.acmicpc.net/problem/11048 풀이: a[i][t] 는 i행 t열로 갈 때 사탕의 최대 갯수 a[i][t] 는 위에서 올때와 왼쪽에서 올때 중 최대값으로 구할 수 있다. a[i][t] += max(a[i - 1][t], a[i][t - 1]); 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[1002][1002] = { 0 }; int main(void) { int n, m; cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { for (int t = 1; t \u003c= m; t++) { cin \u003e\u003e a[i][t]; } } for (int i = 1; i \u003c= n; i++) { for (int t = 1; t \u003c= m; t++) { a[i][t] += max(a[i - 1][t], a[i][t - 1]); } } cout \u003c\u003c a[n][m] \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2017-11-30-11048/:0:0","tags":null,"title":"11048 이동하기","uri":"/2017-11-30-11048/"},{"categories":null,"content":"https://www.acmicpc.net/problem/11656 풀이: 접미사를 모두 리스트에 넣는다. 리스트를 사전순으로 정렬하고 출력한다. 코드: 사용언어 : Python 3 n=input() l=[] for i in range(len(n)): l.append(n[i:]) l.sort() for i in range(len(n)): print(l[i]) ","date":"0001-01-01","objectID":"/2018-02-04-11656/:0:0","tags":null,"title":"11656 접미사 배열","uri":"/2018-02-04-11656/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1267 풀이: 핸드폰 사용시간을 각각 요금제 시간에 맞게 나눈 몫을 구한다 몫을 요금제에 가격에 곱하고 그 가격을 비교한다. 코드: 사용언어 : Python 3 a,c,d=int(input()),0,0 b=list(map(int,input().split())) for i in range(a): c+=b[i]//30+ 1 d+=b[i]//60+ 1 if(c*10\u003cd*15): print(\"Y %d\" % (c*10)) elif(c*10==d*15): print(\"Y M %d\" % (c*10)) else: print(\"M %d\" % (d*15)) ","date":"0001-01-01","objectID":"/2018-03-16-1267/:0:0","tags":null,"title":"1267 핸드폰 요금","uri":"/2018-03-16-1267/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1297 풀이: 대각선길이, 높이비율, 너비비율을 각각 a,b,c라고 할 때 a^2 = (bx)^2 + (cx)^2 로 나타낼 수 있다. 이때 x 값이 a/((bb+cc)^0.5) 로 나타내지고 진짜 길이를 각각 bx, cx로 나타낼 수 있다. 코드: 사용언어 : Python 3 a,b,c=map(int,input().split()) x=a/((b*b+c*c)**.5) print(\"%d %d\"%(int(b*x),int(c*x))) ","date":"0001-01-01","objectID":"/2018-02-06-1297/:0:0","tags":null,"title":"1297 TV 크기","uri":"/2018-02-06-1297/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1302 풀이: 문자열을 하루 동안 팔린 책의 개수 N만큼 받아드린다. 책 제목이 같을경우 책의 개수를 1씩 증가시킨다. 팔린 책의 개수가 가장 많은 책을 출력한다. 만약 팔린 책의 개수가 같다면 사전순으로 먼저 나오는 것을 출력한다. 코드: 사용언어 : Python 3 n=int(input()) s={} q='' w=0 for i in range(n): k=input() if(k in s): s[k]+=1 else: s[k]=1 if(s[k]\u003ew): w=s[k] q=k elif(s[k]==w): if(q\u003ek): q=k print(q) ","date":"0001-01-01","objectID":"/2018-01-31-1302/:0:0","tags":null,"title":"1302 베스트셀러","uri":"/2018-01-31-1302/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1315 풀이: a[i][t] : 힘이 i이고, 지력이 t일 때, 깰 수 있는 퀘스트의 수 초기 능력치를 S, I 라고 했을 때, 깰 수 있는 퀘스트를 모두 클리어한다. 클리어 한 후 모인 스텟 포인트를 힘과 지력에 포인트를 적절히 분배한다. 분배한 힘과 지력으로 못 깬 퀘스트를 클리어 할 수 있는지 확인한다. 주의 사항: 시간이 너무 많이 걸리므로 메모이제이션을 통해 a[i][t] 가 값을 가지고 있다면 바로 리턴하도록 만든다. 이전에 방문했었던 visit이 누적될 수 있으므로 초기화해주는 것을 잊지말자. 포인트와 능력치를 더한값이 퀘스트 최대치인 1000을 넘어갈 수 있으므로, 1000으로 제한을 두자. 코드: #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e #include \u003cstring.h\u003e using namespace std; int n; int st[110], in[110], pn[110], visit[110] = { 0 }, a[1010][1010]; int rpg(int S, int I) { if (a[S][I] != -1) return a[S][I]; int po = 0, cnt = 0; vector \u003cint\u003e b; for (int i = 0; i \u003c n; i++) { if ((S \u003e= st[i] || I \u003e= in[i])) { if (!visit[i]) { visit[i] = 1; po += pn[i]; b.push_back(i); } cnt++; } } a[S][I] = cnt; for (int i = S; i \u003c= min(1000,S + po); i++) { int t = min(1000, I + po - i + S); a[S][I] = max(a[S][I], rpg(i, t)); } for (int i = 0; i \u003c b.size(); i++) visit[b[i]] = 0; return a[S][I]; } int main(void) { cin \u003e\u003e n; memset(a, -1, sizeof a); for (int i = 0; i \u003c n; i++) cin \u003e\u003e st[i] \u003e\u003e in[i] \u003e\u003e pn[i]; cout \u003c\u003c rpg(1, 1) \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2017-12-28-1315/:0:0","tags":null,"title":"1315 RPG","uri":"/2017-12-28-1315/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1357 풀이: 두 숫자를 뒤집어서 입력을 받는다. 입력받은 두 숫자를 더한 후 다시 뒤집는다. 코드: 사용언어 : Python 3 x,y=map(int,input()[::-1].split()) print(int(str(x+y)[::-1]))``` ","date":"0001-01-01","objectID":"/2018-02-04-1357/:0:0","tags":null,"title":"1357 뒤집힌 덧셈","uri":"/2018-02-04-1357/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1398 풀이: a[i] : i원의 가격의 차를 사기위한 동전 개수의 최솟값 동전의 크기가 1, 10 25, 100, 1000, 2500 …. 즉, 1, 10, 25가 100단위로 바뀌고있다. 이를 토대로 뒤의 2자리만 계산하여 구한다. cnt += a[n % 100] 10에 자리까지의 동전 개수를 구한 후 n을 100으로 나누고 계속 10에 자리까지의 동전 개수를 구한다. 코드: #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int a[101] = { 0 }, b[3] = { 1,10,25 }; int main(void) { int T; cin \u003e\u003e T; for (int t = 1; t \u003c 100; t++) { a[t] = INT32_MAX; for (int y = 0; y \u003c 3; y++) { if (t - b[y] \u003e= 0) a[t] = min(a[t], a[t - b[y]] + 1); } } for (int i = 0; i \u003c T; i++) { long long n; int cnt = 0; cin \u003e\u003e n; while (n \u003e 0) { cnt += a[n % 100]; n /= 100; } cout \u003c\u003c cnt \u003c\u003c endl; } return 0; } ","date":"0001-01-01","objectID":"/2018-01-04-1398/:0:0","tags":null,"title":"1398 동전 문제","uri":"/2018-01-04-1398/"},{"categories":null,"content":"https://www.acmicpc.net/problem/14501 풀이: 남은일이 N일 일때, M일의 상담을 완료하는데 걸리는 기간을 T(M)라고 가정한다. 1일에 상담을 했다면 할 수 있는 상담은 1+T(1) ~ N 까지가 있다. 1+T(1) 일에 상담을 했다면 할 수 있는 삼담은 1 + T(1) + T(1+T(1) ~ N 까지가 있다. N을 넘지않도록 주의하며 반복한 후 받을 수 있는 금액에 최대를 출력한다. 코드: 사용언어 : c++ {% highlight c++ %} #include using namespace std; int a, b[16], c[16]; int ts(int q) { int max = 0; for (int i = q; i \u003c a; i++) { int w = c[i] + ts(i + b[i]); if (i + b[i] \u003e a) w = 0; max = max \u003e w ? max : w; } return max; } int main(void) { cin » a; for (int i = 0; i \u003c a; i++) cin » b[i] » c[i]; cout « ts(0) « endl; return 0; } {% endhighlight %} ","date":"0001-01-01","objectID":"/2019-05-25-14501/:0:0","tags":null,"title":"14501 퇴사","uri":"/2019-05-25-14501/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1568 풀이: 처음 새의 수 n에서 숫자 k를 노래할 때 나중 새의 수 = n - k 노래의 숫자 수를 1씩 증가시켜가며 새의 수보다 많아질 경우 1로 돌아간다. 만약 새의 수가 0이되면 카운트를 출력한다. 코드: 사용언어 : Python 3 k=int(input()) cnt,s=0,1 while True: if k==0: break if s\u003ek: s=1 cnt+=1 k-=s s+=1 print(cnt) ","date":"0001-01-01","objectID":"/2018-01-30-1568/:0:0","tags":null,"title":"1568 새","uri":"/2018-01-30-1568/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1629 풀이: a, 19 일 때 a*a^18 a*(a^9)^2 a*(a*(a^4)^2)^2 a*(a*((a^2)^2)^2)^2 이런 식으로 풀면 된다. 코드: pow함수 이용 사용언어 : Python 3 a,b,c=map(int,input().split()) print(pow(a,b,c)) 코드: 사용언어 : Python 3 a,b,c=map(int,input().split()) def q(k): if(k==0):return 1 w=q(k/2) n=(w*w)%c if(k%2):n=(n*a)%c return n print(q(b)) ","date":"0001-01-01","objectID":"/2018-02-05-1629/:0:0","tags":null,"title":"1629 곱셈","uri":"/2018-02-05-1629/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1660 풀이: b[i] : i개의 대포알의 개수로 만들 수 있는 사면체의 최소 개수 a[i] : 사면체의 사이즈가 i인 대포알의 개수 b[i] = min(b[i], b[num - a[i]] + 1) 주의사항: 시간초과에 유의하여 메모이제이션을 하도록한다. min함수를 사용하므로 초기값을 매우 크게 잡아주는 것을 잊지말자. 코드: #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int a[200] = { 0 }, b[300010] = { 0 }, q = 1; int cap(int num) { if (num \u003c= 0 ) return 0; if (b[num]) return b[num]; b[num] = 300000; for (int i = q; i \u003e 0; i--) { if (a[i] \u003c= num) b[num] = min(b[num], cap(num - a[i]) + 1); } return b[num]; } int main(void) { int n, cnt = 1; cin \u003e\u003e n; while(true) { a[q] = a[q - 1] + cnt; cnt += q + 1; if (a[q] \u003e n) break; q++; } cout \u003c\u003c cap(n) \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2017-12-31-1660/:0:0","tags":null,"title":"1660 캡틴 이다솜","uri":"/2017-12-31-1660/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1668 풀이: 왼쪽에서부터 높이를 세며, 더 높은 트로피가 나올때마다 카운트를 증가 오른쪽도 똑같이 한 후 카운트를 출력 코드: 사용언어 : Python 3 n,cnt1,cnt2,k1,k2=int(input()),0,0,0,0 h={} for i in range(n): h[i]=int(input()) for i in range(0,n): if(h[i]\u003ek1): k1=h[i] cnt1+=1 if(h[n-1-i]\u003ek2): k2=h[n-1-i] cnt2+=1 print(cnt1) print(cnt2) ","date":"0001-01-01","objectID":"/2018-01-31-1668/:0:0","tags":null,"title":"1668 트로피 진열","uri":"/2018-01-31-1668/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1720 풀이: a[i] : 2Xi인 타일을 채울 수 있는 경우의 수(중복 포함) b[i] : 2Xi인 타일을 채울 수 있는 경우의 수(중복 미포함) 짝수 일때와 홀수일때 대칭의 경우의 수가 다르므로 나눠서 계산한다. 코드: #include \u003ciostream\u003e using namespace std; int a[32] = { 1,1,3 }; int b[32] = { 1,1,3 }; int main(void) { int n; cin \u003e\u003e n; for (int i = 3; i \u003c= n; i++) { a[i] = a[i - 1] + a[i - 2] * 2; b[i] = a[i]; } int t = 0; if (n % 2 == 1) { while (n - t \u003e= 2 \u0026\u0026 t \u003c n / 2 + 1) { b[n] -= a[n - t - 2]; t++; } } else { while (n - t \u003e= 2 \u0026\u0026 t + 1 \u003c n / 2) { b[n] -= a[n - t - 2]; t++; } } cout \u003c\u003c b[n] \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2017-12-23-1720/:0:0","tags":null,"title":"1720 타일 코드","uri":"/2017-12-23-1720/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1789 풀이: 입력받은 숫자를 N 이라고 할 때 (-1 + (1+8*N)^0.5)/2 에 소수점을 버린 값이 최대 개수이다. n(n+1)/2 \u003e= k n^2+n-2k \u003e= 0 n의 최솟값이다. 코드: 사용언어 : Python 3 print(int((-1+(1+8*int(input()))**.5)/2)) ","date":"0001-01-01","objectID":"/2018-02-04-1789/:0:0","tags":null,"title":"1789 수들의 합","uri":"/2018-02-04-1789/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1834 풀이: 나머지와 몫이 같은 수는 N+1에 배수의 형태로 나타난다. 3일때 4,8 , 4일때 5,10,15 등 n+1의 배수가 n-1번 나타난다. 즉 (n+1)Σ(n-1) 이다. (n+1)n(n-1)/2 (n^3-n)/2 코드: 사용언어 : Python 3 n=int(input()) print((n**3-n)//2) ","date":"0001-01-01","objectID":"/2018-02-05-1834/:0:0","tags":null,"title":"1834 나머지와 몫이 같은 수","uri":"/2018-02-05-1834/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1940 풀이: 재료들이 가진 고유의 번호를 가진 리스트를 a라고 하자 이 때 갑옷을 만드는데 필요한 숫자인 M에서 i번째 고유번호인 a[i]를 뺀 값이 리스트 a에 있다면 갑옷을 1개 만들 수 있는 것이므로 카운트를 1 증가시킨다. 계속 증가시키다 보면 서로 짝이되는 수 2개를 모두 카운트를 시키게 되므로 2로 나눠준다. 코드: 사용언어 : Python 3 n,m=int(input()),int(input()) a=input().split() print(sum(a.count(str(m-int(a[i])))for i in range(n))//2) ","date":"0001-01-01","objectID":"/2018-02-05-1940/:0:0","tags":null,"title":"1940 주몽","uri":"/2018-02-05-1940/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1947 풀이: a[i] : i명이 선물을 나눠갖는 경우의 수 a[i - 1] * (i - 1) : i번 째 사람이 i - 1 번째 사람의 선물을 골랐을 경우 a[i - 2] * (i - 1) : i번 째 사람이 i - 1 번째 사람의 선물을 고르지 않았을 경우 주의사항: a[1] 일 때 즉, 1명 일 때 경우의 수가 아무것도 하지않는 것 1개일줄 알았으나 0개로 취급. 너무 큰 수가 계산되므로 주어진 수로 나눈 나머지를 출력한다. 코드: #include \u003ciostream\u003e using namespace std; long long a[1000010] = { 0,0,1,2 }; int main(void) { int n; cin \u003e\u003e n; for (int i = 4; i \u003c= n; i++) { a[i] = ((i - 1) * (a[i - 1] + a[i - 2]))% 1000000000; } cout \u003c\u003c a[n] \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2018-01-01-1947/:0:0","tags":null,"title":"1947 선물 전달","uri":"/2018-01-01-1947/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1964 풀이: 1,5,12,22…. 더해가는 숫자가 3씩 증가되므로 1+3*Σn+n 이라고 할 수 있다. 3*n(n+1)/2+n+1 이 되고 (n+1)로 묶어서 정리하면 (n+1)(3n+2)/2 가 된다. 이를 45678로 나눈 나머지로 출력하면 된다. 코드: 사용언어 : Python 3 n=int(input()) print((n+1)*(3*n+2)//2%45678) ","date":"0001-01-01","objectID":"/2018-02-05-1964/:0:0","tags":null,"title":"1964 오각형, 오각형, 오각형…","uri":"/2018-02-05-1964/"},{"categories":null,"content":"https://www.acmicpc.net/problem/1977 풀이: m 이상 n이하의 완전제곱수를 다 더한 후 최솟값을 출력 만약 sum이 0이라면 -1을 출력 코드: #include \u003ciostream\u003e using namespace std; int main(void) { int m, n, mini = 0, sum = 0, i = 1; cin \u003e\u003e m \u003e\u003e n; while (true) { if (i*i \u003e= m) { if (i * i \u003e n) break; if (mini == 0) mini = i * i; sum += i * i; } i++; } if (sum == 0) cout \u003c\u003c \"-1\" \u003c\u003c endl; else cout \u003c\u003c sum \u003c\u003c endl \u003c\u003c mini \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2018-01-18-1977/:0:0","tags":null,"title":"1977 완전제곱수","uri":"/2018-01-18-1977/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2011 풀이: dp[a]를 a자리 까지 숫자를 암호화 할 수 있는 가짓수 라고 하자. (a - 1) * 10 + a 가 10~26 사이라면 dp[a] = dp[a - 1] + dp[a - 2] 가 된다. 10~26 사이가 아니라면, dp[a] = dp[a - 1] 이 된다. 이 때, a 가 0 이라면, 암호를 해석 할 수 없으므로 0을 출력한다. (이 때, (a - 1 * 10 + a) 가 10 ~ 26 사이라면 가능하므로 주의하자) 정답이 매우 클 수 있으므로, 1000000으로 나눈 나머지를 출력한다. 1번째 자리의 숫자가 0이라면 무조건 암호가 잘못되어 있으므로 0을 출력한다. 코드: 사용언어 : c++ {% highlight c++ %} #include #include \u003cstring.h\u003e using namespace std; int d[5002] = { 1, 1 }; int main(void) { char n[5001]; cin » n; for (int i = 2; i \u003c= strlen(n); i++) { if (n[i - 1] == ‘0’) d[i - 1] = 0; d[i] = d[i - 1]; if (n[i - 2] == ‘1’ || (n[i - 2] == ‘2’ \u0026\u0026 n[i - 1] \u003c ‘7’)) (d[i] += d[i - 2]) %= 1000000; } if (n[0] == ‘0’) cout « 0 « endl; else cout « d[strlen(n)] « endl; return 0; } {% endhighlight %} ","date":"0001-01-01","objectID":"/2019-06-03-2011/:0:0","tags":null,"title":"2011 암호코드","uri":"/2019-06-03-2011/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2018 풀이: (i + 1) + (i + 2) + (i + 3) + … + (i + j) = n i * j + (1 + 2 + 3 + … + j) = n n - (1 + 2 + 3 + … + j) = i * j n - j*(j+1)/2 = i * j (n - j*(j+1)/2) / j = i 즉 (n - j*(j+1)/2) / j 가 정수 (n - j*(j+1)/2) % j == 0 코드: 사용언어 : Python 3 n,cnt=int(input()),0 for i in range(1,n+1): if(n-(i*(i+1))/2 \u003c 0): break if((n-(i*(i+1))/2)%i==0): cnt+=1 print(cnt) ","date":"0001-01-01","objectID":"/2018-02-02-2018/:0:0","tags":null,"title":"2018 수들의 합5","uri":"/2018-02-02-2018/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2240 풀이: s[t][w]를 자두의 남은 이동수가 w이고, 1 ~ t번째 자두까지 받아먹을 수 있는 최대 갯수 t의 숫자를 늘리며 이전 번째 자두수에서 +1을 해준다. 자두나무가 같다면 w를 같게 다르다면 +1해준다. 이때 w가 최대 이동횟수를 넘지않도록 주의한다. 코드: 사용언어 : c++ {% highlight c++ %} #include #include using namespace std; int T, w, a[1002]; int s[1002][32] = { 0 }; int main(void) { cin » T » w; int m = 0; a[0] = 1; s[0][w] = 1; for (int i = 1; i \u003c= T; i++) cin » a[i]; for (int i = 1; i \u003c= T; i++) for (int t = 0; t \u003c i; t++) for (int y = 0; y \u003c= w; y++) { if (a[i] != a[t] \u0026\u0026 s[t][y + 1] != 0) s[i][y] = max(s[i][y], s[t][y + 1] + 1); else if (a[i] == a[t] \u0026\u0026 s[t][y] != 0) s[i][y] = max(s[i][y], s[t][y] + 1); m = max(m, s[i][y]); } cout « m - 1 « endl; return 0; } {% endhighlight %} ","date":"0001-01-01","objectID":"/2019-05-26-2240/:0:0","tags":null,"title":"2240 자두나무","uri":"/2019-05-26-2240/"},{"categories":null,"content":"+++ author = “jyukki” categories = [“백준”] tags = [“algorithm”, “C++”, “DP”] date = “2017-11-29” description = “algorithm” featured = \"\" featuredalt = \"\" featuredpath = “date” linktitle = \"\" title = “[백준]2579 계단 오르기” +++ https://www.acmicpc.net/problem/2579 풀이: b[i][0] 은 i번째를 골랐을 때, i-1번째를 안고른 경우의 수 b[i][1] 은 i번째를 골랐을 때, i-1번째를 고른 경우의 수 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main(void) { int n; cin \u003e\u003e n; int a[301]; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } int b[301][2] = { a[0],0,a[1],a[0] + a[1],0 }; for (int i = 2; i \u003c n; i++) { for (int t = 0; t \u003c 2; t++) { if (t == 0) b[i][t] = max(b[i - 2][0], b[i - 2][1]) + a[i]; if (t == 1) b[i][t] = b[i - 1][0] + a[i]; } } cout \u003c\u003c max(b[n - 1][0], b[n - 1][1]) \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2017-11-29-2579/:0:0","tags":null,"title":"2579 계단 오르기","uri":"/2017-11-29-2579/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2616 풀이: a[i][t] : i 번째 까지의 소형 기관차 들이 t번째 객차까지 끌 수 있는 최대 승객의 수 첫 번째 소형기관차부터 앞으로 m칸만큼 객차칸수를 증가시켜가며 최댓값을 구한다. 만약 앞에 값이 더 크다면 앞에값을 선택한다. 객차의 칸이 겹칠 수 없으므로 이번 소형기관차(a[i][t])보다 m보다 작은 객차수를 가지고 있는 이전의 소형기관차(a[i - 1][t - m])를 이번 소형기관창의 t번째 최대 승객 수에 더해준다. a[i][t] = max(a[i][t - 1], sum[t] - sum[t - m] + a[i - 1][t - m]; 코드: #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int n, m, sum[50002] = { 0 }, a[4][50002] = { 0 }; int main(void) { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e sum[i]; sum[i] += sum[i - 1]; } cin \u003e\u003e m; for (int i = 1; i \u003c= 3; i++) { for (int t = i * m; t \u003c= n; t++) { a[i][t] = max(a[i][t - 1], sum[t] - sum[t - m] + a[i - 1][t - m]); } } cout \u003c\u003c a[3][n] \u003c\u003c endl; return 0; } 시간 초과 코드: #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int a[50001]; int main(void) { int n, m; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } cin \u003e\u003e m; int num = 0; for (int i = 0; i \u003c= n - 3 * m; i++) { for (int t = i + m; t \u003c= n - 2 * m; t++) { for (int y = t + m; y \u003c= n - m; y++) { int cnt = 0; for (int q = 0; q \u003c m; q++) { cnt += a[i + q] + a[t + q] + a[y + q]; } num = max(num, cnt); } } } cout \u003c\u003c num \u003c\u003c endl; return 0; } 메모리 초과 코드: #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int n, m; int sum[50002] = { 0 }; int small(int a,int b,int c) { if (a + 3 * m \u003e n) return 0; if (b + 2 * m \u003e n) return small(a + 1, a + m + 1, a + 2 * m + 1); if (c + m \u003e n) return small(a, b + 1, b + m + 1); int num = 0; num += sum[a + m] - sum[a] + sum[b + m] - sum[b] + sum[c + m] - sum[c]; return num = max(num, small(a, b, c + 1)); } int main(void) { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e sum[i]; sum[i] += sum[i - 1]; } cin \u003e\u003e m; cout \u003c\u003c small(0, m, 2 * m) \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2017-12-30-2616/:0:0","tags":null,"title":"2616 소형기관차","uri":"/2017-12-30-2616/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2688 풀이: a[t][y] : t + 1 개의 자릿수에서의 줄어들지 않는 수의 갯수 a[t][y] = a[t][y - 1] + a[t - 1][y] 앞자리의 갯수가 1 증가할 때 마다 이전 자릿수의 개수를 더해가는 방식으로 구한다. 최종 자릿수 9가되면 모든 수가 누적되어 있으므로 출력한다. 코드: #include \u003ciostream\u003e using namespace std; long long a[65][10] = { 1,2,3,4,5,6,7,8,9,10,0 }; int main(void) { int T, n; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n; for (int t = 1; t \u003c n; t++) { a[t][0] = 1; for (int y = 1; y \u003c 10; y++) { a[t][y] = a[t][y - 1] + a[t - 1][y]; } } cout \u003c\u003c a[n - 1][9] \u003c\u003c endl; } return 0; } 사간 초과 풀이: 처음 풀이를 할 때 저번 1038 감소하는 수를 푸는 것처럼 하나하나 만들어 가면서 카운트를 하려 했으나 시간초과가 난다. 시간 초과 코드: #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; vector\u003cint\u003e a; int main(void) { int T, n; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { int cnt = 1; cin \u003e\u003e n; for (int t = 0; t \u003c n; t++) a.push_back(0); while (a[n - 1] \u003c 10) { a[0]++; for (int t = 0; t \u003c n - 1; t++) { if (a[t] == 10) { a[t + 1]++; a[t] = 0; } if (a[t] \u003e a[t + 1]) { a[t + 1]++; a[t] = 0; } } cnt++; } cout \u003c\u003c cnt - 1 \u003c\u003c endl; } return 0; } ","date":"0001-01-01","objectID":"/2017-12-24-2688/:0:0","tags":null,"title":"2688 줄어들지 않아","uri":"/2017-12-24-2688/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2743 풀이: 단어의 길이를 출력 코드: #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; int main(void) { string a; cin \u003e\u003e a; cout \u003c\u003c a.length() \u003c\u003c endl; } ","date":"0001-01-01","objectID":"/2017-12-25-2743/:0:0","tags":null,"title":"2743 단어 길이 재기","uri":"/2017-12-25-2743/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2749 풀이: 코드 설명은 피보나치 코드 참고 참고의 문제와는 다르게 매우 큰 수가 들어온다. 피보나치를 n으로 나누면 주기가 생성되는데 주기로 끊어서 풀도록 한다. 코드: #include \u003ciostream\u003e using namespace std; long long a[3] = { 0,1 }, n; int main() { cin \u003e\u003e n; for (int i = 2; i \u003c= n % 1500000; i++) a[i % 3] = (a[(i - 1) % 3] + a[(i - 2) % 3]) % 1000000; cout \u003c\u003c a[(n % 1500000) % 3] \u003c\u003c endl; } 참고: https://www.acmicpc.net/blog/view/28 피보나치 코드: https://jyukki97.github.io/2748 ","date":"0001-01-01","objectID":"/2018-01-06-2749/:0:0","tags":null,"title":"2749 피보나치 수3","uri":"/2018-01-06-2749/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2858 풀이: 전체 사각형의 면적으로 가로 세로를 찾은 후 그 가로 세로에서 2를 뺀것의 넓이가 안쪽 갈색의 면적과 같다면 그 가로 세로가 각각 L, W 라고 할 수 있다. 코드: 사용언어 : Python 3 r,b=map(int,input().split()) for i in range(3,(r+b)//2): if((r+b)%i==0 and (i-2)*(((r+b)/i)-2)==b): print(((r+b)//i),i) break ","date":"0001-01-01","objectID":"/2018-02-02-2858/:0:0","tags":null,"title":"2858 기숙사 바닥","uri":"/2018-02-02-2858/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2896 풀이: 주스의 비율을 주스의 양으로 나눈 값이 가장 작은 주스를 찾는다. 주스의 비율에서 주스의 양 * 1번에서 구한 값 을 출력한다. 코드: 사용언어 : Python 3 a,b,c=map(int,input().split()) d,e,f=map(int,input().split()) g=min(a/d,b/e,c/f) print(\"%.4f %.4f %.4f\"%(a-d*g,b-e*g,c-f*g)) ","date":"0001-01-01","objectID":"/2018-03-16-2896/:0:0","tags":null,"title":"2896 무알콜 칵테일","uri":"/2018-03-16-2896/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2902 풀이: 대문자를 출력 코드: #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; string a; int main(void) { cin \u003e\u003e a; for (int i = 0; i \u003c a.length(); i++) { if (a[i] \u003e 64 \u0026\u0026 a[i] \u003c 91) cout \u003c\u003c a[i]; } cout \u003c\u003c endl; } ","date":"0001-01-01","objectID":"/2018-01-09-2902/:0:0","tags":null,"title":"2902 KMP는 왜 KMP일까?","uri":"/2018-01-09-2902/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2903 풀이: N 단계를 진행할 경우 ((2^N) +1)^2 만큼 점의 개수가 생긴다. 코드: 사용언어 : Python 3 print(((2**int(input()))+1)**2) ","date":"0001-01-01","objectID":"/2018-02-04-2903/:0:0","tags":null,"title":"2903 중앙 이동 알고리즘","uri":"/2018-02-04-2903/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2914 풀이: 올림을 했으므로 평균값에서 1을 뺀 후 수록된 곡의 갯수와 곱한 뒤 1을 더해준다. 코드: 사용언어 : Python 3 a, b = map(int, input().split(' ')) print(a * (b-1) + 1) ","date":"0001-01-01","objectID":"/2018-01-25-2914/:0:0","tags":null,"title":"2914 저작권","uri":"/2018-01-25-2914/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2921 풀이: 세트의 크기가 N인 도미노 세트의 점의 개수 : N*(N+1)*(N+2)/2 코드: 사용언어 : Python 3 n=int(input()) print(n*(n+1)*(n+2)//2) ","date":"0001-01-01","objectID":"/2018-02-01-2921/:0:0","tags":null,"title":"2921 도미노","uri":"/2018-02-01-2921/"},{"categories":null,"content":"https://www.acmicpc.net/problem/2965 풀이: A 캥거루와 B 캥거루,C 캥거루와 B 캥거루 사이 거리 중 최댓값에서 1을 뺀 값을 출력 코드: 사용언어 : Python 3 a, b, c= map(int, input().split(' ')) print(max(b - a, c - b) - 1) ","date":"0001-01-01","objectID":"/2018-01-25-2965/:0:0","tags":null,"title":"2965 캥거루 세마리","uri":"/2018-01-25-2965/"},{"categories":null,"content":"https://www.acmicpc.net/problem/3046 풀이: R2 = 2 * S - R1 코드: #include \u003ciostream\u003e using namespace std; int main(){ int r, s; cin \u003e\u003e r \u003e\u003e s; cout \u003c\u003c 2 * s - r \u003c\u003c endl; return 0; } ","date":"0001-01-01","objectID":"/2018-01-03-3046/:0:0","tags":null,"title":"3046 R2","uri":"/2018-01-03-3046/"},{"categories":null,"content":"https://www.acmicpc.net/problem/3049 풀이: 교차점은 N각형 블록에서 꼭짓점 4개를 선택하여 그 사각형의 내부에 생기는 점의 합이라고 할 수 있다. 그러므로 N개의 꼭짓점 중 4개를 선택하는 경우의 수가 교차점의 개수라고 할 수 있다. 그러므로 답은 nC4 코드: 사용언어 : Python 3 n=int(input()) print(n*(n-1)*(n-2)*(n-3)//24) ","date":"0001-01-01","objectID":"/2018-02-06-3049/:0:0","tags":null,"title":"3049 다각형의 대각선","uri":"/2018-02-06-3049/"},{"categories":null,"content":"https://www.acmicpc.net/problem/3067 풀이: 출처의 문제와 같으므로 출처를 참고. 코드: #include \u003ciostream\u003e using namespace std; int main(void) { int T, a, num; cin \u003e\u003e T; for (int y = 0; y \u003c T; y++) { int coin[10001] = { 0 }; cin \u003e\u003e a; int *q = new int[a]; for (int i = 0; i \u003c a; i++) cin \u003e\u003e q[i]; cin \u003e\u003e num; for (int i = 0; i \u003c= num; i++) { if (i%q[0] == 0) coin[i]++; } for (int i = 1; i \u003c a; i++) { for (int t = q[i]; t \u003c= num; t++) coin[t] += coin[t - q[i]]; } cout \u003c\u003c coin[num] \u003c\u003c endl; } return 0; } **출처 : 2293 동전1 ** https://jyukki97.github.io/2293 ","date":"0001-01-01","objectID":"/2017-12-29-3067/:0:0","tags":null,"title":"3067 Coins","uri":"/2017-12-29-3067/"},{"categories":null,"content":"https://www.acmicpc.net/problem/3474 풀이: 오른쪽 끝에있는 0에 갯수를 알기 위해서는 팩토리얼 안에서 10의 갯수가 얼마나 있는지를 알면된다. 이 때 2의 갯수는 매우 많으므로 팩토리얼 내에서 5가 몇번 곱해지는지를 세면 간단하게 알 수 있다. 주어진 수를 5로 나눈 몫이 5의 갯수이다 그러나 25, 125 등 5가 여러번 들어가는 경우도 있으므로 각각으로 나누어준 값을 더해주어야한다. 코드: 사용언어 : Python 3 {% highlight Python %} for i in range(int(input())): a,b,c=int(input()),5,0 while b\u003c=a: c+=a//b b*=5 print(c) {% endhighlight %} ","date":"0001-01-01","objectID":"/2018-03-16-3474/:0:0","tags":null,"title":"3474 교수가 된 현우","uri":"/2018-03-16-3474/"},{"categories":null,"content":"https://www.acmicpc.net/problem/4504 풀이: 배수인지 아닌지 확인 후 주어진 조건에 맞게 출력 만약 받아드리는 수가 0이라면 반복을 끝낸다. 코드: 사용언어 : Python 3 n=int(input()) while True: k=int(input()) if k==0: break if(k%n==0): print(k,\"is a multiple of %d.\"%(n)) else: print(k,\"is NOT a multiple of %d.\"%(n)) ","date":"0001-01-01","objectID":"/2018-02-04-4504/:0:0","tags":null,"title":"4504 배수 찾기","uri":"/2018-02-04-4504/"},{"categories":null,"content":"https://www.acmicpc.net/problem/5218 풀이: 알파벳 거리를 출력 만약 음수라면 26을 더한다. 코드: 사용언어 : Python 3 n=int(input()) for i in range(n): a,b=map(str,input().split()) print(\"Distances:\",end=' ') for t in range(len(a)): if(ord(a[t])\u003eord(b[t])): print(ord(b[t])-ord(a[t])+26,end=' ') else: print(ord(b[t])-ord(a[t]),end=' ') print() ","date":"0001-01-01","objectID":"/2018-02-04-5218/:0:0","tags":null,"title":"5218 알파벳 거리","uri":"/2018-02-04-5218/"},{"categories":null,"content":"https://www.acmicpc.net/problem/9184 풀이: DP함수가 주어져 있으므로 메모이제이션을 하면된다. 단, a, b, c 의 최대 크기가 주어져있지않으므로 20이 넘어간 값은 생략하도록한다. -1, -1, -1 이 입력으로 들어올 경우 루프를 끝날 수 있게 만든다. 코드: #include \u003ciostream\u003e #include \u003cstring.h\u003e using namespace std; int fuc[21][21][21]; int w(int a,int b,int c) { if (a \u003c= 0 || b \u003c= 0 || c \u003c= 0) return 1; if (a \u003e 20 || b \u003e 20 || c \u003e 20) return fuc[20][20][20] = w(20, 20, 20); if (fuc[a][b][c] \u003e -1) return fuc[a][b][c]; if (a \u003c b \u0026\u0026 b \u003c c) return fuc[a][b][c] = w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c); return fuc[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1); } int main(void) { int a, b, c; memset(fuc, -1, sizeof(fuc)); while(true){ cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; if (a == -1 \u0026\u0026 b == -1 \u0026\u0026 c == -1) break; cout \u003c\u003c \"w(\" \u003c\u003c a \u003c\u003c \", \" \u003c\u003c b \u003c\u003c \", \" \u003c\u003c c \u003c\u003c \") = \" \u003c\u003c w(a, b, c) \u003c\u003c endl; } return 0; } ","date":"0001-01-01","objectID":"/2018-01-12-9184/:0:0","tags":null,"title":"9184 신나는 함수 실행","uri":"/2018-01-12-9184/"},{"categories":null,"content":"https://www.acmicpc.net/problem/9251 풀이: dp[a][b]를 1 ~ a번째 까지의 문자열과 1 ~ b 까지의 문자열로 이루어진 최장 공통 부분수열이라고 하자. a번째 문자와 b번째 문자가 같다면, dp[a - 1][b - 1] 에 1을 더해준다. 즉, dp[a][b] = dp[a - 1][b - 1] + 1 이 된다. a번째 문자와 b번째 문자가 다르다면, a번째 문자를 제거한 문자열과 b번째 문자를 제거한 문자열을 비교하여 최댓값을 받는다. 즉, dp[a][b] = max(dp[a - 1][b], dp[a][b - 1]) 이 된다. 코드: 사용언어 : c++ {% highlight c++ %} #include #include #include using namespace std; int d[1002][1002]; int main(void) { string a,b; cin » a » b; for (int i = 0; i \u003c a.length(); i++) for (int t = 0; t \u003c b.length(); t++) if (a[i] == b[t]) d[i + 1][t + 1] = d[i][t] + 1; else d[i + 1][t + 1] = max(d[i + 1][t], d[i][t + 1]); cout « d[a.length()][b.length()] « endl; return 0; } {% endhighlight %} ","date":"0001-01-01","objectID":"/2019-05-31-9251/:0:0","tags":null,"title":"9251 LCS","uri":"/2019-05-31-9251/"},{"categories":null,"content":"https://www.acmicpc.net/problem/9322 풀이: 제 1 공개키에 각각에 단어들이 제 2 공개키에 어디에 있는지 확인한다. 제 1 공개키에 첫번째 단어부터 제 2 공개키에서의 위치에 있는 암호키를 출력한다. 코드: 사용언어 : Python 3 a,b,c=[],[],[] for i in range(int(input())): n=int(input()) a,b,c=input().split(),input().split(),input().split() for t in range(n): print(c[b.index(a[t])],end=\" \") ","date":"0001-01-01","objectID":"/2018-02-04-9322/:0:0","tags":null,"title":"9322 철벽 보안 알고리즘","uri":"/2018-02-04-9322/"},{"categories":null,"content":"+++ author = “jyukki” categories = [“백준”] tags = [“algorithm”, “C++”, “DP”] date = “2017-11-30” description = “algorithm” featured = \"\" featuredalt = \"\" featuredpath = “date” linktitle = \"\" title = “[백준]9465 스티커” +++ https://www.acmicpc.net/problem/9465 풀이: a[i][t] 는 i행 t열의 스티커를 골랐을 때 최대 점수 a[t][i] += max(a[(t + 1) % 2][i - 2], a[(t + 1) % 2][i - 1]) 코드: #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int a[2][100001] = { 0 }; int main(void) { int T,n; cin \u003e\u003e T; for (int y = 0; y \u003c T; y++) { cin \u003e\u003e n; for (int t = 0; t \u003c 2; t++) { for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[t][i]; } } for (int i = 1; i \u003c n; i++) { for (int t = 0; t \u003c 2; t++) { a[t][i] += max(a[(t + 1) % 2][i - 2], a[(t + 1) % 2][i - 1]); } } cout \u003c\u003c max(a[0][n - 1], a[1][n - 1]) \u003c\u003c endl; } } ","date":"0001-01-01","objectID":"/2017-11-30-9465/:0:0","tags":null,"title":"9465 스티커","uri":"/2017-11-30-9465/"},{"categories":null,"content":"https://www.acmicpc.net/problem/9546 풀이: 처음 사람의 수 = 2^k - 1 코드: 사용언어 : Python 3 t=int(input()) for i in range(t): k=int(input()) print((2**k)-1) ","date":"0001-01-01","objectID":"/2018-01-29-9546/:0:0","tags":null,"title":"9546 3000번 버스","uri":"/2018-01-29-9546/"},{"categories":null,"content":"https://www.acmicpc.net/problem/9550 풀이: 사탕개수를 최소 K개 만큼 주어야 하므로 각각의 사탕을 K로 나눈 몫을 모두 더한 값을 출력한다. 코드: 사용언어 : Python 3 T = int(input()) for i in range(T): cnt = 0 n,k = map(int,input().split(' ')) c = input().split(' ') for t in range(n): cnt += int(c[t]) // k print(cnt) ","date":"0001-01-01","objectID":"/2018-01-27-9550/:0:0","tags":null,"title":"9550 아이들은 사탕을 좋아해","uri":"/2018-01-27-9550/"},{"categories":null,"content":"https://www.acmicpc.net/problem/9764 풀이: a[i][t] : 정수 i를 나타낼 때, 처음 더하는 수가 t인 경우의 수 a[i][t]는 i에서 t만큼 뺀 수에서 t보다 큰 수를 더한 값과 동일하다. 예를들어 5 : 1 + 4 = 2 + 3 = 5 로 나타낼 수 있는데 맨 앞자리를 1을 고를 경우 4의 앞자리가 1보다 큰 경우의 수를 모두 더한값과 같다. 이와 동일하게 2,3,4,5를 모두 할 경우 5의 경우의 수는 3개가 나오게 된다. 주의 사항: n의 경우의 수를 구할 때 값이 매우 커지므로 100999로 나눈 나머지로 출력한다. n의 경우의 수를 구할 때 a[n][n]값을 1로 설정해주는 것을 잊지말자. 코드: #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int a[2010][2010] = { 0 }; int main(void) { int T, n; int q = 1; cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { cin \u003e\u003e n; for (int t = q; t \u003c= n; t++) { for (int y = 1; y \u003c= t; y++) { for (int u = y + 1; u \u003c t; u++) { a[t][y] += a[t - y][u] % 100999; } } a[t][t] = 1; } int sum = 0; for (int t = 1; t \u003c= n; t++) { sum = (sum % 100999 + a[n][t] % 100999) % 100999; } cout \u003c\u003c sum \u003c\u003c endl; q = max(q, n + 1); } return 0; } ","date":"0001-01-01","objectID":"/2017-12-27-9764/:0:0","tags":null,"title":"9764 서로 다른 자연수의 합","uri":"/2017-12-27-9764/"}]