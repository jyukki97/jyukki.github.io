<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>수학 - Tag - JYUKKI&#39;s BLOG</title>
        <link>https://jyukki97.github.io/tags/%EC%88%98%ED%95%99/</link>
        <description>수학 - Tag - JYUKKI&#39;s BLOG</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 20 Jun 2021 22:00:40 &#43;0800</lastBuildDate><atom:link href="https://jyukki97.github.io/tags/%EC%88%98%ED%95%99/" rel="self" type="application/rss+xml" /><item>
    <title>[백준]1323 숫자 연결하기</title>
    <link>https://jyukki97.github.io/1323/</link>
    <pubDate>Sun, 20 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/1323/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1323
풀이: 나머지 연산의 성질을 이용한다.
나머지 연산의 경우 연산에 어디에 나머지 연산을 추가하든 나머지 연산의 값만 동일하다면, 최종 값도 동일하게 나온다.
그러므로 주어진 N을 K로 나눈 나머지를 확인하고,
0이 아니라면, 나온 나머지를 N과 연결하여 다시 K로 나눈 나머지를 확인한다.
0이 나올 때까지 반복한다.
나머지 연산 특성상 일정 개수 이상일 경우 반복하기 때문에 무한루프에 빠질 수 있다. 그러므로 최대 K번을 넘기지 않는다.
코드: 사용언어 : python
1 2 3 4 5 6 7  n,k=map(int,input().]]></description>
</item><item>
    <title>[백준]1241 머리 톡톡</title>
    <link>https://jyukki97.github.io/1241/</link>
    <pubDate>Sat, 19 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/1241/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1241
풀이: 1번 부터 N번까지 학생들의 머리 위의 숫자들의 개수를 저장해놓는다
ex) 2는 2번, 1은 1번&hellip;
자신의 머리 위의 수를 소인수분해한다.
소인수분해를 통해 나온 약수들이 나온 개수만큼 모두 더해준다.
자기 자신과 같은 수 일 때는 자기 자신을 세지않으므로 조심하자.
코드: 사용언어 : python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import math N=int(input()) a=[] d=dict() for i in range(N): a.append(int(input())) d[a[-1]] = d.]]></description>
</item><item>
    <title>[백준]1188 음식 평론가</title>
    <link>https://jyukki97.github.io/1188/</link>
    <pubDate>Fri, 18 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/1188/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1188
풀이: 소시지가 N개 평론가가 M명 있을 때,
각각의 평론가는 N/M개의 소시지를 가지고 간다. (그러므로 만약, N이 M으로 나누어 떨어진다면 소시지를 자르지 않아도 된다.) =&gt; GCD(N, M) = M
N개의 소시지를 이어붙여 1개의 소시지로 만든다면, 소시지는 M - 1번 잘라야 한다. =&gt; GCD(N, M) = 1
즉, M - GCD(N, M) 번 자른다면 평론가들은 모두 동일한 양의 소시지를 얻을 수 있다.
코드: 사용언어 : python
1 2 3  import math n,m=map(int,input().]]></description>
</item><item>
    <title>[백준]1089 스타트링크 타워</title>
    <link>https://jyukki97.github.io/1089/</link>
    <pubDate>Thu, 17 Jun 2021 00:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/1089/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1089
풀이: 5 * 3 자리에서 각 자리에 &lsquo;#&rsquo; 이 들어올 경우 될 수 없는 숫자를 찾아놓는다.
ex) (0, 0) 자리에 &lsquo;#&rsquo; 이 올 경우 1은 절대 될 수 없다.
첫 번 째 숫자 부터 N까지의 숫자를 찾아가면서 가능한 숫자를 저장해놓는다.
가능한 숫자를 모두 조합한다면, 너무 많은 조합이 가능하므로 다른 방법을 사용한다.
ex) 각 자리에 [1], [2, 3], [1, 8, 9] 가 가능하다면, 만들 수 있는 조합은
121, 128, 129, 131, 138, 139 로 총 6가지 이다.]]></description>
</item><item>
    <title>[백준]14614 Calculate!</title>
    <link>https://jyukki97.github.io/2020-12-26-14614/</link>
    <pubDate>Sat, 26 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-12-26-14614/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/14614
풀이: C가 짝수라면 A를
C가 홀수라면 A 와 B를 XOR한 값을 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10  #include &lt;iostream&gt;using namespace std; int main() { int a, b; string c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if ((int)(c[c.size() - 1] - &#39;0&#39;) % 2) a ^= b; cout &lt;&lt; a &lt;&lt; endl; }   ]]></description>
</item><item>
    <title>[백준]1356 유진수</title>
    <link>https://jyukki97.github.io/2020-04-26-1356/</link>
    <pubDate>Sun, 26 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-04-26-1356/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1356
풀이: 1의 자릿수 == 10의 자릿수*&hellip;*n자릿수
1의 자릿수 * 10의 자릿수 == 100의 자릿수 *&hellip;*n자릿수
.
.
.
1의 자릿수*&hellip;*n-1자릿수 == n 자릿수
중 앞의 값과 뒤의 값이 같은 것이 하나라도 있다면, YES를
하나도 없다면 NO를 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11  #include &lt;iostream&gt;using namespace std; int n = 1, m = 1, i, t, f; string s; int main() { cin &gt;&gt; s; for (i = 1; i &lt; s.]]></description>
</item><item>
    <title>[백준]1334 다음 팰린드롬 수</title>
    <link>https://jyukki97.github.io/2020-04-12-1334/</link>
    <pubDate>Sun, 12 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-04-12-1334/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1334
풀이: 문자열 S를 받아온다.
S의 길이를 N이라고 하자.
S의 오른쪽 절반의 값을 왼쪽 절반의 값으로 덮어쓰자.
그렇게 만들어진 문자열을 A라고 하자.
A는 이미 펠린드롬 수 인데, 이 수가 S보다 크다면 A를 그대로 출력한다.
만약 S보다 작다면,
가운데 수를 1씩 증가시킨다.
가운데 수가 9가 됐다면, 0으로 바꾸고 오른쪽, 왼쪽 수를 1씩 증가시킨다.
더 커질 때까지 반복한 후 A를 출력한다.
만약 S가 9로만 이루어진 수라면, 맨 앞수를 1로 바꾸고 그 것을 제외한 모든수를 0으로 바꾼 후 1을 추가한 후 출력한다.]]></description>
</item><item>
    <title>[백준]2864 5와 6의 차이</title>
    <link>https://jyukki97.github.io/2020-03-18-2864/</link>
    <pubDate>Wed, 18 Mar 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-03-18-2864/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/2864
풀이: 두 정수 A 와 B 의 숫자 중
5 와 6 을 전부 5 로 바꾼 값들을 더한 값이 최솟값,
6 으로 바꾼 값들을 더한 값이 최댓값이 된다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include &lt;iostream&gt;#include &lt;string&gt;using namespace std; int main() { string a, b, c, d, e, f; cin &gt;&gt; a &gt;&gt; b; for (char i : a) if (i == 54 || i == 53)	c += &#39;6&#39;, d += &#39;5&#39;; else c += i, d += i; for (char i : b) if (i == 54 || i == 53)	e += &#39;6&#39;, f += &#39;5&#39;; else e += i, f += i; printf(&#34;%d %d\n&#34;, stoi(d) + stoi(f), stoi(c) + stoi(e)); }   ]]></description>
</item><item>
    <title>[백준]1024 수열의 합</title>
    <link>https://jyukki97.github.io/2020-03-06-1024/</link>
    <pubDate>Fri, 06 Mar 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-03-06-1024/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1024
풀이: 길이가 적어도 L인 수열은 다음과 같이 나타낼 수 있다.
1  n	n + 1	n + 2	...	n + L - 2	n + L - 1   즉, 길이가 L인 수열들의 합은
L * n + Σ k (k = 1 ~ L - 1) = N
( N - Σ k (k = 1 ~ L - 1) ) % L == 0]]></description>
</item><item>
    <title>[백준]1057 토너먼트</title>
    <link>https://jyukki97.github.io/2020-03-04-1057/</link>
    <pubDate>Wed, 04 Mar 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-03-04-1057/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1057
풀이: ​	1	2
​	1	2	3	4
1	2	3	4	5	6	7	8
현재 번호가 i 라고 할 때,
위로 갈 수록 배정받는 번호는 (i + 1) / 2 가 된다.
즉, 김지민과 임한수의 번호가 x, y 라고 할 때,
( x + 1 ) / 2 == ( y + 1 ) / 2
가 되는 순간이 둘이 대결하는 순간이다.
토너먼트가 끝날 때까지 둘이 대결하지 않는 경우는 없으므로 -1 출력은 하지않는다.]]></description>
</item></channel>
</rss>
