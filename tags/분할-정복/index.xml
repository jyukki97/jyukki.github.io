<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>분할 정복 - 标签 - JYUKKI&#39;s BLOG</title>
        <link>https://jyukki97.github.io/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/</link>
        <description>분할 정복 - 标签 - JYUKKI&#39;s BLOG</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 25 Feb 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jyukki97.github.io/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/" rel="self" type="application/rss+xml" /><item>
    <title>[백준]1780 종이의 개수</title>
    <link>https://jyukki97.github.io/2020-02-25-1780/</link>
    <pubDate>Tue, 25 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://jyukki97.github.io/2020-02-25-1780/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1780
풀이: [백준]2630 색종이 만들기 참고
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  #include &lt;iostream&gt;using namespace std; int n, c[2200][2200], W = 0, B = 0, D = 0; void se(int x, int y, int a) { bool w = true, b = true, d = true; for (int i = 0; i &lt; a; i++) for (int t = 0; t &lt; a; t++) if (!]]></description>
</item><item>
    <title>[백준]1992 쿼드트리</title>
    <link>https://jyukki97.github.io/2020-02-25-1992/</link>
    <pubDate>Tue, 25 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://jyukki97.github.io/2020-02-25-1992/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1992
풀이: [백준]2630 색종이 만들기 참고
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include &lt;iostream&gt;#include &lt;string&gt;using namespace std; int n; string s, c[65]; void se(int x, int y, int a) { if (x &gt;= n || y &gt;= n || !]]></description>
</item><item>
    <title>[백준]2630 색종이 만들기</title>
    <link>https://jyukki97.github.io/2020-02-25-2630/</link>
    <pubDate>Tue, 25 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://jyukki97.github.io/2020-02-25-2630/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/2630
풀이: n을 2로 나누어 가며 1로 이루어진 곳인지 0으로 이루어진 곳인지 판단한다.
0으로 이루어져있다면 W를 +1 , 1로 이루어져있다면 B를 +1 해준다.
하얀색 색종이와 파란색 색종이의 갯수를 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include &lt;iostream&gt;using namespace std; int n, c[129][129], W = 0, B = 0; void se(int x, int y, int a) { if (x &gt;= n || y &gt;= n || !]]></description>
</item><item>
    <title>[백준]6549 히스토그램에서 가장 큰 직사각형</title>
    <link>https://jyukki97.github.io/2020-02-25-6549/</link>
    <pubDate>Tue, 25 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://jyukki97.github.io/2020-02-25-6549/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/6549
풀이: 값을 하나씩 받아온다.
현재 값보다 스택에 있는 값이 더 크다면,
max(현재 max값, 스택의 탑값 * (스택의 탑 바로 전 값의 위치와 현재 위치의 차이)) 을 수행하고, 현재 탑에 있는 값을 pop한다.
스택에 모든 값이 현재 있는 값보다 작거나 같다면, 스택에 현재 값을 push한다.
모든 값을 받았다면, 스택이 빌 때까지
max(현재 max값, 스택의 탑값 * (스택의 탑 바로 전 값의 위치와 전체 히스토그램의 길이의 차이))
를 수행한다.
히스토그램의 길이가 0일경우 반복을 중지한다.]]></description>
</item><item>
    <title>[백준]11729 하노이 탑 이동 순서</title>
    <link>https://jyukki97.github.io/2020-02-18-11729/</link>
    <pubDate>Tue, 18 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://jyukki97.github.io/2020-02-18-11729/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/11729
풀이: https://jyukki97.github.io/blog/2020-02-18-towerofhanoi/ 를 참고
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include &lt;iostream&gt;using namespace std; void h(int n, int a, int b, int c) { if (!n) return; else { h(n - 1, a, c, b); printf(&#34;%d %d\n&#34;, a, b); h(n - 1, c, b, a); } } int main() { int n, a = 1; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) a *= 2; cout &lt;&lt; a - 1 &lt;&lt; endl; h(n, 1, 3, 2); return 0; }   ]]></description>
</item></channel>
</rss>
