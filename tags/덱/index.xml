<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>덱 - Tag - JYUKKI&#39;s BLOG</title>
        <link>https://jyukki97.github.io/tags/%EB%8D%B1/</link>
        <description>덱 - Tag - JYUKKI&#39;s BLOG</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 29 Jun 2021 22:00:40 &#43;0800</lastBuildDate><atom:link href="https://jyukki97.github.io/tags/%EB%8D%B1/" rel="self" type="application/rss+xml" /><item>
    <title>[백준]11003 최솟값 찾기</title>
    <link>https://jyukki97.github.io/11003/</link>
    <pubDate>Tue, 29 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/11003/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/11003
풀이: dequeue를 사용하는 문제이다.
간단하게 풀 수 있다.
0 번째 숫자부터 N번째 숫자까지 진행한다.
현재 위치가 i일 때, 큐에 마지막에 들어있는 값이 현재 위치의 값보다 크다면, pop한다. 이 것을 현재 위치의 값이 더 클 때까지 반복한다.
즉, 큐의 마지막 값이 현재 값보다 작은 값이 나올때까지 반복하게 된다.
큐의 마지막 값이 현재 값보다 작거나, 큐가 비어있다면, 큐에 마지막에 현재 값을 push해준다.
맨 앞이 가장 작은 값이기에 맨 앞의 값을 출력해줄 것이나, 맨 앞에 값이 i-L+1 ~ i 사이에 오는 값인지 확인하는 작업이 필요하다.]]></description>
</item><item>
    <title>[백준]5430 AC</title>
    <link>https://jyukki97.github.io/2020-02-24-5430/</link>
    <pubDate>Mon, 24 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-02-24-5430/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/5430
풀이: 배열안에 들어있는 원소를
R이 나오면 뒤집고,
D가 나오면 맨 앞 숫자를 버린다.
만약 D가 나왔는데, 배열이 비어있다면, error 를 출력한다.
시간초과에 주의하자 : cout &raquo; printf, cin &raquo; scanf
특히 strlen을 주의하자 시간을 많이잡아먹는다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include &lt;iostream&gt;#include &lt;string.]]></description>
</item></channel>
</rss>
