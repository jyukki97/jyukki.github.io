<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>최소 스패닝 트리 - Tag - JYUKKI&#39;s BLOG</title>
        <link>http://jyukki97.github.io/tags/%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%AC/</link>
        <description>최소 스패닝 트리 - Tag - JYUKKI&#39;s BLOG</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 16 Mar 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://jyukki97.github.io/tags/%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%AC/" rel="self" type="application/rss+xml" /><item>
    <title>[백준]1922 네트워크 연결</title>
    <link>http://jyukki97.github.io/2020-03-16-1922/</link>
    <pubDate>Mon, 16 Mar 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://jyukki97.github.io/2020-03-16-1922/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1922
풀이: [백준]1197 최소 스패닝 트리 참고
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std; typedef pair&lt;int, int&gt; P; int N, E, q, w, e, b[1002] = { 1,1 }; int main() { cin &gt;&gt; N &gt;&gt; E; vector&lt;priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt;&gt; a(N + 1); vector&lt;int&gt; v = { 1 }; for (int i = 0; i &lt; E; i++) { cin &gt;&gt; q &gt;&gt; w &gt;&gt; e; a[q].]]></description>
</item><item>
    <title>[백준]1197 최소 스패닝 트리</title>
    <link>http://jyukki97.github.io/2020-03-07-1197/</link>
    <pubDate>Sat, 07 Mar 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://jyukki97.github.io/2020-03-07-1197/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1197
풀이: 배열 v를 현재 만들어진 트리에 들어있는 노드들의 집합 이라고 하자.
시작할 때 배열 v에 1 하나만 넣고 시작한다.
배열 v를 모두 순회하여 현재 트리에서 뻗어갈 수 있고, 가중치가 가장 작은 간선을 찾는다.
간선을 연결 한 후 연결된 노드를 배열 v에 저장한다.
배열 v에 모든 정점이 들어올때까지 반복한다.
트리에 모든 가중치를 더해 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std; typedef pair&lt;int, int&gt; P; int N, E, q, w, e, b[10002] = { 1,1 }; vector&lt;priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt;&gt; a; int main() { cin &gt;&gt; N &gt;&gt; E; a.]]></description>
</item></channel>
</rss>
