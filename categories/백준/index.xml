<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>백준 - Category - JYUKKI&#39;s BLOG</title>
        <link>https://jyukki97.github.io/categories/%EB%B0%B1%EC%A4%80/</link>
        <description>백준 - Category - JYUKKI&#39;s BLOG</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 26 Dec 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jyukki97.github.io/categories/%EB%B0%B1%EC%A4%80/" rel="self" type="application/rss+xml" /><item>
    <title>[백준]14614 Calculate!</title>
    <link>https://jyukki97.github.io/2020-12-26-14614/</link>
    <pubDate>Sat, 26 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-12-26-14614/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/14614
풀이: C가 짝수라면 A를
C가 홀수라면 A 와 B를 XOR한 값을 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10  #include &lt;iostream&gt;using namespace std; int main() { int a, b; string c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if ((int)(c[c.size() - 1] - &#39;0&#39;) % 2) a ^= b; cout &lt;&lt; a &lt;&lt; endl; }   ]]></description>
</item><item>
    <title>[백준]14612 김식당</title>
    <link>https://jyukki97.github.io/2020-12-25-14612/</link>
    <pubDate>Fri, 25 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-12-25-14612/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/14612
풀이: order를 &lt;주문시간, 테이블번호&gt; 를 변수로 하는 vector에 차곡차곡 쌓는다.
각 주문이 끝난 후 vector의 들어있는 테이블 번호를 순서대로 출력한다.
만약 sort가 들어왔다면, 주문시간을 기준으로 vector를 정렬한다
만약 complete가 들어왔다면, 완성된 테이블 번호를 vector에서 제거한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std; int main() { int n, m, a, b, i; vector&lt;pair&lt;int, int&gt;&gt; v; cin &gt;&gt; n &gt;&gt; m; while (n--) { string s; cin &gt;&gt; s; if (s == &#34;order&#34;) { cin &gt;&gt; a &gt;&gt; b; v.]]></description>
</item><item>
    <title>[백준]12778 CTP공국으로 이민 가자</title>
    <link>https://jyukki97.github.io/2020-12-24-12778/</link>
    <pubDate>Thu, 24 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-12-24-12778/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/12778
풀이: 만약 C라면,
문자열을 숫자로 출력한다.
만약 N이라면,
숫자를 문자열로 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include &lt;iostream&gt;using namespace std; int main() { int a, i, n; char b; cin &gt;&gt; n; while (n--) { cin &gt;&gt; a &gt;&gt; b; if (b == &#39;C&#39;) { for (i = 0; i &lt; a; i++) { char c; cin &gt;&gt; c; cout &lt;&lt; (int)(c - &#39;A&#39; + 1) &lt;&lt; &#34; &#34;; } } else { for (i = 0; i &lt; a; i++) { int c; cin &gt;&gt; c; cout &lt;&lt; (char)(&#39;A&#39; + c - 1) &lt;&lt; &#34; &#34;; } } cout &lt;&lt; endl; } }   ]]></description>
</item><item>
    <title>[백준]12779 상품 is 뭔들</title>
    <link>https://jyukki97.github.io/2020-12-24-12779/</link>
    <pubDate>Thu, 24 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-12-24-12779/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/12779
풀이: 약수의 갯수가 홀수라는 것은 &ldquo;제곱수&rdquo; 라는 것을 의미한다.
그러므로 제곱수의 갯수 / 전체 갯수를 한다면 답을 구할 수 있다.
주의
 확률이 0일 경우 0을 출력해야한다. 2^60 까지의 숫자이므로 int형에 들어갈 수 없다. 기약분수로 출력해야하므로 최대 공약수로 나누어주는 작업을 해주자.  코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include &lt;iostream&gt;#include &lt;math.]]></description>
</item><item>
    <title>[백준]12780 원피스</title>
    <link>https://jyukki97.github.io/2020-12-24-12780/</link>
    <pubDate>Thu, 24 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-12-24-12780/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/12780
풀이: H의 1번 문자열부터 끝까지 검사하며 N이 몇 번 등장하는지 확인한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13  #include &lt;iostream&gt;#include &lt;string&gt;using namespace std; int main() { string s, a; int c = 0; cin &gt;&gt; s &gt;&gt; a; for (int i = 0; i &lt;= s.length() - a.length(); i++) { if (s.substr(i, a.length()) == a) c++; } cout &lt;&lt; c &lt;&lt; endl; }   ]]></description>
</item><item>
    <title>[백준]1388 바닥 장식</title>
    <link>https://jyukki97.github.io/2020-04-27-1388/</link>
    <pubDate>Mon, 27 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-04-27-1388/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1388
풀이: 같은 행에 연속된 &lsquo;-&rsquo; 이 몇 쌍이 있는지 센다.
같은 방식으로
같은 열에 연속된 &lsquo;|&rsquo; 이 몇 쌍이 있는지 센다.
두 수를 더하여 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13  #include &lt;iostream&gt;using namespace std; int n, m, i, t, c; string s[105]; int main() { cin &gt;&gt; n &gt;&gt; m; for (; i &lt; n; i++)	cin &gt;&gt; s[i]; for (i = 0; i &lt; n; i++) for (t = 0; t &lt; m; t++) { if (s[i][t] == &#39;-&#39;)if (t == m - 1 || s[i][t + 1] == &#39;|&#39;)c++; if (s[i][t] == &#39;|&#39;)if (i == n - 1 || s[i + 1][t] == &#39;-&#39;)c++; } cout &lt;&lt; c &lt;&lt; endl; }   ]]></description>
</item><item>
    <title>[백준]1356 유진수</title>
    <link>https://jyukki97.github.io/2020-04-26-1356/</link>
    <pubDate>Sun, 26 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-04-26-1356/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1356
풀이: 1의 자릿수 == 10의 자릿수*&hellip;*n자릿수
1의 자릿수 * 10의 자릿수 == 100의 자릿수 *&hellip;*n자릿수
.
.
.
1의 자릿수*&hellip;*n-1자릿수 == n 자릿수
중 앞의 값과 뒤의 값이 같은 것이 하나라도 있다면, YES를
하나도 없다면 NO를 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11  #include &lt;iostream&gt;using namespace std; int n = 1, m = 1, i, t, f; string s; int main() { cin &gt;&gt; s; for (i = 1; i &lt; s.]]></description>
</item><item>
    <title>[백준]1268 임시 반장 정하기</title>
    <link>https://jyukki97.github.io/2020-04-25-1268/</link>
    <pubDate>Sat, 25 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-04-25-1268/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1268
풀이: 현재 상태에서 제일 많은 학생수를 S, 그 학생수를 가진 학생을 C라고 하자.
1번 학생이 몇 명의 학생과 같은 반을 했었는지를 저장하고,
그 값이 S보다 많다면 S를 교체하고 C에 1을 저장한다.
.
.
.
n번 학생이 몇 명의 학생과 같은 반을 했었는지를 저장하고,
그 값이 S보다 많다면 S를 교체하고 C에 n을 저장한다.
전체를 다 탐색 한 후 C를 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include &lt;iostream&gt;using namespace std; int n, i, t, y, d, s, c, a[1005][5], b[1005][1005]; int main() { cin &gt;&gt; n; for (; i &lt; n; i++) for (t = 0; t &lt; 5; t++) cin &gt;&gt; a[i][t]; for (i = 0; i &lt; n; i++, d = 0) { for (t = 0; t &lt; 5; t++) for (y = 0; y &lt; n; y++) if (a[i][t] == a[y][t])d += !]]></description>
</item><item>
    <title>[백준]1236 성 지키기</title>
    <link>https://jyukki97.github.io/2020-04-24-1236/</link>
    <pubDate>Fri, 24 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-04-24-1236/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1236
풀이: 각 행에 경비병이 있는지 없는지 탐색한다.
경비병이 없는 행의 갯수를 Sn이라고 하자.
각 열에 경비병이 있는지 없는지 탐색한다.
경비병이 없는 열의 갯수를 Sm이라고 하자.
각 행과 열에는 경비병이 1명씩은 있어야 하므로
Sn과 Sm 중 최댓값을 출력한다.
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13  #include &lt;iostream&gt;using namespace std; int n, m, i, t, a[55], b[55], q, w; char c; int main() { cin &gt;&gt; n &gt;&gt; m; for (; i &lt; n; i++) for (t = 0; t &lt; m; t++) { cin &gt;&gt; c; if (c == &#39;X&#39;)	q+=!]]></description>
</item><item>
    <title>[백준]17265 나의 인생에는 수학과 함께</title>
    <link>https://jyukki97.github.io/2020-04-23-17265/</link>
    <pubDate>Thu, 23 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-04-23-17265/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/17265
풀이: 최단 거리이므로 오른쪽과 아래쪽으로만 이동한다.
현재 위치가 연산자라면,
이전까지 연산해왔던 값을 x라고 하자
연잔자를 ㅁ 라고 하고,
다음 이동할 곳의 숫자를 y라고 하자.
현재 위치의 연산자를 이용하여 x ㅁ y 를 연산한 후 다음 숫자로 이동한다.
현재 위치가 숫자라면, 현재 위치가 학교인지 판단 후
학교가 아니라면 오른쪽 또는 아래로 이동한다.
학교라면 현재까지 연산해왔던 값이 지금 저장해 놓은 최댓값보다 크다면 교체한다.
또한 현재까지 연산해왔던 값이 지금 저장해 놓은 최솟값보다 작다면 교체한다.]]></description>
</item></channel>
</rss>
