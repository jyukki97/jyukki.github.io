<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>백준 - Category - JYUKKI&#39;s BLOG</title>
        <link>https://jyukki97.github.io/categories/%EB%B0%B1%EC%A4%80/</link>
        <description>백준 - Category - JYUKKI&#39;s BLOG</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 24 Jun 2021 22:00:40 &#43;0800</lastBuildDate><atom:link href="https://jyukki97.github.io/categories/%EB%B0%B1%EC%A4%80/" rel="self" type="application/rss+xml" /><item>
    <title>[백준]6593 상범 빌딩</title>
    <link>https://jyukki97.github.io/6593/</link>
    <pubDate>Thu, 24 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/6593/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/6593
풀이: BFS 문제이다.
현재 위치에서 오른쪽, 왼쪽, 위, 아래, 앞, 뒤 6방향을 모두 검사하고 갈 수 있다면, 큐에 집어넣는 방식으로 풀 수 있다.
주의사항  이미 방문한 위치는 표시하여 다시 방문하지 않게 해주도록 하자.
  출력 형식을 주의 깊게 보자. 틀렸습니다의 절반 이상이 이 문제일 가능성이 높다.
   처음에 파이썬으로 풀었는데 답 제출에서 IndexOutOfBound가 뜨더라&hellip; 분명히 정답이 뜬 c++ 코드와 같은 코드인데 문제를 모르겠다.]]></description>
</item><item>
    <title>[백준]4811 알약</title>
    <link>https://jyukki97.github.io/4811/</link>
    <pubDate>Wed, 23 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/4811/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/4811
풀이: 카탈란 수 문제이다.
깔끔하게 카탈란 수로 풀어주자.
$${2nCn \over n + 1}$$
코드: 사용언어 : python
1 2  from math import factorial as f while a:=int(input()): print(f(2*a)//(f(a)*f(a+1)))   ]]></description>
</item><item>
    <title>[백준]9252 LCS 2</title>
    <link>https://jyukki97.github.io/9252/</link>
    <pubDate>Tue, 22 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/9252/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/9252
풀이:    0 A C A Y K P     C 0 1 1 1 1 1   A 1 1 2 2 2 2   P 1 1 2 2 2 2   C 1 2 2 2 2 3   A 1 2 3 3 3 3   K 1 2 3 3 4 4    첫 번째 문자열을 : A]]></description>
</item><item>
    <title>[백준]2493 탑</title>
    <link>https://jyukki97.github.io/2493/</link>
    <pubDate>Mon, 21 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2493/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/2493
풀이: 현재 탑의 높이보다 더 높은 위치에 있는 탑을 찾아야 하므로 스택을 이용하도록 한다.
탑의 맨 오른쪽 부터 계산을 시작한다.
현재 위치에 탑의 높이가 스택의 top에 있는 탑의 높이보다 높다면, 스택의 top을 pop 하고, 그 탑의 수신탑의 위치값을 현재 탑의 위치로 바꿔준다.
스택의 top의 있는 탑의 높이가 현재 위치의 탑의 높이보다 작거나 같을 때까지 반복하고,
스택에 현재 탑을 push해준다.
왼쪽 끝까지 모든 탑을 확인했다면, 수신탑의 위치값을 출력해준다. 만약 수신탑을 찾지 못한 탑들은 0으로 출력한다.]]></description>
</item><item>
    <title>[백준]1323 숫자 연결하기</title>
    <link>https://jyukki97.github.io/1323/</link>
    <pubDate>Sun, 20 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/1323/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1323
풀이: 나머지 연산의 성질을 이용한다.
나머지 연산의 경우 연산에 어디에 나머지 연산을 추가하든 나머지 연산의 값만 동일하다면, 최종 값도 동일하게 나온다.
그러므로 주어진 N을 K로 나눈 나머지를 확인하고,
0이 아니라면, 나온 나머지를 N과 연결하여 다시 K로 나눈 나머지를 확인한다.
0이 나올 때까지 반복한다.
나머지 연산 특성상 일정 개수 이상일 경우 반복하기 때문에 무한루프에 빠질 수 있다. 그러므로 최대 K번을 넘기지 않는다.
코드: 사용언어 : python
1 2 3 4 5 6 7  n,k=map(int,input().]]></description>
</item><item>
    <title>[백준]1241 머리 톡톡</title>
    <link>https://jyukki97.github.io/1241/</link>
    <pubDate>Sat, 19 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/1241/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1241
풀이: 1번 부터 N번까지 학생들의 머리 위의 숫자들의 개수를 저장해놓는다
ex) 2는 2번, 1은 1번&hellip;
자신의 머리 위의 수를 소인수분해한다.
소인수분해를 통해 나온 약수들이 나온 개수만큼 모두 더해준다.
자기 자신과 같은 수 일 때는 자기 자신을 세지않으므로 조심하자.
코드: 사용언어 : python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import math N=int(input()) a=[] d=dict() for i in range(N): a.append(int(input())) d[a[-1]] = d.]]></description>
</item><item>
    <title>[백준]1188 음식 평론가</title>
    <link>https://jyukki97.github.io/1188/</link>
    <pubDate>Fri, 18 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/1188/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1188
풀이: 소시지가 N개 평론가가 M명 있을 때,
각각의 평론가는 N/M개의 소시지를 가지고 간다. (그러므로 만약, N이 M으로 나누어 떨어진다면 소시지를 자르지 않아도 된다.) =&gt; GCD(N, M) = M
N개의 소시지를 이어붙여 1개의 소시지로 만든다면, 소시지는 M - 1번 잘라야 한다. =&gt; GCD(N, M) = 1
즉, M - GCD(N, M) 번 자른다면 평론가들은 모두 동일한 양의 소시지를 얻을 수 있다.
코드: 사용언어 : python
1 2 3  import math n,m=map(int,input().]]></description>
</item><item>
    <title>[백준]1092 배</title>
    <link>https://jyukki97.github.io/1092/</link>
    <pubDate>Thu, 17 Jun 2021 22:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/1092/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1092
풀이: 크레인과 박스를 정렬한다
단, 이때 정렬은 내림차순으로 해야한다. 오름차순으로 할 경우 안되는 경우의 수가 존재.
정렬된 크레인과 박스의 맨 처음을 비교한다. 만약 박스의 무게가 더 크다면, 모든 박스를 옮길 수 없으므로 -1을 출력한다.
크레인을 한칸씩 오른쪽으로 이동시키면서 박스를 확인한다. 옮긴 박스는 0으로 바꾸고, 이미 0인 박스는 지나친다.
모든 크레인을 사용했다면 time을 1늘리고, 다시 반복한다.
모든 박스를 옮길 때까지 반복한 후 time을 출력한다.
코드: 사용언어 : python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  a,b,c,d=int(input()),list(map(int, input().]]></description>
</item><item>
    <title>[백준]1089 스타트링크 타워</title>
    <link>https://jyukki97.github.io/1089/</link>
    <pubDate>Thu, 17 Jun 2021 00:00:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/1089/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1089
풀이: 5 * 3 자리에서 각 자리에 &lsquo;#&rsquo; 이 들어올 경우 될 수 없는 숫자를 찾아놓는다.
ex) (0, 0) 자리에 &lsquo;#&rsquo; 이 올 경우 1은 절대 될 수 없다.
첫 번 째 숫자 부터 N까지의 숫자를 찾아가면서 가능한 숫자를 저장해놓는다.
가능한 숫자를 모두 조합한다면, 너무 많은 조합이 가능하므로 다른 방법을 사용한다.
ex) 각 자리에 [1], [2, 3], [1, 8, 9] 가 가능하다면, 만들 수 있는 조합은
121, 128, 129, 131, 138, 139 로 총 6가지 이다.]]></description>
</item><item>
    <title>[백준]12787 지금 밥이 문제냐</title>
    <link>https://jyukki97.github.io/2021-01-04-12787/</link>
    <pubDate>Mon, 04 Jan 2021 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2021-01-04-12787/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/12787
풀이: IPv8 주소가 주어진다면, 정수로
정수가 주어진다면, IPv8 주소로 변환하여 출력한다.
정수의 범위가 64비트이므로 unsigned long long 형을 사용하도록 하자!!
코드: 사용언어 : c++
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string.h&gt;#define ul unsigned long long using namespace std; ul c; int main() { int i, t, y, n, m, d; cin &gt;&gt; n; while (n--) { string s; cin &gt;&gt; m; if (m == 1) { char *r = new char[40], *e; cin &gt;&gt; r; i = 8, c = 0; e = strtok(r, &#34;.]]></description>
</item></channel>
</rss>
